// This file is auto-generated by @hey-api/openapi-ts

export const APIKeySchema = {
  properties: {
    id: {
      type: "string",
      format: "uuid",
      title: "Id",
      description: "Unique identifier",
    },
    created_at: {
      anyOf: [
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Created At",
      description: "Creation datetime",
    },
    updated_at: {
      anyOf: [
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Updated At",
      description: "Update datetime",
    },
    name: {
      anyOf: [
        {
          type: "string",
          maxLength: 3000,
          minLength: 0,
        },
        {
          type: "null",
        },
      ],
      title: "Name",
    },
    project_id: {
      anyOf: [
        {
          type: "string",
          format: "uuid",
        },
        {
          type: "null",
        },
      ],
      title: "Project Id",
    },
    key_type: {
      $ref: "#/components/schemas/APIKeyType",
      default: "user",
    },
    user_id: {
      type: "string",
      title: "User Id",
    },
    redacted_api_key: {
      type: "string",
      title: "Redacted Api Key",
    },
  },
  type: "object",
  required: ["id", "user_id", "redacted_api_key"],
  title: "APIKey",
  description: "Schema for an API Key.",
} as const;

export const APIKeyCreateSchema = {
  properties: {
    name: {
      anyOf: [
        {
          type: "string",
          maxLength: 3000,
          minLength: 0,
        },
        {
          type: "null",
        },
      ],
      title: "Name",
    },
    project_id: {
      anyOf: [
        {
          type: "string",
          format: "uuid",
        },
        {
          type: "null",
        },
      ],
      title: "Project Id",
      description: "The project ID to associate with the API key.",
    },
    key_type: {
      $ref: "#/components/schemas/APIKeyType",
      default: "user",
    },
  },
  type: "object",
  title: "APIKeyCreate",
  description: "Schema for creating an API key.",
} as const;

export const APIKeyQueryResponseSchema = {
  properties: {
    items: {
      items: {
        $ref: "#/components/schemas/APIKey",
      },
      type: "array",
      title: "Items",
      description: "The list of items.",
    },
    next_page_token: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Next Page Token",
      description:
        "A token, which can be sent as page_token to retrieve the next page. If this field is omitted, there are no subsequent pages.",
    },
    total_size: {
      anyOf: [
        {
          type: "integer",
        },
        {
          type: "null",
        },
      ],
      title: "Total Size",
      description:
        "The total number of items available. This is only populated when specifically requested. The value may be an estimate and can be used for display purposes only.",
    },
  },
  type: "object",
  required: ["items"],
  title: "APIKeyQueryResponse",
  description: "Response schema for paginated API key queries.",
} as const;

export const APIKeyTypeSchema = {
  type: "string",
  enum: ["user", "agent"],
  title: "APIKeyType",
} as const;

export const AdvancedModeTransformConfigSchema = {
  properties: {
    mode: {
      type: "string",
      const: "advanced",
      title: "Mode",
      default: "advanced",
    },
    segmentation_config: {
      anyOf: [
        {
          $ref: "#/components/schemas/NoneSegmentationConfig",
        },
        {
          $ref: "#/components/schemas/PageSegmentationConfig",
        },
        {
          $ref: "#/components/schemas/ElementSegmentationConfig",
        },
      ],
      title: "Segmentation Config",
      description: "Configuration for the segmentation.",
    },
    chunking_config: {
      anyOf: [
        {
          $ref: "#/components/schemas/NoneChunkingConfig",
        },
        {
          $ref: "#/components/schemas/CharacterChunkingConfig",
        },
        {
          $ref: "#/components/schemas/TokenChunkingConfig",
        },
        {
          $ref: "#/components/schemas/SentenceChunkingConfig",
        },
        {
          $ref: "#/components/schemas/SemanticChunkingConfig",
        },
      ],
      title: "Chunking Config",
      description: "Configuration for the chunking.",
    },
  },
  type: "object",
  title: "AdvancedModeTransformConfig",
} as const;

export const AgentDataSchema = {
  properties: {
    id: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Id",
    },
    deployment_name: {
      type: "string",
      title: "Deployment Name",
    },
    collection: {
      type: "string",
      title: "Collection",
      default: "default",
    },
    data: {
      additionalProperties: true,
      type: "object",
      title: "Data",
    },
    created_at: {
      anyOf: [
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Created At",
    },
    updated_at: {
      anyOf: [
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Updated At",
    },
  },
  type: "object",
  required: ["deployment_name", "data"],
  title: "AgentData",
  description: "API Result for a single agent data item",
} as const;

export const AgentDataCreateSchema = {
  properties: {
    deployment_name: {
      type: "string",
      title: "Deployment Name",
    },
    collection: {
      type: "string",
      title: "Collection",
      default: "default",
    },
    data: {
      additionalProperties: true,
      type: "object",
      title: "Data",
    },
  },
  type: "object",
  required: ["deployment_name", "data"],
  title: "AgentDataCreate",
  description: "API request model for creating agent data",
} as const;

export const AgentDataUpdateSchema = {
  properties: {
    data: {
      additionalProperties: true,
      type: "object",
      title: "Data",
    },
  },
  type: "object",
  required: ["data"],
  title: "AgentDataUpdate",
  description: "API request model for updating agent data",
} as const;

export const AgentDeploymentListSchema = {
  properties: {
    deployments: {
      items: {
        $ref: "#/components/schemas/AgentDeploymentSummary",
      },
      type: "array",
      title: "Deployments",
      description: "List of deployments",
    },
  },
  type: "object",
  required: ["deployments"],
  title: "AgentDeploymentList",
} as const;

export const AgentDeploymentSummarySchema = {
  properties: {
    id: {
      type: "string",
      title: "Id",
      description: "Deployment ID. Prefixed with dpl-",
    },
    project_id: {
      type: "string",
      format: "uuid",
      title: "Project Id",
      description: "Project ID",
    },
    deployment_name: {
      type: "string",
      title: "Deployment Name",
      description: "Identifier of the deployed app",
    },
    thumbnail_url: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Thumbnail Url",
      description: "Thumbnail URL of the deployed app",
    },
    base_url: {
      type: "string",
      title: "Base Url",
      description: "Base URL of the deployed app",
    },
    created_at: {
      type: "string",
      format: "date-time",
      title: "Created At",
      description: "Timestamp when the app deployment was created",
    },
    updated_at: {
      type: "string",
      format: "date-time",
      title: "Updated At",
      description: "Timestamp when the app deployment was last updated",
    },
    api_key_id: {
      anyOf: [
        {
          type: "string",
          format: "uuid",
        },
        {
          type: "null",
        },
      ],
      title: "Api Key Id",
      description: "API key ID",
    },
  },
  type: "object",
  required: [
    "id",
    "project_id",
    "deployment_name",
    "base_url",
    "created_at",
    "updated_at",
  ],
  title: "AgentDeploymentSummary",
} as const;

export const AggregateGroupSchema = {
  properties: {
    group_key: {
      additionalProperties: true,
      type: "object",
      title: "Group Key",
    },
    count: {
      anyOf: [
        {
          type: "integer",
        },
        {
          type: "null",
        },
      ],
      title: "Count",
    },
    first_item: {
      anyOf: [
        {
          additionalProperties: true,
          type: "object",
        },
        {
          type: "null",
        },
      ],
      title: "First Item",
    },
  },
  type: "object",
  required: ["group_key"],
  title: "AggregateGroup",
  description: "API Result for a single group in the aggregate response",
} as const;

export const AggregateRequestSchema = {
  properties: {
    page_size: {
      anyOf: [
        {
          type: "integer",
        },
        {
          type: "null",
        },
      ],
      title: "Page Size",
      description:
        "The maximum number of items to return. The service may return fewer than this value. If unspecified, a default page size will be used. The maximum value is typically 1000; values above this will be coerced to the maximum.",
    },
    page_token: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Page Token",
      description:
        "A page token, received from a previous list call. Provide this to retrieve the subsequent page.",
    },
    filter: {
      anyOf: [
        {
          additionalProperties: {
            $ref: "#/components/schemas/FilterOperation",
          },
          type: "object",
        },
        {
          type: "null",
        },
      ],
      title: "Filter",
      description:
        "A filter object or expression that filters resources listed in the response.",
    },
    order_by: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Order By",
      description:
        "A comma-separated list of fields to order by, sorted in ascending order. Use 'field_name desc' to specify descending order.",
    },
    deployment_name: {
      type: "string",
      title: "Deployment Name",
      description: "The agent deployment's name to aggregate data for",
    },
    collection: {
      type: "string",
      title: "Collection",
      description: "The logical agent data collection to aggregate data for",
      default: "default",
    },
    group_by: {
      anyOf: [
        {
          items: {
            type: "string",
          },
          type: "array",
        },
        {
          type: "null",
        },
      ],
      title: "Group By",
      description:
        "The fields to group by. If empty, the entire dataset is grouped on. e.g. if left out, can be used for simple count operations",
    },
    count: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Count",
      description: "Whether to count the number of items in each group",
      default: false,
    },
    first: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "First",
      description:
        "Whether to return the first item in each group (Sorted by created_at)",
      default: false,
    },
    offset: {
      anyOf: [
        {
          type: "integer",
          maximum: 1000,
          minimum: 0,
        },
        {
          type: "null",
        },
      ],
      title: "Offset",
      description:
        "The offset to start from. If not provided, the first page is returned",
      default: 0,
    },
  },
  type: "object",
  required: ["deployment_name"],
  title: "AggregateRequest",
  description: "API request body for aggregating agent data",
} as const;

export const AppChatInputParamsSchema = {
  properties: {
    messages: {
      items: {
        $ref: "#/components/schemas/InputMessage",
      },
      type: "array",
      title: "Messages",
    },
  },
  type: "object",
  title: "AppChatInputParams",
  description: "This is the input schema for the chat app endpoint",
  examples: [
    {
      messages: [
        {
          content: "Hello",
          role: "user",
        },
      ],
    },
  ],
} as const;

export const AutoTransformConfigSchema = {
  properties: {
    mode: {
      type: "string",
      const: "auto",
      title: "Mode",
      default: "auto",
    },
    chunk_size: {
      type: "integer",
      exclusiveMinimum: 0,
      title: "Chunk Size",
      description: "Chunk size for the transformation.",
      default: 1024,
    },
    chunk_overlap: {
      type: "integer",
      title: "Chunk Overlap",
      description: "Chunk overlap for the transformation.",
      default: 200,
      gte: 0,
    },
  },
  type: "object",
  title: "AutoTransformConfig",
} as const;

export const AzureOpenAIEmbeddingSchema = {
  properties: {
    model_name: {
      type: "string",
      title: "Model Name",
      description: "The name of the OpenAI embedding model.",
      default: "text-embedding-ada-002",
    },
    embed_batch_size: {
      type: "integer",
      maximum: 2048,
      exclusiveMinimum: 0,
      title: "Embed Batch Size",
      description: "The batch size for embedding calls.",
      default: 10,
    },
    num_workers: {
      anyOf: [
        {
          type: "integer",
        },
        {
          type: "null",
        },
      ],
      title: "Num Workers",
      description: "The number of workers to use for async embedding calls.",
    },
    additional_kwargs: {
      additionalProperties: true,
      type: "object",
      title: "Additional Kwargs",
      description: "Additional kwargs for the OpenAI API.",
    },
    api_key: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Api Key",
      description: "The OpenAI API key.",
    },
    api_base: {
      type: "string",
      title: "Api Base",
      description: "The base URL for Azure deployment.",
      default: "",
    },
    api_version: {
      type: "string",
      title: "Api Version",
      description: "The version for Azure OpenAI API.",
      default: "",
    },
    max_retries: {
      type: "integer",
      title: "Max Retries",
      description: "Maximum number of retries.",
      default: 10,
      gte: 0,
    },
    timeout: {
      type: "number",
      title: "Timeout",
      description: "Timeout for each request.",
      default: 60,
      gte: 0,
    },
    default_headers: {
      anyOf: [
        {
          additionalProperties: {
            type: "string",
          },
          type: "object",
        },
        {
          type: "null",
        },
      ],
      title: "Default Headers",
      description: "The default headers for API requests.",
    },
    reuse_client: {
      type: "boolean",
      title: "Reuse Client",
      description:
        "Reuse the OpenAI client between requests. When doing anything with large volumes of async API calls, setting this to false can improve stability.",
      default: true,
    },
    dimensions: {
      anyOf: [
        {
          type: "integer",
        },
        {
          type: "null",
        },
      ],
      title: "Dimensions",
      description:
        "The number of dimensions on the output embedding vectors. Works only with v3 embedding models.",
    },
    azure_endpoint: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Azure Endpoint",
      description: "The Azure endpoint to use.",
    },
    azure_deployment: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Azure Deployment",
      description: "The Azure deployment to use.",
    },
    class_name: {
      type: "string",
      title: "Class Name",
      default: "AzureOpenAIEmbedding",
    },
  },
  type: "object",
  title: "AzureOpenAIEmbedding",
} as const;

export const AzureOpenAIEmbeddingConfigSchema = {
  properties: {
    type: {
      type: "string",
      const: "AZURE_EMBEDDING",
      title: "Type",
      description: "Type of the embedding model.",
      default: "AZURE_EMBEDDING",
    },
    component: {
      $ref: "#/components/schemas/AzureOpenAIEmbedding",
      description: "Configuration for the Azure OpenAI embedding model.",
    },
  },
  type: "object",
  title: "AzureOpenAIEmbeddingConfig",
} as const;

export const BaseConnectionValidationSchema = {
  properties: {
    success: {
      type: "boolean",
      title: "Success",
    },
    message: {
      type: "string",
      title: "Message",
    },
  },
  type: "object",
  required: ["success", "message"],
  title: "BaseConnectionValidation",
  description: "Base response model for connection validation.",
} as const;

export const BasePlanSchema = {
  properties: {
    id: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Id",
      description: "The ID of the plan in Metronome",
    },
    name: {
      type: "string",
      enum: [
        "free",
        "llama_parse",
        "enterprise",
        "unknown",
        "free_contract",
        "pro",
        "enterprise_contract",
        "enterprise_poc",
        "free_v1",
        "starter_v1",
        "pro_v1",
      ],
      title: "Name",
    },
    metronome_plan_type: {
      type: "string",
      enum: ["plan", "contract"],
      title: "Metronome Plan Type",
    },
    metronome_rate_card_alias: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Metronome Rate Card Alias",
    },
    limits: {
      $ref: "#/components/schemas/PlanLimits",
    },
    recurring_credits: {
      anyOf: [
        {
          items: {
            $ref: "#/components/schemas/RecurringCreditGrant",
          },
          type: "array",
        },
        {
          type: "null",
        },
      ],
      title: "Recurring Credits",
    },
    plan_frequency: {
      type: "string",
      enum: ["MONTHLY", "QUARTERLY", "ANNUAL"],
      title: "Plan Frequency",
    },
    metronome_customer_id: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Metronome Customer Id",
      description: "The ID of the customer in Metronome",
    },
    starting_on: {
      anyOf: [
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Starting On",
      description: "The date the plan starts on",
    },
    ending_before: {
      anyOf: [
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Ending Before",
      description: "The date the plan ends on",
    },
    current_billing_period: {
      anyOf: [
        {
          $ref: "#/components/schemas/BillingPeriod",
        },
        {
          type: "null",
        },
      ],
      description: "The current billing period",
    },
    is_payment_failed: {
      type: "boolean",
      title: "Is Payment Failed",
      description:
        "Whether the organization has a failed payment that requires support contact",
      default: false,
    },
    failure_count: {
      type: "integer",
      title: "Failure Count",
      description: "The number of payment failures for this organization",
      default: 0,
    },
  },
  type: "object",
  required: [
    "name",
    "metronome_plan_type",
    "metronome_rate_card_alias",
    "limits",
    "plan_frequency",
  ],
  title: "BasePlan",
} as const;

export const BatchSchema = {
  properties: {
    tool: {
      type: "string",
      title: "Tool",
      description: "The tool to be used for all requests in the batch.",
    },
    tool_data: {
      anyOf: [
        {
          $ref: "#/components/schemas/LlamaParseParameters",
        },
        {
          type: "null",
        },
      ],
      description: "The data to be used for the tool.",
    },
    input_type: {
      type: "string",
      title: "Input Type",
      description:
        "The type of input file. Currently only 'datasource' is supported.",
    },
    input_id: {
      type: "string",
      title: "Input Id",
      description: "The ID of the input file for the batch.",
    },
    output_type: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Output Type",
      description:
        "The type of output file. Currently only 'datasource' is supported.",
      default: "internal",
    },
    output_id: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Output Id",
      description: "The ID of the output file for the batch.",
    },
    id: {
      type: "string",
      title: "Id",
      description: "Unique identifier for the batch",
    },
    project_id: {
      type: "string",
      title: "Project Id",
      description: "The ID of the project to which the batch belongs",
    },
    organization_id: {
      type: "string",
      title: "Organization Id",
      description: "The ID of the organization to which the batch belongs",
    },
    user_id: {
      type: "string",
      title: "User Id",
      description: "The ID of the user who created the batch",
    },
    external_id: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "External Id",
      description:
        "A developer-provided ID for the batch. This ID will be returned in the response.",
    },
    completion_window: {
      type: "integer",
      title: "Completion Window",
      description: "The time frame within which the batch should be processed",
    },
    pipeline_id: {
      type: "string",
      title: "Pipeline Id",
      description: "The ID of the pipeline to which the batch belongs",
    },
    status: {
      type: "string",
      title: "Status",
      description: "The current status of the batch",
    },
    created_at: {
      anyOf: [
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Created At",
      description:
        "The Unix timestamp (in seconds) for when the batch was created",
    },
    updated_at: {
      anyOf: [
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Updated At",
      description:
        "The Unix timestamp (in seconds) for when the batch was last updated",
    },
  },
  type: "object",
  required: [
    "tool",
    "input_type",
    "input_id",
    "id",
    "project_id",
    "organization_id",
    "user_id",
    "completion_window",
    "pipeline_id",
    "status",
  ],
  title: "Batch",
} as const;

export const BatchCreateSchema = {
  properties: {
    tool: {
      type: "string",
      title: "Tool",
      description: "The tool to be used for all requests in the batch.",
    },
    tool_data: {
      anyOf: [
        {
          $ref: "#/components/schemas/LlamaParseParameters",
        },
        {
          type: "null",
        },
      ],
      description: "The data to be used for the tool.",
    },
    input_type: {
      type: "string",
      title: "Input Type",
      description:
        "The type of input file. Currently only 'datasource' is supported.",
    },
    input_id: {
      type: "string",
      title: "Input Id",
      description: "The ID of the input file for the batch.",
    },
    output_type: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Output Type",
      description:
        "The type of output file. Currently only 'datasource' is supported.",
      default: "internal",
    },
    output_id: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Output Id",
      description: "The ID of the output file for the batch.",
    },
    project_id: {
      type: "string",
      format: "uuid",
      title: "Project Id",
      description: "The ID of the project to which the batch belongs",
    },
    external_id: {
      type: "string",
      title: "External Id",
      description:
        "A developer-provided ID for the batch. This ID will be returned in the response.",
    },
    completion_window: {
      type: "integer",
      title: "Completion Window",
      description:
        "The time frame within which the batch should be processed. Currently only 24h is supported.",
      default: 86400,
    },
  },
  type: "object",
  required: ["tool", "input_type", "input_id", "project_id", "external_id"],
  title: "BatchCreate",
} as const;

export const BatchItemSchema = {
  properties: {
    id: {
      type: "string",
      title: "Id",
      description: "Unique identifier for the batch item",
    },
    batch_id: {
      type: "string",
      title: "Batch Id",
      description: "The ID of the batch to which the item belongs",
    },
    status: {
      type: "string",
      title: "Status",
      description: "The current status of the batch item",
    },
    status_updated_at: {
      anyOf: [
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Status Updated At",
      description:
        "The Unix timestamp (in seconds) for when the batch item status was last updated",
    },
    created_at: {
      anyOf: [
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Created At",
      description:
        "The Unix timestamp (in seconds) for when the batch item was created",
    },
    updated_at: {
      anyOf: [
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Updated At",
      description:
        "The Unix timestamp (in seconds) for when the batch item was last updated",
    },
    input_file: {
      type: "string",
      title: "Input File",
      description: "The input file associated with the batch item",
    },
    output_file: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Output File",
      description: "The output file associated with the batch item",
    },
    task: {
      anyOf: [
        {
          $ref: "#/components/schemas/FileParsePublic",
        },
        {
          type: "null",
        },
      ],
      description: "Worker Task for that item",
    },
  },
  type: "object",
  required: ["id", "batch_id", "status", "input_file"],
  title: "BatchItem",
} as const;

export const BatchPaginatedListSchema = {
  properties: {
    data: {
      items: {
        $ref: "#/components/schemas/Batch",
      },
      type: "array",
      title: "Data",
      description: "List of batches",
    },
    limit: {
      type: "integer",
      title: "Limit",
      description: "Pagination limit",
    },
    offset: {
      type: "integer",
      title: "Offset",
      description: "Pagination offset",
    },
    total_count: {
      type: "integer",
      title: "Total Count",
      description: "Total number of batches",
    },
  },
  type: "object",
  required: ["data", "limit", "offset", "total_count"],
  title: "BatchPaginatedList",
} as const;

export const BatchPublicOutputSchema = {
  properties: {
    batch: {
      $ref: "#/components/schemas/Batch",
    },
    batch_items: {
      items: {
        $ref: "#/components/schemas/BatchItem",
      },
      type: "array",
      title: "Batch Items",
    },
    ingestion_status: {
      $ref: "#/components/schemas/ManagedIngestionStatusResponse",
    },
  },
  type: "object",
  required: ["batch", "batch_items", "ingestion_status"],
  title: "BatchPublicOutput",
} as const;

export const BedrockEmbeddingSchema = {
  properties: {
    model_name: {
      type: "string",
      title: "Model Name",
      description: "The modelId of the Bedrock model to use.",
      default: "amazon.titan-embed-text-v1",
    },
    embed_batch_size: {
      type: "integer",
      maximum: 2048,
      exclusiveMinimum: 0,
      title: "Embed Batch Size",
      description: "The batch size for embedding calls.",
      default: 10,
    },
    num_workers: {
      anyOf: [
        {
          type: "integer",
        },
        {
          type: "null",
        },
      ],
      title: "Num Workers",
      description: "The number of workers to use for async embedding calls.",
    },
    profile_name: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Profile Name",
      description:
        "The name of aws profile to use. If not given, then the default profile is used.",
    },
    aws_access_key_id: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Aws Access Key Id",
      description: "AWS Access Key ID to use",
    },
    aws_secret_access_key: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Aws Secret Access Key",
      description: "AWS Secret Access Key to use",
    },
    aws_session_token: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Aws Session Token",
      description: "AWS Session Token to use",
    },
    region_name: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Region Name",
      description:
        "AWS region name to use. Uses region configured in AWS CLI if not passed",
    },
    max_retries: {
      type: "integer",
      exclusiveMinimum: 0,
      title: "Max Retries",
      description: "The maximum number of API retries.",
      default: 10,
    },
    timeout: {
      type: "number",
      title: "Timeout",
      description:
        "The timeout for the Bedrock API request in seconds. It will be used for both connect and read timeouts.",
      default: 60,
    },
    additional_kwargs: {
      additionalProperties: true,
      type: "object",
      title: "Additional Kwargs",
      description: "Additional kwargs for the bedrock client.",
    },
    class_name: {
      type: "string",
      title: "Class Name",
      default: "BedrockEmbedding",
    },
  },
  type: "object",
  title: "BedrockEmbedding",
} as const;

export const BedrockEmbeddingConfigSchema = {
  properties: {
    type: {
      type: "string",
      const: "BEDROCK_EMBEDDING",
      title: "Type",
      description: "Type of the embedding model.",
      default: "BEDROCK_EMBEDDING",
    },
    component: {
      $ref: "#/components/schemas/BedrockEmbedding",
      description: "Configuration for the Bedrock embedding model.",
    },
  },
  type: "object",
  title: "BedrockEmbeddingConfig",
} as const;

export const BillingPeriodSchema = {
  properties: {
    start_date: {
      type: "string",
      format: "date-time",
      title: "Start Date",
    },
    end_date: {
      type: "string",
      format: "date-time",
      title: "End Date",
    },
  },
  type: "object",
  required: ["start_date", "end_date"],
  title: "BillingPeriod",
} as const;

export const Body_import_pipeline_metadata_api_v1_pipelines__pipeline_id__metadata_putSchema =
  {
    properties: {
      upload_file: {
        type: "string",
        format: "binary",
        title: "Upload File",
      },
    },
    type: "object",
    required: ["upload_file"],
    title:
      "Body_import_pipeline_metadata_api_v1_pipelines__pipeline_id__metadata_put",
  } as const;

export const Body_run_job_on_file_api_v1_extraction_jobs_file_postSchema = {
  properties: {
    extraction_agent_id: {
      type: "string",
      format: "uuid",
      title: "Extraction Agent Id",
      description: "The id of the extraction agent",
    },
    file: {
      type: "string",
      format: "binary",
      title: "File",
      description: "The file to run the job on",
    },
    data_schema_override: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Data Schema Override",
      description:
        "The data schema to override the extraction agent's data schema with as a JSON string",
    },
    config_override: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Config Override",
      description:
        "The config to override the extraction agent's config with as a JSON string",
    },
  },
  type: "object",
  required: ["extraction_agent_id", "file"],
  title: "Body_run_job_on_file_api_v1_extraction_jobs_file_post",
} as const;

export const Body_screenshot_api_parsing_screenshot_postSchema = {
  properties: {
    file: {
      anyOf: [
        {
          type: "string",
          format: "binary",
        },
        {
          type: "null",
        },
      ],
      title: "File",
    },
    do_not_cache: {
      type: "boolean",
      title: "Do Not Cache",
      default: false,
    },
    http_proxy: {
      type: "string",
      title: "Http Proxy",
    },
    input_s3_path: {
      type: "string",
      title: "Input S3 Path",
      default: "",
    },
    input_s3_region: {
      type: "string",
      title: "Input S3 Region",
      default: "",
    },
    input_url: {
      type: "string",
      title: "Input Url",
    },
    invalidate_cache: {
      type: "boolean",
      title: "Invalidate Cache",
      default: false,
    },
    max_pages: {
      anyOf: [
        {
          type: "integer",
        },
        {
          type: "null",
        },
      ],
      title: "Max Pages",
    },
    output_s3_path_prefix: {
      type: "string",
      title: "Output S3 Path Prefix",
      default: "",
    },
    output_s3_region: {
      type: "string",
      title: "Output S3 Region",
      default: "",
    },
    target_pages: {
      type: "string",
      title: "Target Pages",
      default: "",
    },
    webhook_url: {
      type: "string",
      title: "Webhook Url",
      default: "",
    },
    webhook_configurations: {
      type: "string",
      title: "Webhook Configurations",
      default: "",
    },
    job_timeout_in_seconds: {
      type: "number",
      title: "Job Timeout In Seconds",
    },
    job_timeout_extra_time_per_page_in_seconds: {
      type: "number",
      title: "Job Timeout Extra Time Per Page In Seconds",
    },
  },
  type: "object",
  title: "Body_screenshot_api_parsing_screenshot_post",
} as const;

export const Body_screenshot_api_v1_parsing_screenshot_postSchema = {
  properties: {
    file: {
      anyOf: [
        {
          type: "string",
          format: "binary",
        },
        {
          type: "null",
        },
      ],
      title: "File",
    },
    do_not_cache: {
      type: "boolean",
      title: "Do Not Cache",
      default: false,
    },
    http_proxy: {
      type: "string",
      title: "Http Proxy",
    },
    input_s3_path: {
      type: "string",
      title: "Input S3 Path",
      default: "",
    },
    input_s3_region: {
      type: "string",
      title: "Input S3 Region",
      default: "",
    },
    input_url: {
      type: "string",
      title: "Input Url",
    },
    invalidate_cache: {
      type: "boolean",
      title: "Invalidate Cache",
      default: false,
    },
    max_pages: {
      anyOf: [
        {
          type: "integer",
        },
        {
          type: "null",
        },
      ],
      title: "Max Pages",
    },
    output_s3_path_prefix: {
      type: "string",
      title: "Output S3 Path Prefix",
      default: "",
    },
    output_s3_region: {
      type: "string",
      title: "Output S3 Region",
      default: "",
    },
    target_pages: {
      type: "string",
      title: "Target Pages",
      default: "",
    },
    webhook_url: {
      type: "string",
      title: "Webhook Url",
      default: "",
    },
    webhook_configurations: {
      type: "string",
      title: "Webhook Configurations",
      default: "",
    },
    job_timeout_in_seconds: {
      type: "number",
      title: "Job Timeout In Seconds",
    },
    job_timeout_extra_time_per_page_in_seconds: {
      type: "number",
      title: "Job Timeout Extra Time Per Page In Seconds",
    },
  },
  type: "object",
  title: "Body_screenshot_api_v1_parsing_screenshot_post",
} as const;

export const Body_upload_file_api_parsing_upload_postSchema = {
  properties: {
    file: {
      anyOf: [
        {
          type: "string",
          format: "binary",
        },
        {
          type: "null",
        },
      ],
      title: "File",
    },
    adaptive_long_table: {
      type: "boolean",
      title: "Adaptive Long Table",
      default: false,
    },
    annotate_links: {
      type: "boolean",
      title: "Annotate Links",
      default: false,
    },
    auto_mode: {
      type: "boolean",
      title: "Auto Mode",
      default: false,
    },
    auto_mode_trigger_on_image_in_page: {
      type: "boolean",
      title: "Auto Mode Trigger On Image In Page",
      default: false,
    },
    auto_mode_trigger_on_table_in_page: {
      type: "boolean",
      title: "Auto Mode Trigger On Table In Page",
      default: false,
    },
    auto_mode_trigger_on_text_in_page: {
      type: "string",
      title: "Auto Mode Trigger On Text In Page",
    },
    auto_mode_trigger_on_regexp_in_page: {
      type: "string",
      title: "Auto Mode Trigger On Regexp In Page",
    },
    auto_mode_configuration_json: {
      type: "string",
      title: "Auto Mode Configuration Json",
    },
    azure_openai_api_version: {
      type: "string",
      title: "Azure Openai Api Version",
    },
    azure_openai_deployment_name: {
      type: "string",
      title: "Azure Openai Deployment Name",
    },
    azure_openai_endpoint: {
      type: "string",
      title: "Azure Openai Endpoint",
    },
    azure_openai_key: {
      type: "string",
      title: "Azure Openai Key",
    },
    bbox_bottom: {
      type: "number",
      title: "Bbox Bottom",
    },
    bbox_left: {
      type: "number",
      title: "Bbox Left",
    },
    bbox_right: {
      type: "number",
      title: "Bbox Right",
    },
    bbox_top: {
      type: "number",
      title: "Bbox Top",
    },
    compact_markdown_table: {
      type: "boolean",
      title: "Compact Markdown Table",
      default: false,
    },
    disable_ocr: {
      type: "boolean",
      title: "Disable Ocr",
      default: false,
    },
    disable_reconstruction: {
      type: "boolean",
      title: "Disable Reconstruction",
      default: false,
    },
    disable_image_extraction: {
      type: "boolean",
      title: "Disable Image Extraction",
      default: false,
    },
    do_not_cache: {
      type: "boolean",
      title: "Do Not Cache",
      default: false,
    },
    do_not_unroll_columns: {
      type: "boolean",
      title: "Do Not Unroll Columns",
      default: false,
    },
    extract_charts: {
      type: "boolean",
      title: "Extract Charts",
      default: false,
    },
    guess_xlsx_sheet_name: {
      type: "boolean",
      title: "Guess Xlsx Sheet Name",
      default: false,
    },
    high_res_ocr: {
      type: "boolean",
      title: "High Res Ocr",
      default: false,
    },
    html_make_all_elements_visible: {
      type: "boolean",
      title: "Html Make All Elements Visible",
      default: false,
    },
    layout_aware: {
      type: "boolean",
      title: "Layout Aware",
      default: false,
    },
    specialized_chart_parsing_agentic: {
      type: "boolean",
      title: "Specialized Chart Parsing Agentic",
      default: false,
    },
    specialized_chart_parsing_plus: {
      type: "boolean",
      title: "Specialized Chart Parsing Plus",
      default: false,
    },
    specialized_chart_parsing_efficient: {
      type: "boolean",
      title: "Specialized Chart Parsing Efficient",
      default: false,
    },
    specialized_image_parsing: {
      type: "boolean",
      title: "Specialized Image Parsing",
      default: false,
    },
    precise_bounding_box: {
      type: "boolean",
      title: "Precise Bounding Box",
      default: false,
    },
    html_remove_fixed_elements: {
      type: "boolean",
      title: "Html Remove Fixed Elements",
      default: false,
    },
    html_remove_navigation_elements: {
      type: "boolean",
      title: "Html Remove Navigation Elements",
      default: false,
    },
    http_proxy: {
      type: "string",
      title: "Http Proxy",
    },
    input_s3_path: {
      type: "string",
      title: "Input S3 Path",
      default: "",
    },
    input_s3_region: {
      type: "string",
      title: "Input S3 Region",
      default: "",
    },
    input_url: {
      type: "string",
      title: "Input Url",
    },
    invalidate_cache: {
      type: "boolean",
      title: "Invalidate Cache",
      default: false,
    },
    language: {
      items: {
        $ref: "#/components/schemas/ParserLanguages",
      },
      type: "array",
      title: "Language",
      default: ["en"],
    },
    extract_layout: {
      type: "boolean",
      title: "Extract Layout",
      default: false,
    },
    max_pages: {
      anyOf: [
        {
          type: "integer",
        },
        {
          type: "null",
        },
      ],
      title: "Max Pages",
    },
    merge_tables_across_pages_in_markdown: {
      type: "boolean",
      title: "Merge Tables Across Pages In Markdown",
      default: false,
    },
    outlined_table_extraction: {
      type: "boolean",
      title: "Outlined Table Extraction",
      default: false,
    },
    output_pdf_of_document: {
      type: "boolean",
      title: "Output Pdf Of Document",
      default: false,
    },
    output_s3_path_prefix: {
      type: "string",
      title: "Output S3 Path Prefix",
      default: "",
    },
    output_s3_region: {
      type: "string",
      title: "Output S3 Region",
      default: "",
    },
    page_prefix: {
      type: "string",
      title: "Page Prefix",
      default: "",
    },
    page_separator: {
      type: "string",
      title: "Page Separator",
    },
    page_suffix: {
      type: "string",
      title: "Page Suffix",
      default: "",
    },
    preserve_layout_alignment_across_pages: {
      type: "boolean",
      title: "Preserve Layout Alignment Across Pages",
      default: false,
    },
    preserve_very_small_text: {
      type: "boolean",
      title: "Preserve Very Small Text",
      default: false,
    },
    skip_diagonal_text: {
      type: "boolean",
      title: "Skip Diagonal Text",
      default: false,
    },
    spreadsheet_extract_sub_tables: {
      type: "boolean",
      title: "Spreadsheet Extract Sub Tables",
      default: true,
    },
    spreadsheet_force_formula_computation: {
      type: "boolean",
      title: "Spreadsheet Force Formula Computation",
      default: false,
    },
    inline_images_in_markdown: {
      type: "boolean",
      title: "Inline Images In Markdown",
      default: false,
    },
    structured_output: {
      type: "boolean",
      title: "Structured Output",
      default: false,
    },
    structured_output_json_schema: {
      type: "string",
      title: "Structured Output Json Schema",
    },
    structured_output_json_schema_name: {
      type: "string",
      title: "Structured Output Json Schema Name",
    },
    take_screenshot: {
      type: "boolean",
      title: "Take Screenshot",
      default: false,
    },
    target_pages: {
      type: "string",
      title: "Target Pages",
      default: "",
    },
    vendor_multimodal_api_key: {
      type: "string",
      title: "Vendor Multimodal Api Key",
      default: "",
    },
    vendor_multimodal_model_name: {
      type: "string",
      title: "Vendor Multimodal Model Name",
    },
    model: {
      type: "string",
      title: "Model",
    },
    webhook_url: {
      type: "string",
      title: "Webhook Url",
      default: "",
    },
    webhook_configurations: {
      type: "string",
      title: "Webhook Configurations",
      default: "",
    },
    preset: {
      type: "string",
      title: "Preset",
      default: "",
    },
    parse_mode: {
      anyOf: [
        {
          $ref: "#/components/schemas/ParsingMode",
        },
        {
          type: "null",
        },
      ],
    },
    page_error_tolerance: {
      type: "number",
      title: "Page Error Tolerance",
      default: 0.05,
    },
    replace_failed_page_mode: {
      anyOf: [
        {
          $ref: "#/components/schemas/FailPageMode",
        },
        {
          type: "null",
        },
      ],
    },
    replace_failed_page_with_error_message_prefix: {
      type: "string",
      title: "Replace Failed Page With Error Message Prefix",
      default: "",
    },
    replace_failed_page_with_error_message_suffix: {
      type: "string",
      title: "Replace Failed Page With Error Message Suffix",
      default: "",
    },
    system_prompt: {
      type: "string",
      title: "System Prompt",
      default: "",
    },
    system_prompt_append: {
      type: "string",
      title: "System Prompt Append",
      default: "",
    },
    user_prompt: {
      type: "string",
      title: "User Prompt",
      default: "",
    },
    job_timeout_in_seconds: {
      type: "number",
      title: "Job Timeout In Seconds",
    },
    job_timeout_extra_time_per_page_in_seconds: {
      type: "number",
      title: "Job Timeout Extra Time Per Page In Seconds",
    },
    strict_mode_image_extraction: {
      type: "boolean",
      title: "Strict Mode Image Extraction",
      default: false,
    },
    strict_mode_image_ocr: {
      type: "boolean",
      title: "Strict Mode Image Ocr",
      default: false,
    },
    strict_mode_reconstruction: {
      type: "boolean",
      title: "Strict Mode Reconstruction",
      default: false,
    },
    strict_mode_buggy_font: {
      type: "boolean",
      title: "Strict Mode Buggy Font",
      default: false,
    },
    save_images: {
      type: "boolean",
      title: "Save Images",
      default: true,
    },
    ignore_document_elements_for_layout_detection: {
      type: "boolean",
      title: "Ignore Document Elements For Layout Detection",
      default: false,
    },
    output_tables_as_HTML: {
      type: "boolean",
      title: "Output Tables As Html",
      default: false,
    },
    markdown_table_multiline_header_separator: {
      type: "string",
      title: "Markdown Table Multiline Header Separator",
    },
    use_vendor_multimodal_model: {
      type: "boolean",
      title: "Use Vendor Multimodal Model",
      default: false,
    },
    bounding_box: {
      type: "string",
      title: "Bounding Box",
      default: "",
    },
    gpt4o_mode: {
      type: "boolean",
      title: "Gpt4O Mode",
      default: false,
    },
    gpt4o_api_key: {
      type: "string",
      title: "Gpt4O Api Key",
      default: "",
    },
    complemental_formatting_instruction: {
      type: "string",
      title: "Complemental Formatting Instruction",
    },
    content_guideline_instruction: {
      type: "string",
      title: "Content Guideline Instruction",
    },
    premium_mode: {
      type: "boolean",
      title: "Premium Mode",
      default: false,
    },
    is_formatting_instruction: {
      type: "boolean",
      title: "Is Formatting Instruction",
      default: true,
    },
    continuous_mode: {
      type: "boolean",
      title: "Continuous Mode",
      default: false,
    },
    parsing_instruction: {
      type: "string",
      title: "Parsing Instruction",
      default: "",
    },
    fast_mode: {
      type: "boolean",
      title: "Fast Mode",
      default: false,
    },
    formatting_instruction: {
      type: "string",
      title: "Formatting Instruction",
    },
    hide_headers: {
      type: "boolean",
      title: "Hide Headers",
      default: false,
    },
    hide_footers: {
      type: "boolean",
      title: "Hide Footers",
      default: false,
    },
    page_header_prefix: {
      type: "string",
      title: "Page Header Prefix",
    },
    page_header_suffix: {
      type: "string",
      title: "Page Header Suffix",
    },
    page_footer_prefix: {
      type: "string",
      title: "Page Footer Prefix",
    },
    page_footer_suffix: {
      type: "string",
      title: "Page Footer Suffix",
    },
  },
  type: "object",
  title: "Body_upload_file_api_parsing_upload_post",
} as const;

export const Body_upload_file_api_v1_files_postSchema = {
  properties: {
    upload_file: {
      type: "string",
      format: "binary",
      title: "Upload File",
    },
  },
  type: "object",
  required: ["upload_file"],
  title: "Body_upload_file_api_v1_files_post",
} as const;

export const Body_upload_file_api_v1_parsing_upload_postSchema = {
  properties: {
    file: {
      anyOf: [
        {
          type: "string",
          format: "binary",
        },
        {
          type: "null",
        },
      ],
      title: "File",
    },
    adaptive_long_table: {
      type: "boolean",
      title: "Adaptive Long Table",
      default: false,
    },
    annotate_links: {
      type: "boolean",
      title: "Annotate Links",
      default: false,
    },
    auto_mode: {
      type: "boolean",
      title: "Auto Mode",
      default: false,
    },
    auto_mode_trigger_on_image_in_page: {
      type: "boolean",
      title: "Auto Mode Trigger On Image In Page",
      default: false,
    },
    auto_mode_trigger_on_table_in_page: {
      type: "boolean",
      title: "Auto Mode Trigger On Table In Page",
      default: false,
    },
    auto_mode_trigger_on_text_in_page: {
      type: "string",
      title: "Auto Mode Trigger On Text In Page",
    },
    auto_mode_trigger_on_regexp_in_page: {
      type: "string",
      title: "Auto Mode Trigger On Regexp In Page",
    },
    auto_mode_configuration_json: {
      type: "string",
      title: "Auto Mode Configuration Json",
    },
    azure_openai_api_version: {
      type: "string",
      title: "Azure Openai Api Version",
    },
    azure_openai_deployment_name: {
      type: "string",
      title: "Azure Openai Deployment Name",
    },
    azure_openai_endpoint: {
      type: "string",
      title: "Azure Openai Endpoint",
    },
    azure_openai_key: {
      type: "string",
      title: "Azure Openai Key",
    },
    bbox_bottom: {
      type: "number",
      title: "Bbox Bottom",
    },
    bbox_left: {
      type: "number",
      title: "Bbox Left",
    },
    bbox_right: {
      type: "number",
      title: "Bbox Right",
    },
    bbox_top: {
      type: "number",
      title: "Bbox Top",
    },
    compact_markdown_table: {
      type: "boolean",
      title: "Compact Markdown Table",
      default: false,
    },
    disable_ocr: {
      type: "boolean",
      title: "Disable Ocr",
      default: false,
    },
    disable_reconstruction: {
      type: "boolean",
      title: "Disable Reconstruction",
      default: false,
    },
    disable_image_extraction: {
      type: "boolean",
      title: "Disable Image Extraction",
      default: false,
    },
    do_not_cache: {
      type: "boolean",
      title: "Do Not Cache",
      default: false,
    },
    do_not_unroll_columns: {
      type: "boolean",
      title: "Do Not Unroll Columns",
      default: false,
    },
    extract_charts: {
      type: "boolean",
      title: "Extract Charts",
      default: false,
    },
    guess_xlsx_sheet_name: {
      type: "boolean",
      title: "Guess Xlsx Sheet Name",
      default: false,
    },
    high_res_ocr: {
      type: "boolean",
      title: "High Res Ocr",
      default: false,
    },
    html_make_all_elements_visible: {
      type: "boolean",
      title: "Html Make All Elements Visible",
      default: false,
    },
    layout_aware: {
      type: "boolean",
      title: "Layout Aware",
      default: false,
    },
    specialized_chart_parsing_agentic: {
      type: "boolean",
      title: "Specialized Chart Parsing Agentic",
      default: false,
    },
    specialized_chart_parsing_plus: {
      type: "boolean",
      title: "Specialized Chart Parsing Plus",
      default: false,
    },
    specialized_chart_parsing_efficient: {
      type: "boolean",
      title: "Specialized Chart Parsing Efficient",
      default: false,
    },
    specialized_image_parsing: {
      type: "boolean",
      title: "Specialized Image Parsing",
      default: false,
    },
    precise_bounding_box: {
      type: "boolean",
      title: "Precise Bounding Box",
      default: false,
    },
    html_remove_fixed_elements: {
      type: "boolean",
      title: "Html Remove Fixed Elements",
      default: false,
    },
    html_remove_navigation_elements: {
      type: "boolean",
      title: "Html Remove Navigation Elements",
      default: false,
    },
    http_proxy: {
      type: "string",
      title: "Http Proxy",
    },
    input_s3_path: {
      type: "string",
      title: "Input S3 Path",
      default: "",
    },
    input_s3_region: {
      type: "string",
      title: "Input S3 Region",
      default: "",
    },
    input_url: {
      type: "string",
      title: "Input Url",
    },
    invalidate_cache: {
      type: "boolean",
      title: "Invalidate Cache",
      default: false,
    },
    language: {
      items: {
        $ref: "#/components/schemas/ParserLanguages",
      },
      type: "array",
      title: "Language",
      default: ["en"],
    },
    extract_layout: {
      type: "boolean",
      title: "Extract Layout",
      default: false,
    },
    max_pages: {
      anyOf: [
        {
          type: "integer",
        },
        {
          type: "null",
        },
      ],
      title: "Max Pages",
    },
    merge_tables_across_pages_in_markdown: {
      type: "boolean",
      title: "Merge Tables Across Pages In Markdown",
      default: false,
    },
    outlined_table_extraction: {
      type: "boolean",
      title: "Outlined Table Extraction",
      default: false,
    },
    output_pdf_of_document: {
      type: "boolean",
      title: "Output Pdf Of Document",
      default: false,
    },
    output_s3_path_prefix: {
      type: "string",
      title: "Output S3 Path Prefix",
      default: "",
    },
    output_s3_region: {
      type: "string",
      title: "Output S3 Region",
      default: "",
    },
    page_prefix: {
      type: "string",
      title: "Page Prefix",
      default: "",
    },
    page_separator: {
      type: "string",
      title: "Page Separator",
    },
    page_suffix: {
      type: "string",
      title: "Page Suffix",
      default: "",
    },
    preserve_layout_alignment_across_pages: {
      type: "boolean",
      title: "Preserve Layout Alignment Across Pages",
      default: false,
    },
    preserve_very_small_text: {
      type: "boolean",
      title: "Preserve Very Small Text",
      default: false,
    },
    skip_diagonal_text: {
      type: "boolean",
      title: "Skip Diagonal Text",
      default: false,
    },
    spreadsheet_extract_sub_tables: {
      type: "boolean",
      title: "Spreadsheet Extract Sub Tables",
      default: true,
    },
    spreadsheet_force_formula_computation: {
      type: "boolean",
      title: "Spreadsheet Force Formula Computation",
      default: false,
    },
    inline_images_in_markdown: {
      type: "boolean",
      title: "Inline Images In Markdown",
      default: false,
    },
    structured_output: {
      type: "boolean",
      title: "Structured Output",
      default: false,
    },
    structured_output_json_schema: {
      type: "string",
      title: "Structured Output Json Schema",
    },
    structured_output_json_schema_name: {
      type: "string",
      title: "Structured Output Json Schema Name",
    },
    take_screenshot: {
      type: "boolean",
      title: "Take Screenshot",
      default: false,
    },
    target_pages: {
      type: "string",
      title: "Target Pages",
      default: "",
    },
    vendor_multimodal_api_key: {
      type: "string",
      title: "Vendor Multimodal Api Key",
      default: "",
    },
    vendor_multimodal_model_name: {
      type: "string",
      title: "Vendor Multimodal Model Name",
    },
    model: {
      type: "string",
      title: "Model",
    },
    webhook_url: {
      type: "string",
      title: "Webhook Url",
      default: "",
    },
    webhook_configurations: {
      type: "string",
      title: "Webhook Configurations",
      default: "",
    },
    preset: {
      type: "string",
      title: "Preset",
      default: "",
    },
    parse_mode: {
      anyOf: [
        {
          $ref: "#/components/schemas/ParsingMode",
        },
        {
          type: "null",
        },
      ],
    },
    page_error_tolerance: {
      type: "number",
      title: "Page Error Tolerance",
      default: 0.05,
    },
    replace_failed_page_mode: {
      anyOf: [
        {
          $ref: "#/components/schemas/FailPageMode",
        },
        {
          type: "null",
        },
      ],
    },
    replace_failed_page_with_error_message_prefix: {
      type: "string",
      title: "Replace Failed Page With Error Message Prefix",
      default: "",
    },
    replace_failed_page_with_error_message_suffix: {
      type: "string",
      title: "Replace Failed Page With Error Message Suffix",
      default: "",
    },
    system_prompt: {
      type: "string",
      title: "System Prompt",
      default: "",
    },
    system_prompt_append: {
      type: "string",
      title: "System Prompt Append",
      default: "",
    },
    user_prompt: {
      type: "string",
      title: "User Prompt",
      default: "",
    },
    job_timeout_in_seconds: {
      type: "number",
      title: "Job Timeout In Seconds",
    },
    job_timeout_extra_time_per_page_in_seconds: {
      type: "number",
      title: "Job Timeout Extra Time Per Page In Seconds",
    },
    strict_mode_image_extraction: {
      type: "boolean",
      title: "Strict Mode Image Extraction",
      default: false,
    },
    strict_mode_image_ocr: {
      type: "boolean",
      title: "Strict Mode Image Ocr",
      default: false,
    },
    strict_mode_reconstruction: {
      type: "boolean",
      title: "Strict Mode Reconstruction",
      default: false,
    },
    strict_mode_buggy_font: {
      type: "boolean",
      title: "Strict Mode Buggy Font",
      default: false,
    },
    save_images: {
      type: "boolean",
      title: "Save Images",
      default: true,
    },
    ignore_document_elements_for_layout_detection: {
      type: "boolean",
      title: "Ignore Document Elements For Layout Detection",
      default: false,
    },
    output_tables_as_HTML: {
      type: "boolean",
      title: "Output Tables As Html",
      default: false,
    },
    markdown_table_multiline_header_separator: {
      type: "string",
      title: "Markdown Table Multiline Header Separator",
    },
    use_vendor_multimodal_model: {
      type: "boolean",
      title: "Use Vendor Multimodal Model",
      default: false,
    },
    bounding_box: {
      type: "string",
      title: "Bounding Box",
      default: "",
    },
    gpt4o_mode: {
      type: "boolean",
      title: "Gpt4O Mode",
      default: false,
    },
    gpt4o_api_key: {
      type: "string",
      title: "Gpt4O Api Key",
      default: "",
    },
    complemental_formatting_instruction: {
      type: "string",
      title: "Complemental Formatting Instruction",
    },
    content_guideline_instruction: {
      type: "string",
      title: "Content Guideline Instruction",
    },
    premium_mode: {
      type: "boolean",
      title: "Premium Mode",
      default: false,
    },
    is_formatting_instruction: {
      type: "boolean",
      title: "Is Formatting Instruction",
      default: true,
    },
    continuous_mode: {
      type: "boolean",
      title: "Continuous Mode",
      default: false,
    },
    parsing_instruction: {
      type: "string",
      title: "Parsing Instruction",
      default: "",
    },
    fast_mode: {
      type: "boolean",
      title: "Fast Mode",
      default: false,
    },
    formatting_instruction: {
      type: "string",
      title: "Formatting Instruction",
    },
    hide_headers: {
      type: "boolean",
      title: "Hide Headers",
      default: false,
    },
    hide_footers: {
      type: "boolean",
      title: "Hide Footers",
      default: false,
    },
    page_header_prefix: {
      type: "string",
      title: "Page Header Prefix",
    },
    page_header_suffix: {
      type: "string",
      title: "Page Header Suffix",
    },
    page_footer_prefix: {
      type: "string",
      title: "Page Footer Prefix",
    },
    page_footer_suffix: {
      type: "string",
      title: "Page Footer Suffix",
    },
  },
  type: "object",
  title: "Body_upload_file_api_v1_parsing_upload_post",
} as const;

export const BoxAuthMechanismSchema = {
  type: "string",
  enum: ["developer_token", "ccg"],
  title: "BoxAuthMechanism",
} as const;

export const CharacterChunkingConfigSchema = {
  properties: {
    chunk_size: {
      type: "integer",
      exclusiveMinimum: 0,
      title: "Chunk Size",
      default: 1024,
    },
    chunk_overlap: {
      type: "integer",
      title: "Chunk Overlap",
      default: 200,
      gte: 0,
    },
    mode: {
      type: "string",
      const: "character",
      title: "Mode",
      default: "character",
    },
  },
  type: "object",
  title: "CharacterChunkingConfig",
} as const;

export const ChatAppSchema = {
  properties: {
    id: {
      type: "string",
      format: "uuid",
      title: "Id",
      description: "Unique identifier",
    },
    created_at: {
      anyOf: [
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Created At",
      description: "Creation datetime",
    },
    updated_at: {
      anyOf: [
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Updated At",
      description: "Update datetime",
    },
    name: {
      type: "string",
      maxLength: 3000,
      minLength: 1,
      title: "Name",
      description: "Name of the chat app",
    },
    retriever_id: {
      type: "string",
      format: "uuid",
      title: "Retriever Id",
      description: "ID of the retriever to use for the chat app",
    },
    llm_config: {
      $ref: "#/components/schemas/LLMParameters",
      description: "Configuration for the LLM model to use for the chat app",
    },
    retrieval_config: {
      $ref: "#/components/schemas/PresetCompositeRetrievalParams",
      description:
        "Configuration for the retrieval model to use for the chat app",
    },
    project_id: {
      type: "string",
      format: "uuid",
      title: "Project Id",
      description: "ID of the project the chat app belongs to",
    },
  },
  type: "object",
  required: [
    "id",
    "name",
    "retriever_id",
    "llm_config",
    "retrieval_config",
    "project_id",
  ],
  title: "ChatApp",
  description: "Schema for a chat app",
} as const;

export const ChatAppCreateSchema = {
  properties: {
    name: {
      type: "string",
      maxLength: 3000,
      minLength: 1,
      title: "Name",
      description: "Name of the chat app",
    },
    retriever_id: {
      type: "string",
      format: "uuid",
      title: "Retriever Id",
      description: "ID of the retriever to use for the chat app",
    },
    llm_config: {
      $ref: "#/components/schemas/LLMParameters",
      description: "Configuration for the LLM model to use for the chat app",
    },
    retrieval_config: {
      $ref: "#/components/schemas/PresetCompositeRetrievalParams",
      description:
        "Configuration for the retrieval model to use for the chat app",
    },
  },
  type: "object",
  required: ["name", "retriever_id", "llm_config", "retrieval_config"],
  title: "ChatAppCreate",
  description: "Schema for creating a new chat app",
} as const;

export const ChatAppResponseSchema = {
  properties: {
    id: {
      type: "string",
      format: "uuid",
      title: "Id",
      description: "Unique identifier",
    },
    created_at: {
      anyOf: [
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Created At",
      description: "Creation datetime",
    },
    updated_at: {
      anyOf: [
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Updated At",
      description: "Update datetime",
    },
    name: {
      type: "string",
      maxLength: 3000,
      minLength: 1,
      title: "Name",
      description: "Name of the chat app",
    },
    retriever_id: {
      type: "string",
      format: "uuid",
      title: "Retriever Id",
      description: "ID of the retriever to use for the chat app",
    },
    llm_config: {
      $ref: "#/components/schemas/LLMParameters",
      description: "Configuration for the LLM model to use for the chat app",
    },
    retrieval_config: {
      $ref: "#/components/schemas/PresetCompositeRetrievalParams",
      description:
        "Configuration for the retrieval model to use for the chat app",
    },
    project_id: {
      type: "string",
      format: "uuid",
      title: "Project Id",
      description: "ID of the project the chat app belongs to",
    },
    retriever_name: {
      type: "string",
      title: "Retriever Name",
    },
  },
  type: "object",
  required: [
    "id",
    "name",
    "retriever_id",
    "llm_config",
    "retrieval_config",
    "project_id",
    "retriever_name",
  ],
  title: "ChatAppResponse",
} as const;

export const ChatAppUpdateSchema = {
  properties: {
    name: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Name",
    },
    llm_config: {
      anyOf: [
        {
          $ref: "#/components/schemas/LLMParameters",
        },
        {
          type: "null",
        },
      ],
    },
    retrieval_config: {
      anyOf: [
        {
          $ref: "#/components/schemas/PresetCompositeRetrievalParams",
        },
        {
          type: "null",
        },
      ],
    },
  },
  type: "object",
  title: "ChatAppUpdate",
  description: "Schema for updating a chat app",
} as const;

export const ChatDataSchema = {
  properties: {
    retrieval_parameters: {
      $ref: "#/components/schemas/PresetRetrievalParams",
    },
    llm_parameters: {
      anyOf: [
        {
          $ref: "#/components/schemas/LLMParameters",
        },
        {
          type: "null",
        },
      ],
    },
    class_name: {
      type: "string",
      title: "Class Name",
      default: "base_component",
    },
  },
  type: "object",
  title: "ChatData",
} as const;

export const ChatInputParamsSchema = {
  properties: {
    messages: {
      items: {
        $ref: "#/components/schemas/InputMessage",
      },
      type: "array",
      minItems: 1,
      title: "Messages",
    },
    data: {
      $ref: "#/components/schemas/ChatData",
    },
    class_name: {
      type: "string",
      title: "Class Name",
      default: "base_component",
    },
  },
  type: "object",
  title: "ChatInputParams",
} as const;

export const ChatMessageSchema = {
  properties: {
    id: {
      type: "string",
      format: "uuid",
      title: "Id",
    },
    index: {
      type: "integer",
      title: "Index",
      description: "The index of the message in the chat.",
    },
    annotations: {
      items: {
        $ref: "#/components/schemas/MessageAnnotation",
      },
      type: "array",
      title: "Annotations",
      description: "Retrieval annotations for the message.",
    },
    role: {
      $ref: "#/components/schemas/MessageRole",
      description: "The role of the message.",
    },
    content: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Content",
      description: "Text content of the generation",
    },
    additional_kwargs: {
      additionalProperties: {
        type: "string",
      },
      type: "object",
      title: "Additional Kwargs",
      description: "Additional arguments passed to the model",
    },
    class_name: {
      type: "string",
      title: "Class Name",
      default: "base_component",
    },
  },
  type: "object",
  required: ["id", "index", "role"],
  title: "ChatMessage",
} as const;

export const ClassificationResultSchema = {
  properties: {
    reasoning: {
      type: "string",
      title: "Reasoning",
      description:
        "Step-by-step explanation of why this classification was chosen and the confidence score assigned",
    },
    confidence: {
      type: "number",
      maximum: 1,
      minimum: 0,
      title: "Confidence",
      description: "Confidence score of the classification (0.0-1.0)",
    },
    type: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Type",
      description: "The document type that best matches, or null if no match.",
    },
  },
  type: "object",
  required: ["reasoning", "confidence", "type"],
  title: "ClassificationResult",
  description: "Result of classifying a single file.",
} as const;

export const ClassifierRuleSchema = {
  properties: {
    type: {
      type: "string",
      maxLength: 50,
      minLength: 1,
      title: "Type",
      description:
        "The document type to assign when this rule matches (e.g., 'invoice', 'receipt', 'contract')",
      examples: ["invoice", "receipt", "contract", "report", "proposal"],
    },
    description: {
      type: "string",
      maxLength: 500,
      minLength: 10,
      title: "Description",
      description:
        "Natural language description of what to classify. Be specific about the content characteristics that identify this document type.",
      examples: [
        "contains invoice number, line items, and total amount",
        "purchase receipt with transaction info and merchant details",
        "legal contract with terms, conditions, and signatures",
      ],
    },
  },
  type: "object",
  required: ["type", "description"],
  title: "ClassifierRule",
  description: `A rule for classifying documents - v0 simplified version.

This represents a single classification rule that will be applied to documents.
All rules are content-based and use natural language descriptions.`,
} as const;

export const ClassifyJobSchema = {
  properties: {
    id: {
      type: "string",
      format: "uuid",
      title: "Id",
      description: "Unique identifier",
    },
    created_at: {
      anyOf: [
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Created At",
      description: "Creation datetime",
    },
    updated_at: {
      anyOf: [
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Updated At",
      description: "Update datetime",
    },
    rules: {
      items: {
        $ref: "#/components/schemas/ClassifierRule",
      },
      type: "array",
      minItems: 1,
      title: "Rules",
      description: "The rules to classify the files",
    },
    user_id: {
      type: "string",
      title: "User Id",
      description: "The ID of the user",
    },
    project_id: {
      type: "string",
      format: "uuid",
      title: "Project Id",
      description: "The ID of the project",
    },
    status: {
      $ref: "#/components/schemas/StatusEnum",
      description: "The status of the classify job",
    },
    parsing_configuration: {
      $ref: "#/components/schemas/ClassifyParsingConfiguration",
      description: "The configuration for the parsing job",
      default: {
        lang: "en",
        max_pages: 5,
      },
    },
  },
  type: "object",
  required: ["id", "rules", "user_id", "project_id", "status"],
  title: "ClassifyJob",
  description: "A classify job.",
} as const;

export const ClassifyJobCreateSchema = {
  properties: {
    rules: {
      items: {
        $ref: "#/components/schemas/ClassifierRule",
      },
      type: "array",
      minItems: 1,
      title: "Rules",
      description: "The rules to classify the files",
    },
    file_ids: {
      items: {
        type: "string",
        format: "uuid",
      },
      type: "array",
      maxItems: 500,
      minItems: 1,
      title: "File Ids",
      description: "The IDs of the files to classify",
    },
    parsing_configuration: {
      $ref: "#/components/schemas/ClassifyParsingConfiguration",
      description: "The configuration for the parsing job",
      default: {
        lang: "en",
        max_pages: 5,
      },
    },
  },
  type: "object",
  required: ["rules", "file_ids"],
  title: "ClassifyJobCreate",
  description: "A classify job.",
} as const;

export const ClassifyJobResultsSchema = {
  properties: {
    items: {
      items: {
        $ref: "#/components/schemas/FileClassification",
      },
      type: "array",
      title: "Items",
      description: "The list of items.",
    },
    next_page_token: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Next Page Token",
      description:
        "A token, which can be sent as page_token to retrieve the next page. If this field is omitted, there are no subsequent pages.",
    },
    total_size: {
      anyOf: [
        {
          type: "integer",
        },
        {
          type: "null",
        },
      ],
      title: "Total Size",
      description:
        "The total number of items available. This is only populated when specifically requested. The value may be an estimate and can be used for display purposes only.",
    },
  },
  type: "object",
  required: ["items"],
  title: "ClassifyJobResults",
  description:
    "Response model for the classify endpoint following AIP-132 pagination standard.",
} as const;

export const ClassifyParsingConfigurationSchema = {
  properties: {
    lang: {
      $ref: "#/components/schemas/ParserLanguages",
      description: "The language to parse the files in",
      default: "en",
    },
    max_pages: {
      anyOf: [
        {
          type: "integer",
        },
        {
          type: "null",
        },
      ],
      title: "Max Pages",
      description: "The maximum number of pages to parse",
      default: 5,
    },
    target_pages: {
      anyOf: [
        {
          items: {
            type: "integer",
          },
          type: "array",
          minItems: 1,
        },
        {
          type: "null",
        },
      ],
      title: "Target Pages",
      description:
        "The pages to target for parsing (0-indexed, so first page is at 0)",
    },
  },
  type: "object",
  title: "ClassifyParsingConfiguration",
  description: "Parsing configuration for a classify job.",
} as const;

export const CloudAstraDBVectorStoreSchema = {
  properties: {
    supports_nested_metadata_filters: {
      type: "boolean",
      const: true,
      title: "Supports Nested Metadata Filters",
      default: true,
    },
    token: {
      type: "string",
      format: "password",
      title: "Token",
      description: "The Astra DB Application Token to use",
      writeOnly: true,
    },
    api_endpoint: {
      type: "string",
      title: "Api Endpoint",
      description: "The Astra DB JSON API endpoint for your database",
    },
    collection_name: {
      type: "string",
      title: "Collection Name",
      description:
        "Collection name to use. If not existing, it will be created",
    },
    embedding_dimension: {
      type: "integer",
      title: "Embedding Dimension",
      description: "Length of the embedding vectors in use",
    },
    keyspace: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Keyspace",
      description: "The keyspace to use. If not provided, 'default_keyspace'",
    },
    class_name: {
      type: "string",
      title: "Class Name",
      default: "CloudAstraDBVectorStore",
    },
  },
  type: "object",
  required: ["token", "api_endpoint", "collection_name", "embedding_dimension"],
  title: "CloudAstraDBVectorStore",
  description: `Cloud AstraDB Vector Store.

This class is used to store the configuration for an AstraDB vector store, so that it can be
created and used in LlamaCloud.

Args:
    token (str): The Astra DB Application Token to use.
    api_endpoint (str): The Astra DB JSON API endpoint for your database.
    collection_name (str): Collection name to use. If not existing, it will be created.
    embedding_dimension (int): Length of the embedding vectors in use.
    keyspace (optional[str]): The keyspace to use. If not provided, 'default_keyspace'`,
} as const;

export const CloudAzStorageBlobDataSourceSchema = {
  properties: {
    supports_access_control: {
      type: "boolean",
      title: "Supports Access Control",
      default: false,
    },
    container_name: {
      type: "string",
      title: "Container Name",
      description: "The name of the Azure Storage Blob container to read from.",
    },
    account_url: {
      type: "string",
      title: "Account Url",
      description:
        "The Azure Storage Blob account URL to use for authentication.",
    },
    blob: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Blob",
      description: "The blob name to read from.",
    },
    prefix: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Prefix",
      description: "The prefix of the Azure Storage Blob objects to read from.",
    },
    account_name: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Account Name",
      description:
        "The Azure Storage Blob account name to use for authentication.",
    },
    account_key: {
      anyOf: [
        {
          type: "string",
          format: "password",
          writeOnly: true,
        },
        {
          type: "null",
        },
      ],
      title: "Account Key",
      description:
        "The Azure Storage Blob account key to use for authentication.",
    },
    tenant_id: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Tenant Id",
      description: "The Azure AD tenant ID to use for authentication.",
    },
    client_id: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Client Id",
      description: "The Azure AD client ID to use for authentication.",
    },
    client_secret: {
      anyOf: [
        {
          type: "string",
          format: "password",
          writeOnly: true,
        },
        {
          type: "null",
        },
      ],
      title: "Client Secret",
      description: "The Azure AD client secret to use for authentication.",
    },
    class_name: {
      type: "string",
      title: "Class Name",
      default: "CloudAzStorageBlobDataSource",
    },
  },
  type: "object",
  required: ["container_name", "account_url"],
  title: "CloudAzStorageBlobDataSource",
} as const;

export const CloudAzureAISearchVectorStoreSchema = {
  properties: {
    supports_nested_metadata_filters: {
      type: "boolean",
      const: true,
      title: "Supports Nested Metadata Filters",
      default: true,
    },
    search_service_api_key: {
      type: "string",
      format: "password",
      title: "Search Service Api Key",
      writeOnly: true,
    },
    search_service_endpoint: {
      type: "string",
      title: "Search Service Endpoint",
    },
    search_service_api_version: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Search Service Api Version",
    },
    index_name: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Index Name",
    },
    filterable_metadata_field_keys: {
      anyOf: [
        {
          additionalProperties: true,
          type: "object",
        },
        {
          type: "null",
        },
      ],
      title: "Filterable Metadata Field Keys",
    },
    embedding_dimension: {
      anyOf: [
        {
          type: "integer",
        },
        {
          type: "null",
        },
      ],
      title: "Embedding Dimension",
    },
    client_id: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Client Id",
    },
    client_secret: {
      anyOf: [
        {
          type: "string",
          format: "password",
          writeOnly: true,
        },
        {
          type: "null",
        },
      ],
      title: "Client Secret",
    },
    tenant_id: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Tenant Id",
    },
    class_name: {
      type: "string",
      title: "Class Name",
      default: "CloudAzureAISearchVectorStore",
    },
  },
  type: "object",
  required: ["search_service_api_key", "search_service_endpoint"],
  title: "CloudAzureAISearchVectorStore",
  description: "Cloud Azure AI Search Vector Store.",
} as const;

export const CloudBoxDataSourceSchema = {
  properties: {
    supports_access_control: {
      type: "boolean",
      title: "Supports Access Control",
      default: false,
    },
    folder_id: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Folder Id",
      description: "The ID of the Box folder to read from.",
    },
    authentication_mechanism: {
      $ref: "#/components/schemas/BoxAuthMechanism",
      description: "The type of authentication to use (Developer Token or CCG)",
    },
    developer_token: {
      anyOf: [
        {
          type: "string",
          format: "password",
          writeOnly: true,
        },
        {
          type: "null",
        },
      ],
      title: "Developer Token",
      description:
        "Developer token for authentication if authentication_mechanism is 'developer_token'.",
    },
    client_id: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Client Id",
      description:
        "Box API key used for identifying the application the user is authenticating with",
    },
    client_secret: {
      anyOf: [
        {
          type: "string",
          format: "password",
          writeOnly: true,
        },
        {
          type: "null",
        },
      ],
      title: "Client Secret",
      description: "Box API secret used for making auth requests.",
    },
    user_id: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "User Id",
      description: "Box User ID, if provided authenticates as user.",
    },
    enterprise_id: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Enterprise Id",
      description: "Box Enterprise ID, if provided authenticates as service.",
    },
    class_name: {
      type: "string",
      title: "Class Name",
      default: "CloudBoxDataSource",
    },
  },
  type: "object",
  required: ["authentication_mechanism"],
  title: "CloudBoxDataSource",
} as const;

export const CloudConfluenceDataSourceSchema = {
  properties: {
    supports_access_control: {
      type: "boolean",
      title: "Supports Access Control",
      default: false,
    },
    server_url: {
      type: "string",
      title: "Server Url",
      description: "The server URL of the Confluence instance.",
    },
    authentication_mechanism: {
      type: "string",
      title: "Authentication Mechanism",
      description: "Type of Authentication for connecting to Confluence APIs.",
    },
    user_name: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "User Name",
      description: "The username to use for authentication.",
    },
    api_token: {
      anyOf: [
        {
          type: "string",
          format: "password",
          writeOnly: true,
        },
        {
          type: "null",
        },
      ],
      title: "Api Token",
      description: "The API token to use for authentication.",
    },
    space_key: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Space Key",
      description: "The space key to read from.",
    },
    page_ids: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Page Ids",
      description: "The page IDs of the Confluence to read from.",
    },
    cql: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Cql",
      description: "The CQL query to use for fetching pages.",
    },
    label: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Label",
      description: "The label to use for fetching pages.",
    },
    index_restricted_pages: {
      type: "boolean",
      title: "Index Restricted Pages",
      description: "Whether to index restricted pages.",
      default: false,
    },
    keep_markdown_format: {
      type: "boolean",
      title: "Keep Markdown Format",
      description: "Whether to keep the markdown format.",
    },
    failure_handling: {
      $ref: "#/components/schemas/FailureHandlingConfig",
      description: `Configuration for handling failures during processing. Key-value object controlling failure handling behaviors.

Example:
{
  "skip_list_failures": true
}

Currently supports:
- skip_list_failures: Skip failed batches/lists and continue processing`,
    },
    class_name: {
      type: "string",
      title: "Class Name",
      default: "CloudConfluenceDataSource",
    },
  },
  type: "object",
  required: ["server_url", "authentication_mechanism"],
  title: "CloudConfluenceDataSource",
} as const;

export const CloudDocumentSchema = {
  properties: {
    text: {
      type: "string",
      title: "Text",
    },
    metadata: {
      additionalProperties: true,
      type: "object",
      title: "Metadata",
    },
    excluded_embed_metadata_keys: {
      items: {
        type: "string",
      },
      type: "array",
      title: "Excluded Embed Metadata Keys",
      default: [],
    },
    excluded_llm_metadata_keys: {
      items: {
        type: "string",
      },
      type: "array",
      title: "Excluded Llm Metadata Keys",
      default: [],
    },
    page_positions: {
      anyOf: [
        {
          items: {
            type: "integer",
          },
          type: "array",
        },
        {
          type: "null",
        },
      ],
      title: "Page Positions",
      description:
        "indices in the CloudDocument.text where a new page begins. e.g. Second page starts at index specified by page_positions[1].",
    },
    id: {
      type: "string",
      title: "Id",
    },
  },
  type: "object",
  required: ["text", "metadata", "id"],
  title: "CloudDocument",
  description: "Cloud document stored in S3.",
} as const;

export const CloudDocumentCreateSchema = {
  properties: {
    text: {
      type: "string",
      title: "Text",
    },
    metadata: {
      additionalProperties: true,
      type: "object",
      title: "Metadata",
    },
    excluded_embed_metadata_keys: {
      items: {
        type: "string",
      },
      type: "array",
      title: "Excluded Embed Metadata Keys",
      default: [],
    },
    excluded_llm_metadata_keys: {
      items: {
        type: "string",
      },
      type: "array",
      title: "Excluded Llm Metadata Keys",
      default: [],
    },
    page_positions: {
      anyOf: [
        {
          items: {
            type: "integer",
          },
          type: "array",
        },
        {
          type: "null",
        },
      ],
      title: "Page Positions",
      description:
        "indices in the CloudDocument.text where a new page begins. e.g. Second page starts at index specified by page_positions[1].",
    },
    id: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Id",
    },
  },
  type: "object",
  required: ["text", "metadata"],
  title: "CloudDocumentCreate",
  description: "Create a new cloud document.",
} as const;

export const CloudJiraDataSourceSchema = {
  properties: {
    supports_access_control: {
      type: "boolean",
      title: "Supports Access Control",
      default: false,
    },
    email: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Email",
      description: "The email address to use for authentication.",
    },
    api_token: {
      anyOf: [
        {
          type: "string",
          format: "password",
          writeOnly: true,
        },
        {
          type: "null",
        },
      ],
      title: "Api Token",
      description:
        "The API/ Access Token used for Basic, PAT and OAuth2 authentication.",
    },
    server_url: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Server Url",
      description: "The server url for Jira Cloud.",
    },
    cloud_id: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Cloud Id",
      description: "The cloud ID, used in case of OAuth2.",
    },
    authentication_mechanism: {
      type: "string",
      title: "Authentication Mechanism",
      description: "Type of Authentication for connecting to Jira APIs.",
    },
    query: {
      type: "string",
      title: "Query",
      description: "JQL (Jira Query Language) query to search.",
    },
    class_name: {
      type: "string",
      title: "Class Name",
      default: "CloudJiraDataSource",
    },
  },
  type: "object",
  required: ["authentication_mechanism", "query"],
  title: "CloudJiraDataSource",
  description: "Cloud Jira Data Source integrating JiraReader.",
} as const;

export const CloudJiraDataSourceV2Schema = {
  properties: {
    supports_access_control: {
      type: "boolean",
      title: "Supports Access Control",
      default: false,
    },
    email: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Email",
      description: "The email address to use for authentication.",
    },
    api_token: {
      anyOf: [
        {
          type: "string",
          format: "password",
          writeOnly: true,
        },
        {
          type: "null",
        },
      ],
      title: "Api Token",
      description:
        "The API Access Token used for Basic, PAT and OAuth2 authentication.",
    },
    server_url: {
      type: "string",
      title: "Server Url",
      description: "The server url for Jira Cloud.",
    },
    cloud_id: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Cloud Id",
      description: "The cloud ID, used in case of OAuth2.",
    },
    authentication_mechanism: {
      type: "string",
      title: "Authentication Mechanism",
      description: "Type of Authentication for connecting to Jira APIs.",
    },
    api_version: {
      type: "string",
      enum: ["2", "3"],
      title: "Api Version",
      description:
        "Jira REST API version to use (2 or 3). 3 supports Atlassian Document Format (ADF).",
      default: "2",
    },
    query: {
      type: "string",
      title: "Query",
      description: "JQL (Jira Query Language) query to search.",
    },
    fields: {
      anyOf: [
        {
          items: {
            type: "string",
          },
          type: "array",
        },
        {
          type: "null",
        },
      ],
      title: "Fields",
      description:
        "List of fields to retrieve from Jira. If None, retrieves all fields.",
    },
    expand: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Expand",
      description: "Fields to expand in the response.",
    },
    requests_per_minute: {
      anyOf: [
        {
          type: "integer",
        },
        {
          type: "null",
        },
      ],
      title: "Requests Per Minute",
      description: "Rate limit for Jira API requests per minute.",
    },
    get_permissions: {
      type: "boolean",
      title: "Get Permissions",
      description:
        "Whether to fetch project role permissions and issue-level security",
      default: true,
    },
    class_name: {
      type: "string",
      title: "Class Name",
      default: "CloudJiraDataSourceV2",
    },
  },
  type: "object",
  required: ["server_url", "authentication_mechanism", "query"],
  title: "CloudJiraDataSourceV2",
  description: "Cloud Jira Data Source integrating JiraReaderV2.",
} as const;

export const CloudMilvusVectorStoreSchema = {
  properties: {
    supports_nested_metadata_filters: {
      type: "boolean",
      title: "Supports Nested Metadata Filters",
      default: false,
    },
    uri: {
      type: "string",
      title: "Uri",
    },
    collection_name: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Collection Name",
    },
    token: {
      anyOf: [
        {
          type: "string",
          format: "password",
          writeOnly: true,
        },
        {
          type: "null",
        },
      ],
      title: "Token",
    },
    embedding_dimension: {
      anyOf: [
        {
          type: "integer",
        },
        {
          type: "null",
        },
      ],
      title: "Embedding Dimension",
    },
    class_name: {
      type: "string",
      title: "Class Name",
      default: "CloudMilvusVectorStore",
    },
  },
  type: "object",
  required: ["uri"],
  title: "CloudMilvusVectorStore",
  description: "Cloud Milvus Vector Store.",
} as const;

export const CloudMongoDBAtlasVectorSearchSchema = {
  properties: {
    supports_nested_metadata_filters: {
      type: "boolean",
      title: "Supports Nested Metadata Filters",
      default: false,
    },
    mongodb_uri: {
      type: "string",
      format: "password",
      title: "Mongodb Uri",
      writeOnly: true,
    },
    db_name: {
      type: "string",
      title: "Db Name",
    },
    collection_name: {
      type: "string",
      title: "Collection Name",
    },
    vector_index_name: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Vector Index Name",
    },
    fulltext_index_name: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Fulltext Index Name",
    },
    embedding_dimension: {
      anyOf: [
        {
          type: "integer",
        },
        {
          type: "null",
        },
      ],
      title: "Embedding Dimension",
    },
    class_name: {
      type: "string",
      title: "Class Name",
      default: "CloudMongoDBAtlasVectorSearch",
    },
  },
  type: "object",
  required: ["mongodb_uri", "db_name", "collection_name"],
  title: "CloudMongoDBAtlasVectorSearch",
  description: `Cloud MongoDB Atlas Vector Store.

This class is used to store the configuration for a MongoDB Atlas vector store,
so that it can be created and used in LlamaCloud.

Args:
    mongodb_uri (str): URI for connecting to MongoDB Atlas
    db_name (str): name of the MongoDB database
    collection_name (str): name of the MongoDB collection
    vector_index_name (str): name of the MongoDB Atlas vector index
    fulltext_index_name (str): name of the MongoDB Atlas full-text index`,
} as const;

export const CloudNotionPageDataSourceSchema = {
  properties: {
    supports_access_control: {
      type: "boolean",
      title: "Supports Access Control",
      default: false,
    },
    integration_token: {
      type: "string",
      format: "password",
      title: "Integration Token",
      description: "The integration token to use for authentication.",
      writeOnly: true,
    },
    database_ids: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Database Ids",
      description: "The Notion Database Id to read content from.",
    },
    page_ids: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Page Ids",
      description: "The Page ID's of the Notion to read from.",
    },
    class_name: {
      type: "string",
      title: "Class Name",
      default: "CloudNotionPageDataSource",
    },
  },
  type: "object",
  required: ["integration_token"],
  title: "CloudNotionPageDataSource",
} as const;

export const CloudOneDriveDataSourceSchema = {
  properties: {
    supports_access_control: {
      type: "boolean",
      const: true,
      title: "Supports Access Control",
      default: true,
    },
    user_principal_name: {
      type: "string",
      title: "User Principal Name",
      description: "The user principal name to use for authentication.",
    },
    folder_path: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Folder Path",
      description: "The path of the OneDrive folder to read from.",
    },
    folder_id: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Folder Id",
      description: "The ID of the OneDrive folder to read from.",
    },
    client_id: {
      type: "string",
      title: "Client Id",
      description: "The client ID to use for authentication.",
    },
    client_secret: {
      type: "string",
      format: "password",
      title: "Client Secret",
      description: "The client secret to use for authentication.",
      writeOnly: true,
    },
    tenant_id: {
      type: "string",
      title: "Tenant Id",
      description: "The tenant ID to use for authentication.",
    },
    required_exts: {
      anyOf: [
        {
          items: {
            type: "string",
          },
          type: "array",
        },
        {
          type: "null",
        },
      ],
      title: "Required Exts",
      description: "The list of required file extensions.",
    },
    class_name: {
      type: "string",
      title: "Class Name",
      default: "CloudOneDriveDataSource",
    },
  },
  type: "object",
  required: ["user_principal_name", "client_id", "client_secret", "tenant_id"],
  title: "CloudOneDriveDataSource",
} as const;

export const CloudPineconeVectorStoreSchema = {
  properties: {
    supports_nested_metadata_filters: {
      type: "boolean",
      const: true,
      title: "Supports Nested Metadata Filters",
      default: true,
    },
    api_key: {
      type: "string",
      format: "password",
      title: "Api Key",
      description: "The API key for authenticating with Pinecone",
      writeOnly: true,
    },
    index_name: {
      type: "string",
      title: "Index Name",
    },
    namespace: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Namespace",
    },
    insert_kwargs: {
      anyOf: [
        {
          additionalProperties: true,
          type: "object",
        },
        {
          type: "null",
        },
      ],
      title: "Insert Kwargs",
    },
    class_name: {
      type: "string",
      title: "Class Name",
      default: "CloudPineconeVectorStore",
    },
  },
  type: "object",
  required: ["api_key", "index_name"],
  title: "CloudPineconeVectorStore",
  description: `Cloud Pinecone Vector Store.

This class is used to store the configuration for a Pinecone vector store, so that it can be
created and used in LlamaCloud.

Args:
    api_key (str): API key for authenticating with Pinecone
    index_name (str): name of the Pinecone index
    namespace (optional[str]): namespace to use in the Pinecone index
    insert_kwargs (optional[dict]): additional kwargs to pass during insertion`,
} as const;

export const CloudPostgresVectorStoreSchema = {
  properties: {
    supports_nested_metadata_filters: {
      type: "boolean",
      title: "Supports Nested Metadata Filters",
      default: true,
    },
    database: {
      type: "string",
      title: "Database",
    },
    host: {
      type: "string",
      title: "Host",
    },
    password: {
      type: "string",
      format: "password",
      title: "Password",
      writeOnly: true,
    },
    port: {
      type: "integer",
      title: "Port",
    },
    user: {
      type: "string",
      title: "User",
    },
    table_name: {
      type: "string",
      title: "Table Name",
    },
    schema_name: {
      type: "string",
      title: "Schema Name",
    },
    embed_dim: {
      type: "integer",
      title: "Embed Dim",
    },
    hybrid_search: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Hybrid Search",
      default: true,
    },
    perform_setup: {
      type: "boolean",
      title: "Perform Setup",
      default: true,
    },
    hnsw_settings: {
      anyOf: [
        {
          $ref: "#/components/schemas/PGVectorHNSWSettings",
        },
        {
          type: "null",
        },
      ],
      description:
        "HNSW settings for PGVector index. Set to null to disable HNSW indexing in favor of a brute force indexing/exact search strategy instead.",
    },
    class_name: {
      type: "string",
      title: "Class Name",
      default: "CloudPostgresVectorStore",
    },
  },
  type: "object",
  required: [
    "database",
    "host",
    "password",
    "port",
    "user",
    "table_name",
    "schema_name",
    "embed_dim",
  ],
  title: "CloudPostgresVectorStore",
} as const;

export const CloudQdrantVectorStoreSchema = {
  properties: {
    supports_nested_metadata_filters: {
      type: "boolean",
      const: true,
      title: "Supports Nested Metadata Filters",
      default: true,
    },
    collection_name: {
      type: "string",
      title: "Collection Name",
    },
    url: {
      type: "string",
      title: "Url",
    },
    api_key: {
      type: "string",
      format: "password",
      title: "Api Key",
      writeOnly: true,
    },
    max_retries: {
      type: "integer",
      title: "Max Retries",
      default: 3,
    },
    client_kwargs: {
      additionalProperties: true,
      type: "object",
      title: "Client Kwargs",
    },
    class_name: {
      type: "string",
      title: "Class Name",
      default: "CloudQdrantVectorStore",
    },
  },
  type: "object",
  required: ["collection_name", "url", "api_key"],
  title: "CloudQdrantVectorStore",
  description: `Cloud Qdrant Vector Store.

This class is used to store the configuration for a Qdrant vector store, so that it can be
created and used in LlamaCloud.

Args:
    collection_name (str): name of the Qdrant collection
    url (str): url of the Qdrant instance
    api_key (str): API key for authenticating with Qdrant
    max_retries (int): maximum number of retries in case of a failure. Defaults to 3
    client_kwargs (dict): additional kwargs to pass to the Qdrant client`,
} as const;

export const CloudS3DataSourceSchema = {
  properties: {
    supports_access_control: {
      type: "boolean",
      title: "Supports Access Control",
      default: false,
    },
    bucket: {
      type: "string",
      title: "Bucket",
      description: "The name of the S3 bucket to read from.",
    },
    prefix: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Prefix",
      description: "The prefix of the S3 objects to read from.",
    },
    regex_pattern: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Regex Pattern",
      description:
        "The regex pattern to filter S3 objects. Must be a valid regex pattern.",
    },
    aws_access_id: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Aws Access Id",
      description: "The AWS access ID to use for authentication.",
    },
    aws_access_secret: {
      anyOf: [
        {
          type: "string",
          format: "password",
          writeOnly: true,
        },
        {
          type: "null",
        },
      ],
      title: "Aws Access Secret",
      description: "The AWS access secret to use for authentication.",
    },
    s3_endpoint_url: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "S3 Endpoint Url",
      description: "The S3 endpoint URL to use for authentication.",
    },
    class_name: {
      type: "string",
      title: "Class Name",
      default: "CloudS3DataSource",
    },
  },
  type: "object",
  required: ["bucket"],
  title: "CloudS3DataSource",
} as const;

export const CloudSharepointDataSourceSchema = {
  properties: {
    supports_access_control: {
      type: "boolean",
      const: true,
      title: "Supports Access Control",
      default: true,
    },
    site_name: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Site Name",
      description: "The name of the SharePoint site to download from.",
    },
    site_id: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Site Id",
      description: "The ID of the SharePoint site to download from.",
    },
    folder_path: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Folder Path",
      description: "The path of the Sharepoint folder to read from.",
    },
    folder_id: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Folder Id",
      description: "The ID of the Sharepoint folder to read from.",
    },
    drive_name: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Drive Name",
      description: "The name of the Sharepoint drive to read from.",
    },
    client_id: {
      type: "string",
      title: "Client Id",
      description: "The client ID to use for authentication.",
    },
    client_secret: {
      type: "string",
      format: "password",
      title: "Client Secret",
      description: "The client secret to use for authentication.",
      writeOnly: true,
    },
    tenant_id: {
      type: "string",
      title: "Tenant Id",
      description: "The tenant ID to use for authentication.",
    },
    required_exts: {
      anyOf: [
        {
          items: {
            type: "string",
          },
          type: "array",
        },
        {
          type: "null",
        },
      ],
      title: "Required Exts",
      description: "The list of required file extensions.",
    },
    get_permissions: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Get Permissions",
      description: "Whether to get permissions for the sharepoint site.",
      default: true,
    },
    class_name: {
      type: "string",
      title: "Class Name",
      default: "CloudSharepointDataSource",
    },
  },
  type: "object",
  required: ["client_id", "client_secret", "tenant_id"],
  title: "CloudSharepointDataSource",
} as const;

export const CloudSlackDataSourceSchema = {
  properties: {
    supports_access_control: {
      type: "boolean",
      title: "Supports Access Control",
      default: false,
    },
    slack_token: {
      type: "string",
      format: "password",
      title: "Slack Token",
      description: "Slack Bot Token.",
      writeOnly: true,
    },
    channel_ids: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Channel Ids",
      description: "Slack Channel.",
    },
    latest_date: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Latest Date",
      description: "Latest date.",
    },
    earliest_date: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Earliest Date",
      description: "Earliest date.",
    },
    earliest_date_timestamp: {
      anyOf: [
        {
          type: "number",
        },
        {
          type: "null",
        },
      ],
      title: "Earliest Date Timestamp",
      description: "Earliest date timestamp.",
    },
    latest_date_timestamp: {
      anyOf: [
        {
          type: "number",
        },
        {
          type: "null",
        },
      ],
      title: "Latest Date Timestamp",
      description: "Latest date timestamp.",
    },
    channel_patterns: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Channel Patterns",
      description: "Slack Channel name pattern.",
    },
    class_name: {
      type: "string",
      title: "Class Name",
      default: "CloudSlackDataSource",
    },
  },
  type: "object",
  required: ["slack_token"],
  title: "CloudSlackDataSource",
} as const;

export const CohereEmbeddingSchema = {
  properties: {
    model_name: {
      type: "string",
      title: "Model Name",
      description: "The modelId of the Cohere model to use.",
      default: "embed-english-v3.0",
    },
    embed_batch_size: {
      type: "integer",
      maximum: 2048,
      exclusiveMinimum: 0,
      title: "Embed Batch Size",
      description: "The batch size for embedding calls.",
      default: 10,
    },
    num_workers: {
      anyOf: [
        {
          type: "integer",
        },
        {
          type: "null",
        },
      ],
      title: "Num Workers",
      description: "The number of workers to use for async embedding calls.",
    },
    api_key: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Api Key",
      description: "The Cohere API key.",
    },
    truncate: {
      type: "string",
      title: "Truncate",
      description: "Truncation type - START/ END/ NONE",
      default: "END",
    },
    input_type: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Input Type",
      description:
        "Model Input type. If not provided, search_document and search_query are used when needed.",
    },
    embedding_type: {
      type: "string",
      title: "Embedding Type",
      description:
        "Embedding type. If not provided float embedding_type is used when needed.",
      default: "float",
    },
    class_name: {
      type: "string",
      title: "Class Name",
      default: "CohereEmbedding",
    },
  },
  type: "object",
  required: ["api_key"],
  title: "CohereEmbedding",
} as const;

export const CohereEmbeddingConfigSchema = {
  properties: {
    type: {
      type: "string",
      const: "COHERE_EMBEDDING",
      title: "Type",
      description: "Type of the embedding model.",
      default: "COHERE_EMBEDDING",
    },
    component: {
      $ref: "#/components/schemas/CohereEmbedding",
      description: "Configuration for the Cohere embedding model.",
    },
  },
  type: "object",
  title: "CohereEmbeddingConfig",
} as const;

export const CompositeRetrievalModeSchema = {
  type: "string",
  enum: ["routing", "full"],
  title: "CompositeRetrievalMode",
  description: "Enum for the mode of composite retrieval.",
} as const;

export const CompositeRetrievalParamsSchema = {
  properties: {
    mode: {
      $ref: "#/components/schemas/CompositeRetrievalMode",
      description: "The mode of composite retrieval.",
      default: "full",
    },
    rerank_top_n: {
      anyOf: [
        {
          type: "integer",
        },
        {
          type: "null",
        },
      ],
      title: "Rerank Top N",
      description:
        "(use rerank_config.top_n instead) The number of nodes to retrieve after reranking over retrieved nodes from all retrieval tools.",
      deprecated: true,
    },
    rerank_config: {
      $ref: "#/components/schemas/ReRankConfig",
      description: "The rerank configuration for composite retrieval.",
    },
    query: {
      type: "string",
      minLength: 1,
      title: "Query",
      description: "The query to retrieve against.",
    },
  },
  type: "object",
  required: ["query"],
  title: "CompositeRetrievalParams",
} as const;

export const CompositeRetrievalResultSchema = {
  properties: {
    nodes: {
      items: {
        $ref: "#/components/schemas/CompositeRetrievedTextNodeWithScore",
      },
      type: "array",
      title: "Nodes",
      description: "The retrieved nodes from the composite retrieval.",
    },
    image_nodes: {
      items: {
        $ref: "#/components/schemas/PageScreenshotNodeWithScore",
      },
      type: "array",
      title: "Image Nodes",
      description:
        "The image nodes retrieved by the pipeline for the given query. Deprecated - will soon be replaced with 'page_screenshot_nodes'.",
      deprecated: true,
    },
    page_figure_nodes: {
      items: {
        $ref: "#/components/schemas/PageFigureNodeWithScore",
      },
      type: "array",
      title: "Page Figure Nodes",
      description:
        "The page figure nodes retrieved by the pipeline for the given query.",
    },
  },
  type: "object",
  title: "CompositeRetrievalResult",
} as const;

export const CompositeRetrievedTextNodeSchema = {
  properties: {
    id: {
      type: "string",
      format: "uuid",
      title: "Id",
      description: "The ID of the retrieved node.",
    },
    retriever_id: {
      type: "string",
      format: "uuid",
      title: "Retriever Id",
      description: "The ID of the retriever this node was retrieved from.",
    },
    retriever_pipeline_name: {
      type: "string",
      title: "Retriever Pipeline Name",
      description:
        "The name of the retrieval pipeline this node was retrieved from.",
    },
    pipeline_id: {
      type: "string",
      format: "uuid",
      title: "Pipeline Id",
      description: "The ID of the pipeline this node was retrieved from.",
    },
    metadata: {
      additionalProperties: true,
      type: "object",
      title: "Metadata",
      description: "Metadata associated with the retrieved node.",
    },
    text: {
      type: "string",
      title: "Text",
      description: "The text of the retrieved node.",
    },
    start_char_idx: {
      anyOf: [
        {
          type: "integer",
        },
        {
          type: "null",
        },
      ],
      title: "Start Char Idx",
      description:
        "The start character index of the retrieved node in the document",
    },
    end_char_idx: {
      anyOf: [
        {
          type: "integer",
        },
        {
          type: "null",
        },
      ],
      title: "End Char Idx",
      description:
        "The end character index of the retrieved node in the document",
    },
  },
  type: "object",
  required: [
    "id",
    "retriever_id",
    "retriever_pipeline_name",
    "pipeline_id",
    "text",
    "start_char_idx",
    "end_char_idx",
  ],
  title: "CompositeRetrievedTextNode",
} as const;

export const CompositeRetrievedTextNodeWithScoreSchema = {
  properties: {
    node: {
      $ref: "#/components/schemas/CompositeRetrievedTextNode",
    },
    score: {
      anyOf: [
        {
          type: "number",
        },
        {
          type: "null",
        },
      ],
      title: "Score",
    },
    class_name: {
      type: "string",
      title: "Class Name",
      default: "CompositeRetrievedTextNodeWithScore",
    },
  },
  type: "object",
  required: ["node"],
  title: "CompositeRetrievedTextNodeWithScore",
} as const;

export const ConfigurableDataSinkNamesSchema = {
  type: "string",
  enum: [
    "PINECONE",
    "POSTGRES",
    "QDRANT",
    "AZUREAI_SEARCH",
    "MONGODB_ATLAS",
    "MILVUS",
    "ASTRA_DB",
  ],
  title: "ConfigurableDataSinkNames",
} as const;

export const ConfigurableDataSourceNamesSchema = {
  type: "string",
  enum: [
    "S3",
    "AZURE_STORAGE_BLOB",
    "GOOGLE_DRIVE",
    "MICROSOFT_ONEDRIVE",
    "MICROSOFT_SHAREPOINT",
    "SLACK",
    "NOTION_PAGE",
    "CONFLUENCE",
    "JIRA",
    "JIRA_V2",
    "BOX",
  ],
  title: "ConfigurableDataSourceNames",
} as const;

export const CreateIntentAndCustomerSessionResponseSchema = {
  properties: {
    client_secret: {
      type: "string",
      title: "Client Secret",
    },
    customer_session_client_secret: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Customer Session Client Secret",
    },
  },
  type: "object",
  required: ["client_secret", "customer_session_client_secret"],
  title: "CreateIntentAndCustomerSessionResponse",
} as const;

export const CreditTypeSchema = {
  properties: {
    id: {
      type: "string",
      title: "Id",
    },
    name: {
      type: "string",
      title: "Name",
    },
  },
  type: "object",
  required: ["id", "name"],
  title: "CreditType",
} as const;

export const CustomClaimsSchema = {
  properties: {
    allowed_org_creation: {
      type: "boolean",
      title: "Allowed Org Creation",
      description: "Whether the user is allowed to create organizations.",
      default: false,
    },
    max_jobs_in_execution_per_job_type: {
      type: "integer",
      title: "Max Jobs In Execution Per Job Type",
      description:
        "The maximum number of jobs the user can have in execution per job type.",
      default: 10,
    },
    max_document_ingestion_jobs_in_execution: {
      type: "integer",
      title: "Max Document Ingestion Jobs In Execution",
      description:
        "The maximum number of document ingestion jobs the user can have in execution.",
      default: 2,
    },
    max_metadata_update_jobs_in_execution: {
      type: "integer",
      title: "Max Metadata Update Jobs In Execution",
      description:
        "The maximum number of metadata update jobs the user can have in execution.",
      default: 10,
    },
    extraction_test_user: {
      type: "boolean",
      title: "Extraction Test User",
      description:
        "Whether the user is a test user for extraction. This will include additional debug metadata and access to test endpoints.",
      default: false,
    },
    allowed_report: {
      type: "boolean",
      title: "Allowed Report",
      description:
        "Whether the user is allowed to access llama-report generation.",
      default: false,
    },
    allowed_app: {
      type: "boolean",
      title: "Allowed App",
      description: "Whether the user is allowed to access the app.",
      default: false,
    },
    allowed_classify: {
      type: "boolean",
      title: "Allowed Classify",
      description:
        "Whether the user is allowed to access the classifier feature.",
      default: true,
    },
    api_datasource_access: {
      type: "boolean",
      title: "Api Datasource Access",
      description: "Whether the user is allowed to access API data sources.",
      default: false,
    },
    allow_org_deletion: {
      type: "boolean",
      title: "Allow Org Deletion",
      description: "Whether the user is allowed to delete organizations.",
      default: false,
    },
    allowed_spreadsheet: {
      type: "boolean",
      title: "Allowed Spreadsheet",
      description:
        "Whether the user is allowed to access the spreadsheet feature.",
      default: false,
    },
  },
  type: "object",
  title: "CustomClaims",
  description: `Custom claims that dictate various limits or allowed behaviors.
Currently these claims reside at a per user level. Claims may expand to a per organization level or project in the future.`,
} as const;

export const CustomerPortalSessionCreatePayloadSchema = {
  properties: {
    return_url: {
      type: "string",
      minLength: 1,
      format: "uri",
      title: "Return Url",
    },
  },
  type: "object",
  required: ["return_url"],
  title: "CustomerPortalSessionCreatePayload",
} as const;

export const DataSinkSchema = {
  properties: {
    id: {
      type: "string",
      format: "uuid",
      title: "Id",
      description: "Unique identifier",
    },
    created_at: {
      anyOf: [
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Created At",
      description: "Creation datetime",
    },
    updated_at: {
      anyOf: [
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Updated At",
      description: "Update datetime",
    },
    name: {
      type: "string",
      title: "Name",
      description: "The name of the data sink.",
    },
    sink_type: {
      $ref: "#/components/schemas/ConfigurableDataSinkNames",
    },
    component: {
      anyOf: [
        {
          additionalProperties: true,
          type: "object",
        },
        {
          $ref: "#/components/schemas/CloudPineconeVectorStore",
        },
        {
          $ref: "#/components/schemas/CloudPostgresVectorStore",
        },
        {
          $ref: "#/components/schemas/CloudQdrantVectorStore",
        },
        {
          $ref: "#/components/schemas/CloudAzureAISearchVectorStore",
        },
        {
          $ref: "#/components/schemas/CloudMongoDBAtlasVectorSearch",
        },
        {
          $ref: "#/components/schemas/CloudMilvusVectorStore",
        },
        {
          $ref: "#/components/schemas/CloudAstraDBVectorStore",
        },
      ],
      title: "DataSinkCreateComponent",
      description: "Component that implements the data sink",
    },
    project_id: {
      type: "string",
      format: "uuid",
      title: "Project Id",
    },
  },
  type: "object",
  required: ["id", "name", "sink_type", "component", "project_id"],
  title: "DataSink",
  description: "Schema for a data sink.",
} as const;

export const DataSinkCreateSchema = {
  properties: {
    name: {
      type: "string",
      title: "Name",
      description: "The name of the data sink.",
    },
    sink_type: {
      $ref: "#/components/schemas/ConfigurableDataSinkNames",
    },
    component: {
      anyOf: [
        {
          additionalProperties: true,
          type: "object",
        },
        {
          $ref: "#/components/schemas/CloudPineconeVectorStore",
        },
        {
          $ref: "#/components/schemas/CloudPostgresVectorStore",
        },
        {
          $ref: "#/components/schemas/CloudQdrantVectorStore",
        },
        {
          $ref: "#/components/schemas/CloudAzureAISearchVectorStore",
        },
        {
          $ref: "#/components/schemas/CloudMongoDBAtlasVectorSearch",
        },
        {
          $ref: "#/components/schemas/CloudMilvusVectorStore",
        },
        {
          $ref: "#/components/schemas/CloudAstraDBVectorStore",
        },
      ],
      title: "DataSinkCreateComponent",
      description: "Component that implements the data sink",
    },
  },
  type: "object",
  required: ["name", "sink_type", "component"],
  title: "DataSinkCreate",
  description: "Schema for creating a data sink.",
} as const;

export const DataSinkUpdateSchema = {
  properties: {
    name: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Name",
      description: "The name of the data sink.",
    },
    sink_type: {
      $ref: "#/components/schemas/ConfigurableDataSinkNames",
    },
    component: {
      anyOf: [
        {
          additionalProperties: true,
          type: "object",
        },
        {
          $ref: "#/components/schemas/CloudPineconeVectorStore",
        },
        {
          $ref: "#/components/schemas/CloudPostgresVectorStore",
        },
        {
          $ref: "#/components/schemas/CloudQdrantVectorStore",
        },
        {
          $ref: "#/components/schemas/CloudAzureAISearchVectorStore",
        },
        {
          $ref: "#/components/schemas/CloudMongoDBAtlasVectorSearch",
        },
        {
          $ref: "#/components/schemas/CloudMilvusVectorStore",
        },
        {
          $ref: "#/components/schemas/CloudAstraDBVectorStore",
        },
        {
          type: "null",
        },
      ],
      title: "DataSinkUpdateComponent",
      description: "Component that implements the data sink",
    },
  },
  type: "object",
  required: ["sink_type"],
  title: "DataSinkUpdate",
  description: "Schema for updating a data sink.",
} as const;

export const DataSourceSchema = {
  properties: {
    id: {
      type: "string",
      format: "uuid",
      title: "Id",
      description: "Unique identifier",
    },
    created_at: {
      anyOf: [
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Created At",
      description: "Creation datetime",
    },
    updated_at: {
      anyOf: [
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Updated At",
      description: "Update datetime",
    },
    name: {
      type: "string",
      title: "Name",
      description: "The name of the data source.",
    },
    source_type: {
      $ref: "#/components/schemas/ConfigurableDataSourceNames",
    },
    custom_metadata: {
      anyOf: [
        {
          additionalProperties: {
            anyOf: [
              {
                additionalProperties: true,
                type: "object",
              },
              {
                items: {},
                type: "array",
              },
              {
                type: "string",
              },
              {
                type: "integer",
              },
              {
                type: "number",
              },
              {
                type: "boolean",
              },
              {
                type: "null",
              },
            ],
          },
          type: "object",
        },
        {
          type: "null",
        },
      ],
      title: "Custom Metadata",
      description:
        "Custom metadata that will be present on all data loaded from the data source",
    },
    component: {
      anyOf: [
        {
          additionalProperties: true,
          type: "object",
        },
        {
          $ref: "#/components/schemas/CloudS3DataSource",
        },
        {
          $ref: "#/components/schemas/CloudAzStorageBlobDataSource",
        },
        {
          $ref: "#/components/schemas/CloudOneDriveDataSource",
        },
        {
          $ref: "#/components/schemas/CloudSharepointDataSource",
        },
        {
          $ref: "#/components/schemas/CloudSlackDataSource",
        },
        {
          $ref: "#/components/schemas/CloudNotionPageDataSource",
        },
        {
          $ref: "#/components/schemas/CloudConfluenceDataSource",
        },
        {
          $ref: "#/components/schemas/CloudJiraDataSource",
        },
        {
          $ref: "#/components/schemas/CloudJiraDataSourceV2",
        },
        {
          $ref: "#/components/schemas/CloudBoxDataSource",
        },
      ],
      title: "DataSourceCreateComponent",
      description: "Component that implements the data source",
    },
    version_metadata: {
      anyOf: [
        {
          $ref: "#/components/schemas/DataSourceReaderVersionMetadata",
        },
        {
          type: "null",
        },
      ],
      description: "Version metadata for the data source",
    },
    project_id: {
      type: "string",
      format: "uuid",
      title: "Project Id",
    },
  },
  type: "object",
  required: ["id", "name", "source_type", "component", "project_id"],
  title: "DataSource",
  description: "Schema for a data source.",
} as const;

export const DataSourceCreateSchema = {
  properties: {
    name: {
      type: "string",
      title: "Name",
      description: "The name of the data source.",
    },
    source_type: {
      $ref: "#/components/schemas/ConfigurableDataSourceNames",
    },
    custom_metadata: {
      anyOf: [
        {
          additionalProperties: {
            anyOf: [
              {
                additionalProperties: true,
                type: "object",
              },
              {
                items: {},
                type: "array",
              },
              {
                type: "string",
              },
              {
                type: "integer",
              },
              {
                type: "number",
              },
              {
                type: "boolean",
              },
              {
                type: "null",
              },
            ],
          },
          type: "object",
        },
        {
          type: "null",
        },
      ],
      title: "Custom Metadata",
      description:
        "Custom metadata that will be present on all data loaded from the data source",
    },
    component: {
      anyOf: [
        {
          additionalProperties: true,
          type: "object",
        },
        {
          $ref: "#/components/schemas/CloudS3DataSource",
        },
        {
          $ref: "#/components/schemas/CloudAzStorageBlobDataSource",
        },
        {
          $ref: "#/components/schemas/CloudOneDriveDataSource",
        },
        {
          $ref: "#/components/schemas/CloudSharepointDataSource",
        },
        {
          $ref: "#/components/schemas/CloudSlackDataSource",
        },
        {
          $ref: "#/components/schemas/CloudNotionPageDataSource",
        },
        {
          $ref: "#/components/schemas/CloudConfluenceDataSource",
        },
        {
          $ref: "#/components/schemas/CloudJiraDataSource",
        },
        {
          $ref: "#/components/schemas/CloudJiraDataSourceV2",
        },
        {
          $ref: "#/components/schemas/CloudBoxDataSource",
        },
      ],
      title: "DataSourceCreateComponent",
      description: "Component that implements the data source",
    },
  },
  type: "object",
  required: ["name", "source_type", "component"],
  title: "DataSourceCreate",
  description: "Schema for creating a data source.",
} as const;

export const DataSourceReaderVersionMetadataSchema = {
  properties: {
    reader_version: {
      anyOf: [
        {
          type: "string",
          enum: ["1.0", "2.0", "2.1"],
        },
        {
          type: "null",
        },
      ],
      title: "Reader Version",
      description: "The version of the reader to use for this data source.",
    },
  },
  type: "object",
  title: "DataSourceReaderVersionMetadata",
} as const;

export const DataSourceUpdateSchema = {
  properties: {
    name: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Name",
      description: "The name of the data source.",
    },
    source_type: {
      $ref: "#/components/schemas/ConfigurableDataSourceNames",
    },
    custom_metadata: {
      anyOf: [
        {
          additionalProperties: {
            anyOf: [
              {
                additionalProperties: true,
                type: "object",
              },
              {
                items: {},
                type: "array",
              },
              {
                type: "string",
              },
              {
                type: "integer",
              },
              {
                type: "number",
              },
              {
                type: "boolean",
              },
              {
                type: "null",
              },
            ],
          },
          type: "object",
        },
        {
          type: "null",
        },
      ],
      title: "Custom Metadata",
      description:
        "Custom metadata that will be present on all data loaded from the data source",
    },
    component: {
      anyOf: [
        {
          additionalProperties: true,
          type: "object",
        },
        {
          $ref: "#/components/schemas/CloudS3DataSource",
        },
        {
          $ref: "#/components/schemas/CloudAzStorageBlobDataSource",
        },
        {
          $ref: "#/components/schemas/CloudOneDriveDataSource",
        },
        {
          $ref: "#/components/schemas/CloudSharepointDataSource",
        },
        {
          $ref: "#/components/schemas/CloudSlackDataSource",
        },
        {
          $ref: "#/components/schemas/CloudNotionPageDataSource",
        },
        {
          $ref: "#/components/schemas/CloudConfluenceDataSource",
        },
        {
          $ref: "#/components/schemas/CloudJiraDataSource",
        },
        {
          $ref: "#/components/schemas/CloudJiraDataSourceV2",
        },
        {
          $ref: "#/components/schemas/CloudBoxDataSource",
        },
        {
          type: "null",
        },
      ],
      title: "DataSourceUpdateComponent",
      description: "Component that implements the data source",
    },
  },
  type: "object",
  required: ["source_type"],
  title: "DataSourceUpdate",
  description: "Schema for updating a data source.",
} as const;

export const DataSourceUpdateDispatcherConfigSchema = {
  properties: {
    type: {
      type: "string",
      const: "data_source_update_dispatcher",
      title: "Type",
      default: "data_source_update_dispatcher",
    },
    should_delete: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Should Delete",
      description: "Whether to delete the data source from the pipeline",
      default: false,
    },
    custom_metadata: {
      anyOf: [
        {
          additionalProperties: true,
          type: "object",
        },
        {
          type: "null",
        },
      ],
      title: "Custom Metadata",
      description: "The custom metadata to attach to the data source.",
    },
    delete_info: {
      anyOf: [
        {
          $ref: "#/components/schemas/DeleteParams",
        },
        {
          type: "null",
        },
      ],
      description: "The parameters for the delete job.",
    },
  },
  type: "object",
  title: "DataSourceUpdateDispatcherConfig",
  description: "Schema for the parameters of a data source dispatcher job.",
} as const;

export const DefaultOrganizationUpdateSchema = {
  properties: {
    organization_id: {
      type: "string",
      format: "uuid",
      title: "Organization Id",
      description: "The organization's ID.",
    },
  },
  type: "object",
  required: ["organization_id"],
  title: "DefaultOrganizationUpdate",
  description: "Schema for updating the default organization for a user.",
} as const;

export const DeleteParamsSchema = {
  properties: {
    document_ids_to_delete: {
      anyOf: [
        {
          items: {
            type: "string",
          },
          type: "array",
        },
        {
          type: "null",
        },
      ],
      title: "Document Ids To Delete",
      description: "The IDs for the documents to delete.",
    },
    files_ids_to_delete: {
      anyOf: [
        {
          items: {
            type: "string",
            format: "uuid",
          },
          type: "array",
        },
        {
          type: "null",
        },
      ],
      title: "Files Ids To Delete",
      description: "The IDs for the files to delete.",
    },
    data_sources_ids_to_delete: {
      anyOf: [
        {
          items: {
            type: "string",
            format: "uuid",
          },
          type: "array",
        },
        {
          type: "null",
        },
      ],
      title: "Data Sources Ids To Delete",
      description: "The IDs for the data sources to delete.",
    },
    embed_collection_name: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Embed Collection Name",
      description: "The collection name to delete.",
    },
    data_sink_id: {
      anyOf: [
        {
          type: "string",
          format: "uuid",
        },
        {
          type: "null",
        },
      ],
      title: "Data Sink Id",
      description: "The ID for the data sink from which to delete data.",
    },
  },
  type: "object",
  title: "DeleteParams",
  description: "Schema for the parameters of a delete job.",
} as const;

export const DeleteRequestSchema = {
  properties: {
    deployment_name: {
      type: "string",
      title: "Deployment Name",
      description: "The agent deployment's name to delete data for",
    },
    collection: {
      type: "string",
      title: "Collection",
      description: "The logical agent data collection to delete from",
      default: "default",
    },
    filter: {
      anyOf: [
        {
          additionalProperties: {
            $ref: "#/components/schemas/FilterOperation",
          },
          type: "object",
        },
        {
          type: "null",
        },
      ],
      title: "Filter",
      description: "Optional filters to select which items to delete",
    },
  },
  type: "object",
  required: ["deployment_name"],
  title: "DeleteRequest",
  description: "API request body for bulk deleting agent data by query",
} as const;

export const DeleteResponseSchema = {
  properties: {
    deleted_count: {
      type: "integer",
      title: "Deleted Count",
    },
  },
  type: "object",
  required: ["deleted_count"],
  title: "DeleteResponse",
  description: "API response for bulk delete operation",
} as const;

export const DirectRetrievalParamsSchema = {
  properties: {
    mode: {
      $ref: "#/components/schemas/CompositeRetrievalMode",
      description: "The mode of composite retrieval.",
      default: "full",
    },
    rerank_top_n: {
      anyOf: [
        {
          type: "integer",
        },
        {
          type: "null",
        },
      ],
      title: "Rerank Top N",
      description:
        "(use rerank_config.top_n instead) The number of nodes to retrieve after reranking over retrieved nodes from all retrieval tools.",
      deprecated: true,
    },
    rerank_config: {
      $ref: "#/components/schemas/ReRankConfig",
      description: "The rerank configuration for composite retrieval.",
    },
    query: {
      type: "string",
      minLength: 1,
      title: "Query",
      description: "The query to retrieve against.",
    },
    pipelines: {
      items: {
        $ref: "#/components/schemas/RetrieverPipeline",
      },
      type: "array",
      title: "Pipelines",
      description: "The pipelines to use for retrieval.",
    },
  },
  type: "object",
  required: ["query"],
  title: "DirectRetrievalParams",
} as const;

export const DocumentChunkModeSchema = {
  type: "string",
  enum: ["PAGE", "SECTION"],
  title: "DocumentChunkMode",
} as const;

export const DocumentIngestionJobParamsSchema = {
  properties: {
    custom_metadata: {
      anyOf: [
        {
          additionalProperties: true,
          type: "object",
        },
        {
          type: "null",
        },
      ],
      title: "Custom Metadata",
      description: "The custom metadata to attach to the documents.",
    },
    resource_info: {
      anyOf: [
        {
          additionalProperties: true,
          type: "object",
        },
        {
          type: "null",
        },
      ],
      title: "Resource Info",
      description: "The resource info about the file",
    },
    type: {
      type: "string",
      const: "document_ingestion",
      title: "Type",
      default: "document_ingestion",
    },
    should_delete: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Should Delete",
      description: "Whether to delete the documents",
    },
    document_ids: {
      anyOf: [
        {
          items: {
            type: "string",
          },
          type: "array",
        },
        {
          type: "null",
        },
      ],
      title: "Document Ids",
      description: "The IDs for the Documents this execution ran against.",
    },
    pipeline_file_id: {
      anyOf: [
        {
          type: "string",
          format: "uuid",
        },
        {
          type: "null",
        },
      ],
      title: "Pipeline File Id",
      description: "The ID for the File this execution ran against.",
    },
    delete_info: {
      anyOf: [
        {
          $ref: "#/components/schemas/DeleteParams",
        },
        {
          type: "null",
        },
      ],
      description: "The parameters for the delete job.",
    },
    is_new_file: {
      type: "boolean",
      title: "Is New File",
      description: "Whether the file is new",
      default: false,
    },
    page_count: {
      anyOf: [
        {
          type: "integer",
        },
        {
          type: "null",
        },
      ],
      title: "Page Count",
      description:
        "The number of pages in the file. Only used if used llama-parse",
    },
  },
  type: "object",
  title: "DocumentIngestionJobParams",
  description: "Schema for the parameters of a document ingestion job.",
} as const;

export const ElementSegmentationConfigSchema = {
  properties: {
    mode: {
      type: "string",
      const: "element",
      title: "Mode",
      default: "element",
    },
  },
  type: "object",
  title: "ElementSegmentationConfig",
} as const;

export const EmbeddingModelConfigSchema = {
  properties: {
    id: {
      type: "string",
      format: "uuid",
      title: "Id",
      description: "Unique identifier",
    },
    created_at: {
      anyOf: [
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Created At",
      description: "Creation datetime",
    },
    updated_at: {
      anyOf: [
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Updated At",
      description: "Update datetime",
    },
    name: {
      type: "string",
      title: "Name",
      description: "The name of the embedding model config.",
    },
    embedding_config: {
      oneOf: [
        {
          $ref: "#/components/schemas/AzureOpenAIEmbeddingConfig",
        },
        {
          $ref: "#/components/schemas/CohereEmbeddingConfig",
        },
        {
          $ref: "#/components/schemas/GeminiEmbeddingConfig",
        },
        {
          $ref: "#/components/schemas/HuggingFaceInferenceAPIEmbeddingConfig",
        },
        {
          $ref: "#/components/schemas/OpenAIEmbeddingConfig",
        },
        {
          $ref: "#/components/schemas/VertexAIEmbeddingConfig",
        },
        {
          $ref: "#/components/schemas/BedrockEmbeddingConfig",
        },
      ],
      title: "Embedding Config",
      description:
        "The embedding configuration for the embedding model config.",
      discriminator: {
        propertyName: "type",
        mapping: {
          AZURE_EMBEDDING: "#/components/schemas/AzureOpenAIEmbeddingConfig",
          BEDROCK_EMBEDDING: "#/components/schemas/BedrockEmbeddingConfig",
          COHERE_EMBEDDING: "#/components/schemas/CohereEmbeddingConfig",
          GEMINI_EMBEDDING: "#/components/schemas/GeminiEmbeddingConfig",
          HUGGINGFACE_API_EMBEDDING:
            "#/components/schemas/HuggingFaceInferenceAPIEmbeddingConfig",
          OPENAI_EMBEDDING: "#/components/schemas/OpenAIEmbeddingConfig",
          VERTEXAI_EMBEDDING: "#/components/schemas/VertexAIEmbeddingConfig",
        },
      },
    },
    project_id: {
      type: "string",
      format: "uuid",
      title: "Project Id",
    },
  },
  type: "object",
  required: ["id", "name", "embedding_config", "project_id"],
  title: "EmbeddingModelConfig",
  description: "Schema for an embedding model config.",
} as const;

export const EmbeddingModelConfigCreateSchema = {
  properties: {
    name: {
      type: "string",
      title: "Name",
      description: "The name of the embedding model config.",
    },
    embedding_config: {
      oneOf: [
        {
          $ref: "#/components/schemas/AzureOpenAIEmbeddingConfig",
        },
        {
          $ref: "#/components/schemas/CohereEmbeddingConfig",
        },
        {
          $ref: "#/components/schemas/GeminiEmbeddingConfig",
        },
        {
          $ref: "#/components/schemas/HuggingFaceInferenceAPIEmbeddingConfig",
        },
        {
          $ref: "#/components/schemas/OpenAIEmbeddingConfig",
        },
        {
          $ref: "#/components/schemas/VertexAIEmbeddingConfig",
        },
        {
          $ref: "#/components/schemas/BedrockEmbeddingConfig",
        },
      ],
      title: "Embedding Config",
      description:
        "The embedding configuration for the embedding model config.",
      discriminator: {
        propertyName: "type",
        mapping: {
          AZURE_EMBEDDING: "#/components/schemas/AzureOpenAIEmbeddingConfig",
          BEDROCK_EMBEDDING: "#/components/schemas/BedrockEmbeddingConfig",
          COHERE_EMBEDDING: "#/components/schemas/CohereEmbeddingConfig",
          GEMINI_EMBEDDING: "#/components/schemas/GeminiEmbeddingConfig",
          HUGGINGFACE_API_EMBEDDING:
            "#/components/schemas/HuggingFaceInferenceAPIEmbeddingConfig",
          OPENAI_EMBEDDING: "#/components/schemas/OpenAIEmbeddingConfig",
          VERTEXAI_EMBEDDING: "#/components/schemas/VertexAIEmbeddingConfig",
        },
      },
    },
  },
  type: "object",
  required: ["name", "embedding_config"],
  title: "EmbeddingModelConfigCreate",
} as const;

export const EmbeddingModelConfigUpdateSchema = {
  properties: {
    name: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Name",
      description: "The name of the embedding model config.",
    },
    embedding_config: {
      anyOf: [
        {
          oneOf: [
            {
              $ref: "#/components/schemas/AzureOpenAIEmbeddingConfig",
            },
            {
              $ref: "#/components/schemas/CohereEmbeddingConfig",
            },
            {
              $ref: "#/components/schemas/GeminiEmbeddingConfig",
            },
            {
              $ref: "#/components/schemas/HuggingFaceInferenceAPIEmbeddingConfig",
            },
            {
              $ref: "#/components/schemas/OpenAIEmbeddingConfig",
            },
            {
              $ref: "#/components/schemas/VertexAIEmbeddingConfig",
            },
            {
              $ref: "#/components/schemas/BedrockEmbeddingConfig",
            },
          ],
          discriminator: {
            propertyName: "type",
            mapping: {
              AZURE_EMBEDDING:
                "#/components/schemas/AzureOpenAIEmbeddingConfig",
              BEDROCK_EMBEDDING: "#/components/schemas/BedrockEmbeddingConfig",
              COHERE_EMBEDDING: "#/components/schemas/CohereEmbeddingConfig",
              GEMINI_EMBEDDING: "#/components/schemas/GeminiEmbeddingConfig",
              HUGGINGFACE_API_EMBEDDING:
                "#/components/schemas/HuggingFaceInferenceAPIEmbeddingConfig",
              OPENAI_EMBEDDING: "#/components/schemas/OpenAIEmbeddingConfig",
              VERTEXAI_EMBEDDING:
                "#/components/schemas/VertexAIEmbeddingConfig",
            },
          },
        },
        {
          type: "null",
        },
      ],
      title: "Embedding Config",
      description:
        "The embedding configuration for the embedding model config.",
    },
  },
  type: "object",
  title: "EmbeddingModelConfigUpdate",
} as const;

export const EvalExecutionParamsSchema = {
  properties: {
    llm_model: {
      $ref: "#/components/schemas/SupportedLLMModelNames",
      description: "The LLM model to use within eval execution.",
      default: "GPT_4O",
    },
    qa_prompt_tmpl: {
      type: "string",
      title: "Qa Prompt Tmpl",
      description: "The template to use for the question answering prompt.",
      default: `Context information is below.
---------------------
{context_str}
---------------------
Given the context information and not prior knowledge, answer the query.
Query: {query_str}
Answer: `,
    },
  },
  type: "object",
  title: "EvalExecutionParams",
  description: "Schema for the params for an eval execution.",
} as const;

export const ExtractAgentSchema = {
  properties: {
    id: {
      type: "string",
      format: "uuid",
      title: "Id",
      description: "The id of the extraction agent.",
    },
    name: {
      type: "string",
      title: "Name",
      description: "The name of the extraction agent.",
    },
    project_id: {
      type: "string",
      format: "uuid",
      title: "Project Id",
      description:
        "The ID of the project that the extraction agent belongs to.",
    },
    data_schema: {
      additionalProperties: {
        anyOf: [
          {
            additionalProperties: true,
            type: "object",
          },
          {
            items: {},
            type: "array",
          },
          {
            type: "string",
          },
          {
            type: "integer",
          },
          {
            type: "number",
          },
          {
            type: "boolean",
          },
          {
            type: "null",
          },
        ],
      },
      type: "object",
      title: "Data Schema",
      description: "The schema of the data.",
    },
    config: {
      $ref: "#/components/schemas/ExtractConfig",
      description: "The configuration parameters for the extraction agent.",
    },
    custom_configuration: {
      anyOf: [
        {
          type: "string",
          const: "default",
        },
        {
          type: "null",
        },
      ],
      title: "Custom Configuration",
      description:
        "Custom configuration type for the extraction agent. Currently supports 'default'.",
    },
    created_at: {
      anyOf: [
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Created At",
      description: "The creation time of the extraction agent.",
    },
    updated_at: {
      anyOf: [
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Updated At",
      description: "The last update time of the extraction agent.",
    },
  },
  type: "object",
  required: ["id", "name", "project_id", "data_schema", "config"],
  title: "ExtractAgent",
  description: "Schema and configuration for creating an extraction agent.",
} as const;

export const ExtractAgentCreateSchema = {
  properties: {
    name: {
      type: "string",
      maxLength: 3000,
      minLength: 1,
      title: "Name",
      description: "The name of the extraction schema",
    },
    data_schema: {
      anyOf: [
        {
          additionalProperties: {
            anyOf: [
              {
                additionalProperties: true,
                type: "object",
              },
              {
                items: {},
                type: "array",
              },
              {
                type: "string",
              },
              {
                type: "integer",
              },
              {
                type: "number",
              },
              {
                type: "boolean",
              },
              {
                type: "null",
              },
            ],
          },
          type: "object",
        },
        {
          type: "string",
        },
      ],
      title: "Data Schema",
      description: "The schema of the data.",
    },
    config: {
      $ref: "#/components/schemas/ExtractConfig",
      description: "The configuration parameters for the extraction agent.",
    },
  },
  type: "object",
  required: ["name", "data_schema", "config"],
  title: "ExtractAgentCreate",
  description: "Settings for creating an extraction agent.",
} as const;

export const ExtractAgentUpdateSchema = {
  properties: {
    data_schema: {
      anyOf: [
        {
          additionalProperties: {
            anyOf: [
              {
                additionalProperties: true,
                type: "object",
              },
              {
                items: {},
                type: "array",
              },
              {
                type: "string",
              },
              {
                type: "integer",
              },
              {
                type: "number",
              },
              {
                type: "boolean",
              },
              {
                type: "null",
              },
            ],
          },
          type: "object",
        },
        {
          type: "string",
        },
      ],
      title: "Data Schema",
      description: "The schema of the data",
    },
    config: {
      $ref: "#/components/schemas/ExtractConfig",
      description: "The configuration parameters for the extraction agent.",
    },
  },
  type: "object",
  required: ["data_schema", "config"],
  title: "ExtractAgentUpdate",
  description: "Settings for updating an extraction schema.",
} as const;

export const ExtractConfigSchema = {
  properties: {
    priority: {
      anyOf: [
        {
          type: "string",
          enum: ["low", "medium", "high", "critical"],
        },
        {
          type: "null",
        },
      ],
      title: "Priority",
      description:
        "The priority for the request. This field may be ignored or overwritten depending on the organization tier.",
    },
    extraction_target: {
      $ref: "#/components/schemas/ExtractTarget",
      description: "The extraction target specified.",
      default: "PER_DOC",
    },
    extraction_mode: {
      $ref: "#/components/schemas/ExtractMode",
      description:
        "The extraction mode specified (FAST, BALANCED, MULTIMODAL, PREMIUM).",
      default: "BALANCED",
    },
    parse_model: {
      anyOf: [
        {
          $ref: "#/components/schemas/PublicModelName",
        },
        {
          type: "null",
        },
      ],
      description:
        "The parse model to use for document parsing. If not provided, uses the default for the extraction mode.",
    },
    extract_model: {
      anyOf: [
        {
          $ref: "#/components/schemas/ExtractModels",
        },
        {
          type: "null",
        },
      ],
      description:
        "The extract model to use for data extraction. If not provided, uses the default for the extraction mode.",
    },
    multimodal_fast_mode: {
      type: "boolean",
      title: "Multimodal Fast Mode",
      description:
        "DEPRECATED: Whether to use fast mode for multimodal extraction.",
      default: false,
    },
    system_prompt: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "System Prompt",
      description: "The system prompt to use for the extraction.",
    },
    use_reasoning: {
      type: "boolean",
      title: "Use Reasoning",
      description: "Whether to use reasoning for the extraction.",
      default: false,
    },
    cite_sources: {
      type: "boolean",
      title: "Cite Sources",
      description: "Whether to cite sources for the extraction.",
      default: false,
    },
    confidence_scores: {
      type: "boolean",
      title: "Confidence Scores",
      description: "Whether to fetch confidence scores for the extraction.",
      default: false,
    },
    chunk_mode: {
      $ref: "#/components/schemas/DocumentChunkMode",
      description: "The mode to use for chunking the document.",
      default: "PAGE",
    },
    high_resolution_mode: {
      type: "boolean",
      title: "High Resolution Mode",
      description: "Whether to use high resolution mode for the extraction.",
      default: false,
    },
    invalidate_cache: {
      type: "boolean",
      title: "Invalidate Cache",
      description: "Whether to invalidate the cache for the extraction.",
      default: false,
    },
    num_pages_context: {
      anyOf: [
        {
          type: "integer",
          minimum: 1,
        },
        {
          type: "null",
        },
      ],
      title: "Num Pages Context",
      description:
        "Number of pages to pass as context on long document extraction.",
    },
    page_range: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Page Range",
      description:
        "Comma-separated list of page numbers or ranges to extract from (1-based, e.g., '1,3,5-7,9' or '1-3,8-10').",
    },
  },
  type: "object",
  title: "ExtractConfig",
  description: "Additional parameters for the extraction agent.",
} as const;

export const ExtractJobSchema = {
  properties: {
    id: {
      type: "string",
      format: "uuid",
      title: "Id",
      description: "The id of the extraction job",
    },
    extraction_agent: {
      $ref: "#/components/schemas/ExtractAgent",
      description: "The agent that the job was run on.",
    },
    status: {
      $ref: "#/components/schemas/StatusEnum",
      description: "The status of the extraction job",
    },
    error: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Error",
      description: "The error that occurred during extraction",
    },
    file: {
      $ref: "#/components/schemas/File",
      description: "The file that the extract was extracted from",
    },
  },
  type: "object",
  required: ["id", "extraction_agent", "status", "file"],
  title: "ExtractJob",
} as const;

export const ExtractJobCreateSchema = {
  properties: {
    priority: {
      anyOf: [
        {
          type: "string",
          enum: ["low", "medium", "high", "critical"],
        },
        {
          type: "null",
        },
      ],
      title: "Priority",
      description:
        "The priority for the request. This field may be ignored or overwritten depending on the organization tier.",
    },
    webhook_configurations: {
      anyOf: [
        {
          items: {
            $ref: "#/components/schemas/WebhookConfiguration",
          },
          type: "array",
        },
        {
          type: "null",
        },
      ],
      title: "Webhook Configurations",
      description: "The outbound webhook configurations",
    },
    extraction_agent_id: {
      type: "string",
      format: "uuid",
      title: "Extraction Agent Id",
      description: "The id of the extraction agent",
    },
    file_id: {
      type: "string",
      format: "uuid",
      title: "File Id",
      description: "The id of the file",
    },
    data_schema_override: {
      anyOf: [
        {
          additionalProperties: {
            anyOf: [
              {
                additionalProperties: true,
                type: "object",
              },
              {
                items: {},
                type: "array",
              },
              {
                type: "string",
              },
              {
                type: "integer",
              },
              {
                type: "number",
              },
              {
                type: "boolean",
              },
              {
                type: "null",
              },
            ],
          },
          type: "object",
        },
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Data Schema Override",
      description:
        "The data schema to override the extraction agent's data schema with",
    },
    config_override: {
      anyOf: [
        {
          $ref: "#/components/schemas/ExtractConfig",
        },
        {
          type: "null",
        },
      ],
      description: "The config to override the extraction agent's config with",
    },
  },
  type: "object",
  required: ["extraction_agent_id", "file_id"],
  title: "ExtractJobCreate",
  description: "Schema for creating an extraction job.",
} as const;

export const ExtractJobCreateBatchSchema = {
  properties: {
    extraction_agent_id: {
      type: "string",
      format: "uuid",
      title: "Extraction Agent Id",
      description: "The id of the extraction agent",
    },
    file_ids: {
      items: {
        type: "string",
        format: "uuid",
      },
      type: "array",
      minItems: 1,
      title: "File Ids",
      description: "The ids of the files",
    },
    data_schema_override: {
      anyOf: [
        {
          additionalProperties: {
            anyOf: [
              {
                additionalProperties: true,
                type: "object",
              },
              {
                items: {},
                type: "array",
              },
              {
                type: "string",
              },
              {
                type: "integer",
              },
              {
                type: "number",
              },
              {
                type: "boolean",
              },
              {
                type: "null",
              },
            ],
          },
          type: "object",
        },
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Data Schema Override",
      description:
        "The data schema to override the extraction agent's data schema with",
    },
    config_override: {
      anyOf: [
        {
          $ref: "#/components/schemas/ExtractConfig",
        },
        {
          type: "null",
        },
      ],
      description: "The config to override the extraction agent's config with",
    },
  },
  type: "object",
  required: ["extraction_agent_id", "file_ids"],
  title: "ExtractJobCreateBatch",
  description: "Schema for creating extraction jobs in batch.",
} as const;

export const ExtractModeSchema = {
  type: "string",
  enum: ["FAST", "BALANCED", "PREMIUM", "MULTIMODAL"],
  title: "ExtractMode",
} as const;

export const ExtractModelsSchema = {
  type: "string",
  enum: [
    "openai-gpt-4-1",
    "openai-gpt-4-1-mini",
    "openai-gpt-4-1-nano",
    "openai-gpt-5",
    "openai-gpt-5-mini",
    "gemini-2.0-flash",
    "gemini-2.5-flash",
    "gemini-2.5-flash-lite",
    "gemini-2.5-pro",
    "openai-gpt-4o",
    "openai-gpt-4o-mini",
  ],
  title: "ExtractModels",
} as const;

export const ExtractResultsetSchema = {
  properties: {
    run_id: {
      type: "string",
      format: "uuid",
      title: "Run Id",
      description: "The id of the extraction run",
    },
    extraction_agent_id: {
      type: "string",
      format: "uuid",
      title: "Extraction Agent Id",
      description: "The id of the extraction agent",
    },
    data: {
      anyOf: [
        {
          additionalProperties: {
            anyOf: [
              {
                additionalProperties: true,
                type: "object",
              },
              {
                items: {},
                type: "array",
              },
              {
                type: "string",
              },
              {
                type: "integer",
              },
              {
                type: "number",
              },
              {
                type: "boolean",
              },
              {
                type: "null",
              },
            ],
          },
          type: "object",
        },
        {
          items: {
            additionalProperties: {
              anyOf: [
                {
                  additionalProperties: true,
                  type: "object",
                },
                {
                  items: {},
                  type: "array",
                },
                {
                  type: "string",
                },
                {
                  type: "integer",
                },
                {
                  type: "number",
                },
                {
                  type: "boolean",
                },
                {
                  type: "null",
                },
              ],
            },
            type: "object",
          },
          type: "array",
        },
        {
          type: "null",
        },
      ],
      title: "Data",
      description: "The data extracted from the file",
    },
    extraction_metadata: {
      additionalProperties: {
        anyOf: [
          {
            additionalProperties: true,
            type: "object",
          },
          {
            items: {},
            type: "array",
          },
          {
            type: "string",
          },
          {
            type: "integer",
          },
          {
            type: "number",
          },
          {
            type: "boolean",
          },
          {
            type: "null",
          },
        ],
      },
      type: "object",
      title: "Extraction Metadata",
      description: "The metadata extracted from the file",
    },
  },
  type: "object",
  required: ["run_id", "extraction_agent_id", "data", "extraction_metadata"],
  title: "ExtractResultset",
  description: "Schema for an extraction resultset.",
} as const;

export const ExtractRunSchema = {
  properties: {
    id: {
      type: "string",
      format: "uuid",
      title: "Id",
      description: "The id of the extraction run",
    },
    created_at: {
      anyOf: [
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Created At",
      description: "Creation datetime",
    },
    updated_at: {
      anyOf: [
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Updated At",
      description: "Update datetime",
    },
    extraction_agent_id: {
      type: "string",
      format: "uuid",
      title: "Extraction Agent Id",
      description: "The id of the extraction agent",
    },
    data_schema: {
      additionalProperties: {
        anyOf: [
          {
            additionalProperties: true,
            type: "object",
          },
          {
            items: {},
            type: "array",
          },
          {
            type: "string",
          },
          {
            type: "integer",
          },
          {
            type: "number",
          },
          {
            type: "boolean",
          },
          {
            type: "null",
          },
        ],
      },
      type: "object",
      title: "Data Schema",
      description: "The schema used for extraction",
    },
    config: {
      $ref: "#/components/schemas/ExtractConfig",
      description: "The config used for extraction",
    },
    file: {
      $ref: "#/components/schemas/File",
      description: "The file that the extract was extracted from",
    },
    status: {
      $ref: "#/components/schemas/ExtractState",
      description: "The status of the extraction run",
    },
    error: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Error",
      description: "The error that occurred during extraction",
    },
    job_id: {
      anyOf: [
        {
          type: "string",
          format: "uuid",
        },
        {
          type: "null",
        },
      ],
      title: "Job Id",
      description: "The id of the job that the extraction run belongs to",
    },
    data: {
      anyOf: [
        {
          additionalProperties: {
            anyOf: [
              {
                additionalProperties: true,
                type: "object",
              },
              {
                items: {},
                type: "array",
              },
              {
                type: "string",
              },
              {
                type: "integer",
              },
              {
                type: "number",
              },
              {
                type: "boolean",
              },
              {
                type: "null",
              },
            ],
          },
          type: "object",
        },
        {
          items: {
            additionalProperties: {
              anyOf: [
                {
                  additionalProperties: true,
                  type: "object",
                },
                {
                  items: {},
                  type: "array",
                },
                {
                  type: "string",
                },
                {
                  type: "integer",
                },
                {
                  type: "number",
                },
                {
                  type: "boolean",
                },
                {
                  type: "null",
                },
              ],
            },
            type: "object",
          },
          type: "array",
        },
        {
          type: "null",
        },
      ],
      title: "Data",
      description: "The data extracted from the file",
    },
    extraction_metadata: {
      anyOf: [
        {
          additionalProperties: {
            anyOf: [
              {
                additionalProperties: true,
                type: "object",
              },
              {
                items: {},
                type: "array",
              },
              {
                type: "string",
              },
              {
                type: "integer",
              },
              {
                type: "number",
              },
              {
                type: "boolean",
              },
              {
                type: "null",
              },
            ],
          },
          type: "object",
        },
        {
          type: "null",
        },
      ],
      title: "Extraction Metadata",
      description: "The metadata extracted from the file",
    },
    from_ui: {
      type: "boolean",
      title: "From Ui",
      description: "Whether this extraction run was triggered from the UI",
    },
  },
  type: "object",
  required: [
    "id",
    "extraction_agent_id",
    "data_schema",
    "config",
    "file",
    "status",
    "from_ui",
  ],
  title: "ExtractRun",
  description: "Schema for an extraction run.",
} as const;

export const ExtractSchemaGenerateRequestSchema = {
  properties: {
    prompt: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Prompt",
      description:
        "Natural language description of the data structure to extract",
    },
    file_id: {
      anyOf: [
        {
          type: "string",
          format: "uuid",
        },
        {
          type: "null",
        },
      ],
      title: "File Id",
      description: "Optional file ID to analyze for schema generation",
    },
  },
  type: "object",
  title: "ExtractSchemaGenerateRequest",
  description: "Request schema for generating an extraction schema.",
} as const;

export const ExtractSchemaGenerateResponseSchema = {
  properties: {
    data_schema: {
      additionalProperties: {
        anyOf: [
          {
            additionalProperties: true,
            type: "object",
          },
          {
            items: {},
            type: "array",
          },
          {
            type: "string",
          },
          {
            type: "integer",
          },
          {
            type: "number",
          },
          {
            type: "boolean",
          },
          {
            type: "null",
          },
        ],
      },
      type: "object",
      title: "Data Schema",
      description: "The generated JSON schema",
    },
  },
  type: "object",
  required: ["data_schema"],
  title: "ExtractSchemaGenerateResponse",
  description: "Response schema for schema generation.",
} as const;

export const ExtractSchemaValidateRequestSchema = {
  properties: {
    data_schema: {
      anyOf: [
        {
          additionalProperties: {
            anyOf: [
              {
                additionalProperties: true,
                type: "object",
              },
              {
                items: {},
                type: "array",
              },
              {
                type: "string",
              },
              {
                type: "integer",
              },
              {
                type: "number",
              },
              {
                type: "boolean",
              },
              {
                type: "null",
              },
            ],
          },
          type: "object",
        },
        {
          type: "string",
        },
      ],
      title: "Data Schema",
    },
  },
  type: "object",
  required: ["data_schema"],
  title: "ExtractSchemaValidateRequest",
} as const;

export const ExtractSchemaValidateResponseSchema = {
  properties: {
    data_schema: {
      additionalProperties: {
        anyOf: [
          {
            additionalProperties: true,
            type: "object",
          },
          {
            items: {},
            type: "array",
          },
          {
            type: "string",
          },
          {
            type: "integer",
          },
          {
            type: "number",
          },
          {
            type: "boolean",
          },
          {
            type: "null",
          },
        ],
      },
      type: "object",
      title: "Data Schema",
    },
  },
  type: "object",
  required: ["data_schema"],
  title: "ExtractSchemaValidateResponse",
} as const;

export const ExtractStateSchema = {
  type: "string",
  enum: ["CREATED", "PENDING", "SUCCESS", "ERROR"],
  title: "ExtractState",
} as const;

export const ExtractStatelessRequestSchema = {
  properties: {
    webhook_configurations: {
      anyOf: [
        {
          items: {
            $ref: "#/components/schemas/WebhookConfiguration",
          },
          type: "array",
        },
        {
          type: "null",
        },
      ],
      title: "Webhook Configurations",
      description: "The outbound webhook configurations",
    },
    data_schema: {
      anyOf: [
        {
          additionalProperties: {
            anyOf: [
              {
                additionalProperties: true,
                type: "object",
              },
              {
                items: {},
                type: "array",
              },
              {
                type: "string",
              },
              {
                type: "integer",
              },
              {
                type: "number",
              },
              {
                type: "boolean",
              },
              {
                type: "null",
              },
            ],
          },
          type: "object",
        },
        {
          type: "string",
        },
      ],
      title: "Data Schema",
      description: "The schema of the data to extract",
    },
    config: {
      $ref: "#/components/schemas/ExtractConfig",
      description: "The configuration parameters for the extraction",
    },
    file_id: {
      anyOf: [
        {
          type: "string",
          format: "uuid",
        },
        {
          type: "null",
        },
      ],
      title: "File Id",
      description: "The ID of the file to extract from",
    },
    text: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Text",
      description: "The text content to extract from",
    },
    file: {
      anyOf: [
        {
          $ref: "#/components/schemas/FileData",
        },
        {
          type: "null",
        },
      ],
      description: "The file data with base64 content and MIME type",
    },
  },
  type: "object",
  required: ["data_schema", "config"],
  title: "ExtractStatelessRequest",
  description: "Schema for stateless extraction requests.",
} as const;

export const ExtractTargetSchema = {
  type: "string",
  enum: ["PER_DOC", "PER_PAGE"],
  title: "ExtractTarget",
} as const;

export const ExtractedTableSchema = {
  properties: {
    table_id: {
      type: "integer",
      title: "Table Id",
      description: "Unique identifier for this table within the file",
    },
    sheet_name: {
      type: "string",
      title: "Sheet Name",
      description: "Worksheet name where table was found",
    },
    row_span: {
      type: "integer",
      title: "Row Span",
      description: "Number of rows in the table",
    },
    col_span: {
      type: "integer",
      title: "Col Span",
      description: "Number of columns in the table",
    },
    has_headers: {
      type: "boolean",
      title: "Has Headers",
      description: "Whether the table has header rows",
    },
    metadata_json: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Metadata Json",
      description: "JSON metadata with detailed table information",
    },
  },
  type: "object",
  required: ["table_id", "sheet_name", "row_span", "col_span", "has_headers"],
  title: "ExtractedTable",
  description: "A single extracted table from a spreadsheet",
} as const;

export const FailPageModeSchema = {
  type: "string",
  enum: ["raw_text", "blank_page", "error_message"],
  title: "FailPageMode",
  description:
    "Enum for representing the different available page error handling modes",
} as const;

export const FailureHandlingConfigSchema = {
  properties: {
    skip_list_failures: {
      type: "boolean",
      title: "Skip List Failures",
      description:
        "Whether to skip failed batches/lists and continue processing",
      default: false,
    },
  },
  type: "object",
  title: "FailureHandlingConfig",
  description:
    "Configuration for handling different types of failures during data source processing.",
} as const;

export const FileSchema = {
  properties: {
    id: {
      type: "string",
      format: "uuid",
      title: "Id",
      description: "Unique identifier",
    },
    created_at: {
      anyOf: [
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Created At",
      description: "Creation datetime",
    },
    updated_at: {
      anyOf: [
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Updated At",
      description: "Update datetime",
    },
    name: {
      type: "string",
      maxLength: 3000,
      minLength: 1,
      title: "Name",
    },
    external_file_id: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "External File Id",
      description: "The ID of the file in the external system",
    },
    file_size: {
      anyOf: [
        {
          type: "integer",
          minimum: 0,
        },
        {
          type: "null",
        },
      ],
      title: "File Size",
      description: "Size of the file in bytes",
    },
    file_type: {
      anyOf: [
        {
          type: "string",
          maxLength: 3000,
          minLength: 1,
        },
        {
          type: "null",
        },
      ],
      title: "File Type",
      description: "File type (e.g. pdf, docx, etc.)",
    },
    project_id: {
      type: "string",
      format: "uuid",
      title: "Project Id",
      description: "The ID of the project that the file belongs to",
    },
    last_modified_at: {
      anyOf: [
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Last Modified At",
      description: "The last modified time of the file",
    },
    resource_info: {
      anyOf: [
        {
          additionalProperties: {
            anyOf: [
              {
                additionalProperties: true,
                type: "object",
              },
              {
                items: {},
                type: "array",
              },
              {
                type: "string",
              },
              {
                type: "integer",
              },
              {
                type: "number",
              },
              {
                type: "boolean",
              },
              {
                type: "null",
              },
            ],
          },
          type: "object",
        },
        {
          type: "null",
        },
      ],
      title: "Resource Info",
      description: "Resource information for the file",
    },
    permission_info: {
      anyOf: [
        {
          additionalProperties: {
            anyOf: [
              {
                additionalProperties: true,
                type: "object",
              },
              {
                items: {},
                type: "array",
              },
              {
                type: "string",
              },
              {
                type: "integer",
              },
              {
                type: "number",
              },
              {
                type: "boolean",
              },
              {
                type: "null",
              },
            ],
          },
          type: "object",
        },
        {
          type: "null",
        },
      ],
      title: "Permission Info",
      description: "Permission information for the file",
    },
    data_source_id: {
      anyOf: [
        {
          type: "string",
          format: "uuid",
        },
        {
          type: "null",
        },
      ],
      title: "Data Source Id",
      description: "The ID of the data source that the file belongs to",
    },
  },
  type: "object",
  required: ["id", "name", "project_id"],
  title: "File",
  description: "Schema for a file.",
} as const;

export const FileClassificationSchema = {
  properties: {
    id: {
      type: "string",
      format: "uuid",
      title: "Id",
      description: "Unique identifier",
    },
    created_at: {
      anyOf: [
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Created At",
      description: "Creation datetime",
    },
    updated_at: {
      anyOf: [
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Updated At",
      description: "Update datetime",
    },
    classify_job_id: {
      type: "string",
      format: "uuid",
      title: "Classify Job Id",
      description: "The ID of the classify job",
    },
    file_id: {
      type: "string",
      format: "uuid",
      title: "File Id",
      description: "The ID of the classified file",
    },
    result: {
      anyOf: [
        {
          $ref: "#/components/schemas/ClassificationResult",
        },
        {
          type: "null",
        },
      ],
      description: "The classification result",
    },
  },
  type: "object",
  required: ["id", "classify_job_id", "file_id"],
  title: "FileClassification",
  description: "A file classification.",
} as const;

export const FileCountByStatusResponseSchema = {
  properties: {
    counts: {
      additionalProperties: {
        type: "integer",
      },
      type: "object",
      title: "Counts",
      description: "The counts of files by status",
    },
    total_count: {
      type: "integer",
      title: "Total Count",
      description: "The total number of files",
    },
    pipeline_id: {
      anyOf: [
        {
          type: "string",
          format: "uuid",
        },
        {
          type: "null",
        },
      ],
      title: "Pipeline Id",
      description: "The ID of the pipeline that the files belong to",
    },
    data_source_id: {
      anyOf: [
        {
          type: "string",
          format: "uuid",
        },
        {
          type: "null",
        },
      ],
      title: "Data Source Id",
      description: "The ID of the data source that the files belong to",
    },
    only_manually_uploaded: {
      type: "boolean",
      title: "Only Manually Uploaded",
      description: "Whether to only count manually uploaded files",
      default: false,
    },
  },
  type: "object",
  required: ["counts", "total_count"],
  title: "FileCountByStatusResponse",
} as const;

export const FileCreateSchema = {
  properties: {
    name: {
      type: "string",
      maxLength: 3000,
      minLength: 1,
      title: "Name",
      description:
        "Name that will be used for created file. If possible, always include the file extension in the name.",
    },
    external_file_id: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "External File Id",
      description: "The ID of the file in the external system",
    },
    file_size: {
      anyOf: [
        {
          type: "integer",
          minimum: 0,
        },
        {
          type: "null",
        },
      ],
      title: "File Size",
      description: "Size of the file in bytes",
    },
    last_modified_at: {
      anyOf: [
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Last Modified At",
      description: "The last modified time of the file",
    },
    resource_info: {
      anyOf: [
        {
          additionalProperties: {
            anyOf: [
              {
                additionalProperties: true,
                type: "object",
              },
              {
                items: {},
                type: "array",
              },
              {
                type: "string",
              },
              {
                type: "integer",
              },
              {
                type: "number",
              },
              {
                type: "boolean",
              },
              {
                type: "null",
              },
            ],
          },
          type: "object",
        },
        {
          type: "null",
        },
      ],
      title: "Resource Info",
      description: "Resource information for the file",
    },
    permission_info: {
      anyOf: [
        {
          additionalProperties: {
            anyOf: [
              {
                additionalProperties: true,
                type: "object",
              },
              {
                items: {},
                type: "array",
              },
              {
                type: "string",
              },
              {
                type: "integer",
              },
              {
                type: "number",
              },
              {
                type: "boolean",
              },
              {
                type: "null",
              },
            ],
          },
          type: "object",
        },
        {
          type: "null",
        },
      ],
      title: "Permission Info",
      description: "Permission information for the file",
    },
    data_source_id: {
      anyOf: [
        {
          type: "string",
          format: "uuid",
        },
        {
          type: "null",
        },
      ],
      title: "Data Source Id",
      description: "The ID of the data source that the file belongs to",
    },
  },
  type: "object",
  required: ["name"],
  title: "FileCreate",
} as const;

export const FileCreateFromUrlSchema = {
  properties: {
    name: {
      anyOf: [
        {
          type: "string",
          maxLength: 3000,
          minLength: 1,
        },
        {
          type: "null",
        },
      ],
      title: "Name",
      description:
        "Name that will be used for created file. If possible, always include the file extension in the name.",
    },
    url: {
      type: "string",
      minLength: 1,
      format: "uri",
      title: "Url",
      description: "URL of the file to download",
    },
    proxy_url: {
      anyOf: [
        {
          type: "string",
          minLength: 1,
          format: "uri",
        },
        {
          type: "null",
        },
      ],
      title: "Proxy Url",
      description: "URL of the proxy server to use for downloading the file",
    },
    request_headers: {
      anyOf: [
        {
          additionalProperties: {
            type: "string",
          },
          type: "object",
        },
        {
          type: "null",
        },
      ],
      title: "Request Headers",
      description:
        "Headers to include in the request when downloading the file",
    },
    verify_ssl: {
      type: "boolean",
      title: "Verify Ssl",
      description:
        "Whether to verify the SSL certificate when downloading the file",
      default: true,
    },
    follow_redirects: {
      type: "boolean",
      title: "Follow Redirects",
      description: "Whether to follow redirects when downloading the file",
      default: true,
    },
    resource_info: {
      anyOf: [
        {
          additionalProperties: {
            anyOf: [
              {
                additionalProperties: true,
                type: "object",
              },
              {
                items: {},
                type: "array",
              },
              {
                type: "string",
              },
              {
                type: "integer",
              },
              {
                type: "number",
              },
              {
                type: "boolean",
              },
              {
                type: "null",
              },
            ],
          },
          type: "object",
        },
        {
          type: "null",
        },
      ],
      title: "Resource Info",
      description: "Resource information for the file",
    },
  },
  type: "object",
  required: ["url"],
  title: "FileCreateFromUrl",
} as const;

export const FileDataSchema = {
  properties: {
    data: {
      type: "string",
      title: "Data",
      description: "The file content as base64-encoded string",
    },
    mime_type: {
      type: "string",
      title: "Mime Type",
      description:
        "The MIME type of the file (e.g., 'application/pdf', 'text/plain')",
    },
  },
  type: "object",
  required: ["data", "mime_type"],
  title: "FileData",
  description: "Schema for file data with base64 content and MIME type.",
} as const;

export const FileFilterSchema = {
  properties: {
    project_id: {
      anyOf: [
        {
          type: "string",
          format: "uuid",
        },
        {
          type: "null",
        },
      ],
      title: "Project Id",
      description: "Filter by project ID",
    },
    file_ids: {
      anyOf: [
        {
          items: {
            type: "string",
            format: "uuid",
          },
          type: "array",
        },
        {
          type: "null",
        },
      ],
      title: "File Ids",
      description: "Filter by specific file IDs",
    },
    file_name: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "File Name",
      description: "Filter by file name",
    },
    data_source_id: {
      anyOf: [
        {
          type: "string",
          format: "uuid",
        },
        {
          type: "null",
        },
      ],
      title: "Data Source Id",
      description: "Filter by data source ID",
    },
    external_file_id: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "External File Id",
      description: "Filter by external file ID",
    },
    only_manually_uploaded: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Only Manually Uploaded",
      description:
        "Filter only manually uploaded files (data_source_id is null)",
    },
  },
  type: "object",
  title: "FileFilter",
  description: "Filter parameters for file queries.",
} as const;

export const FileIdPresignedUrlSchema = {
  properties: {
    url: {
      type: "string",
      minLength: 1,
      format: "uri",
      title: "Url",
      description: "A presigned URL for IO operations against a private file",
    },
    expires_at: {
      type: "string",
      format: "date-time",
      title: "Expires At",
      description: "The time at which the presigned URL expires",
    },
    form_fields: {
      anyOf: [
        {
          additionalProperties: {
            type: "string",
          },
          type: "object",
        },
        {
          type: "null",
        },
      ],
      title: "Form Fields",
      description: "Form fields for a presigned POST request",
    },
    file_id: {
      type: "string",
      format: "uuid",
      title: "File Id",
      description: "The ID of the file associated with the presigned URL",
    },
  },
  type: "object",
  required: ["url", "expires_at", "file_id"],
  title: "FileIdPresignedUrl",
  description: "Schema for a presigned URL with a file ID.",
} as const;

export const FileParsePublicSchema = {
  properties: {
    created_at: {
      type: "string",
      format: "date-time",
      title: "Created At",
      description: "The date and time when the file was parsed.",
    },
    status: {
      type: "string",
      title: "Status",
      description: "The status of the parse task.",
    },
    started_at: {
      anyOf: [
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Started At",
      description: "The date and time when the file parse started.",
    },
    ended_at: {
      anyOf: [
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Ended At",
      description: "The date and time when the file parse ended.",
    },
    input_path: {
      type: "string",
      title: "Input Path",
      description: "The path to the input file.",
    },
    data_path: {
      type: "string",
      title: "Data Path",
      description: "The path to the data file.",
    },
  },
  type: "object",
  required: ["created_at", "status", "input_path", "data_path"],
  title: "FileParsePublic",
} as const;

export const FileQueryRequestSchema = {
  properties: {
    page_size: {
      anyOf: [
        {
          type: "integer",
        },
        {
          type: "null",
        },
      ],
      title: "Page Size",
      description:
        "The maximum number of items to return. The service may return fewer than this value. If unspecified, a default page size will be used. The maximum value is typically 1000; values above this will be coerced to the maximum.",
    },
    page_token: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Page Token",
      description:
        "A page token, received from a previous list call. Provide this to retrieve the subsequent page.",
    },
    filter: {
      anyOf: [
        {
          $ref: "#/components/schemas/FileFilter",
        },
        {
          type: "null",
        },
      ],
      description:
        "A filter object or expression that filters resources listed in the response.",
    },
    order_by: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Order By",
      description:
        "A comma-separated list of fields to order by, sorted in ascending order. Use 'field_name desc' to specify descending order.",
    },
  },
  type: "object",
  title: "FileQueryRequest",
  description:
    "Request schema for querying files with pagination and filtering.",
} as const;

export const FileQueryResponseSchema = {
  properties: {
    items: {
      items: {
        $ref: "#/components/schemas/File",
      },
      type: "array",
      title: "Items",
      description: "The list of items.",
    },
    next_page_token: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Next Page Token",
      description:
        "A token, which can be sent as page_token to retrieve the next page. If this field is omitted, there are no subsequent pages.",
    },
    total_size: {
      anyOf: [
        {
          type: "integer",
        },
        {
          type: "null",
        },
      ],
      title: "Total Size",
      description:
        "The total number of items available. This is only populated when specifically requested. The value may be an estimate and can be used for display purposes only.",
    },
  },
  type: "object",
  required: ["items"],
  title: "FileQueryResponse",
  description: "Response schema for paginated file queries.",
} as const;

export const FilterConditionSchema = {
  type: "string",
  enum: ["and", "or", "not"],
  title: "FilterCondition",
  description: "Vector store filter conditions to combine different filters.",
} as const;

export const FilterOperationSchema = {
  properties: {
    eq: {
      anyOf: [
        {
          type: "number",
        },
        {
          type: "integer",
        },
        {
          type: "string",
        },
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Eq",
    },
    gt: {
      anyOf: [
        {
          type: "number",
        },
        {
          type: "integer",
        },
        {
          type: "string",
        },
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Gt",
    },
    gte: {
      anyOf: [
        {
          type: "number",
        },
        {
          type: "integer",
        },
        {
          type: "string",
        },
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Gte",
    },
    lt: {
      anyOf: [
        {
          type: "number",
        },
        {
          type: "integer",
        },
        {
          type: "string",
        },
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Lt",
    },
    lte: {
      anyOf: [
        {
          type: "number",
        },
        {
          type: "integer",
        },
        {
          type: "string",
        },
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Lte",
    },
    includes: {
      items: {
        anyOf: [
          {
            type: "number",
          },
          {
            type: "integer",
          },
          {
            type: "string",
          },
          {
            type: "string",
            format: "date-time",
          },
          {
            type: "null",
          },
        ],
      },
      type: "array",
      title: "Includes",
    },
  },
  type: "object",
  title: "FilterOperation",
  description: "API request model for a filter comparison operation.",
} as const;

export const FilterOperatorSchema = {
  type: "string",
  enum: [
    "==",
    ">",
    "<",
    "!=",
    ">=",
    "<=",
    "in",
    "nin",
    "any",
    "all",
    "text_match",
    "text_match_insensitive",
    "contains",
    "is_empty",
  ],
  title: "FilterOperator",
  description: "Vector store filter operator.",
} as const;

export const FreeCreditsUsageSchema = {
  properties: {
    starting_balance: {
      type: "integer",
      title: "Starting Balance",
    },
    remaining_balance: {
      type: "integer",
      title: "Remaining Balance",
    },
    grant_name: {
      type: "string",
      title: "Grant Name",
    },
    expires_at: {
      type: "string",
      format: "date-time",
      title: "Expires At",
    },
  },
  type: "object",
  required: [
    "starting_balance",
    "remaining_balance",
    "grant_name",
    "expires_at",
  ],
  title: "FreeCreditsUsage",
} as const;

export const GeminiEmbeddingSchema = {
  properties: {
    model_name: {
      type: "string",
      title: "Model Name",
      description: "The modelId of the Gemini model to use.",
      default: "models/embedding-001",
    },
    embed_batch_size: {
      type: "integer",
      maximum: 2048,
      exclusiveMinimum: 0,
      title: "Embed Batch Size",
      description: "The batch size for embedding calls.",
      default: 10,
    },
    num_workers: {
      anyOf: [
        {
          type: "integer",
        },
        {
          type: "null",
        },
      ],
      title: "Num Workers",
      description: "The number of workers to use for async embedding calls.",
    },
    title: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Title",
      description:
        "Title is only applicable for retrieval_document tasks, and is used to represent a document title. For other tasks, title is invalid.",
      default: "",
    },
    task_type: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Task Type",
      description: "The task for embedding model.",
      default: "retrieval_document",
    },
    api_key: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Api Key",
      description: "API key to access the model. Defaults to None.",
    },
    api_base: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Api Base",
      description: "API base to access the model. Defaults to None.",
    },
    transport: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Transport",
      description: "Transport to access the model. Defaults to None.",
    },
    class_name: {
      type: "string",
      title: "Class Name",
      default: "GeminiEmbedding",
    },
  },
  type: "object",
  title: "GeminiEmbedding",
} as const;

export const GeminiEmbeddingConfigSchema = {
  properties: {
    type: {
      type: "string",
      const: "GEMINI_EMBEDDING",
      title: "Type",
      description: "Type of the embedding model.",
      default: "GEMINI_EMBEDDING",
    },
    component: {
      $ref: "#/components/schemas/GeminiEmbedding",
      description: "Configuration for the Gemini embedding model.",
    },
  },
  type: "object",
  title: "GeminiEmbeddingConfig",
} as const;

export const HTTPValidationErrorSchema = {
  properties: {
    detail: {
      items: {
        $ref: "#/components/schemas/ValidationError",
      },
      type: "array",
      title: "Detail",
    },
  },
  type: "object",
  title: "HTTPValidationError",
} as const;

export const HuggingFaceInferenceAPIEmbeddingSchema = {
  properties: {
    model_name: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Model Name",
      description: "Hugging Face model name. If None, the task will be used.",
    },
    embed_batch_size: {
      type: "integer",
      maximum: 2048,
      exclusiveMinimum: 0,
      title: "Embed Batch Size",
      description: "The batch size for embedding calls.",
      default: 10,
    },
    num_workers: {
      anyOf: [
        {
          type: "integer",
        },
        {
          type: "null",
        },
      ],
      title: "Num Workers",
      description: "The number of workers to use for async embedding calls.",
    },
    pooling: {
      anyOf: [
        {
          $ref: "#/components/schemas/Pooling",
        },
        {
          type: "null",
        },
      ],
      description:
        "Pooling strategy. If None, the model's default pooling is used.",
      default: "cls",
    },
    query_instruction: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Query Instruction",
      description: "Instruction to prepend during query embedding.",
    },
    text_instruction: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Text Instruction",
      description: "Instruction to prepend during text embedding.",
    },
    token: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Token",
      description:
        "Hugging Face token. Will default to the locally saved token. Pass token=False if you don’t want to send your token to the server.",
    },
    timeout: {
      anyOf: [
        {
          type: "number",
        },
        {
          type: "null",
        },
      ],
      title: "Timeout",
      description:
        "The maximum number of seconds to wait for a response from the server. Loading a new model in Inference API can take up to several minutes. Defaults to None, meaning it will loop until the server is available.",
    },
    headers: {
      anyOf: [
        {
          additionalProperties: {
            type: "string",
          },
          type: "object",
        },
        {
          type: "null",
        },
      ],
      title: "Headers",
      description:
        "Additional headers to send to the server. By default only the authorization and user-agent headers are sent. Values in this dictionary will override the default values.",
    },
    cookies: {
      anyOf: [
        {
          additionalProperties: {
            type: "string",
          },
          type: "object",
        },
        {
          type: "null",
        },
      ],
      title: "Cookies",
      description: "Additional cookies to send to the server.",
    },
    task: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Task",
      description:
        "Optional task to pick Hugging Face's recommended model, used when model_name is left as default of None.",
    },
    class_name: {
      type: "string",
      title: "Class Name",
      default: "HuggingFaceInferenceAPIEmbedding",
    },
  },
  type: "object",
  title: "HuggingFaceInferenceAPIEmbedding",
} as const;

export const HuggingFaceInferenceAPIEmbeddingConfigSchema = {
  properties: {
    type: {
      type: "string",
      const: "HUGGINGFACE_API_EMBEDDING",
      title: "Type",
      description: "Type of the embedding model.",
      default: "HUGGINGFACE_API_EMBEDDING",
    },
    component: {
      $ref: "#/components/schemas/HuggingFaceInferenceAPIEmbedding",
      description:
        "Configuration for the HuggingFace Inference API embedding model.",
    },
  },
  type: "object",
  title: "HuggingFaceInferenceAPIEmbeddingConfig",
} as const;

export const IngestionErrorResponseSchema = {
  properties: {
    job_id: {
      type: "string",
      format: "uuid",
      title: "Job Id",
      description: "ID of the job that failed.",
    },
    message: {
      type: "string",
      title: "Message",
      description: "List of errors that occurred during ingestion.",
    },
    step: {
      $ref: "#/components/schemas/JobNameMapping",
      description: "Name of the job that failed.",
    },
  },
  type: "object",
  required: ["job_id", "message", "step"],
  title: "IngestionErrorResponse",
} as const;

export const InputMessageSchema = {
  properties: {
    id: {
      type: "string",
      format: "uuid",
      title: "Id",
      description: "ID of the message, if any. a UUID.",
    },
    role: {
      $ref: "#/components/schemas/MessageRole",
    },
    content: {
      type: "string",
      title: "Content",
    },
    data: {
      anyOf: [
        {
          additionalProperties: true,
          type: "object",
        },
        {
          type: "null",
        },
      ],
      title: "Data",
      description: "Additional data to be stored with the message.",
    },
    class_name: {
      type: "string",
      title: "Class Name",
      default: "base_component",
    },
  },
  type: "object",
  required: ["role", "content"],
  title: "InputMessage",
  description:
    "This is distinct from a ChatMessage because this schema is enforced by the AI Chat library used in the frontend",
} as const;

export const JobNameMappingSchema = {
  type: "string",
  enum: [
    "MANAGED_INGESTION",
    "DATA_SOURCE",
    "FILES_UPDATE",
    "FILE_UPDATER",
    "PARSE",
    "TRANSFORM",
    "INGESTION",
    "METADATA_UPDATE",
  ],
  title: "JobNameMapping",
  description: "Enum for mapping original job names to readable names.",
} as const;

export const JobNamesSchema = {
  type: "string",
  enum: [
    "load_documents_job",
    "load_files_job",
    "playground_job",
    "pipeline_managed_ingestion_job",
    "data_source_update_dispatcher_job",
    "pipeline_file_update_dispatcher_job",
    "pipeline_file_updater_job",
    "file_managed_ingestion_job",
    "document_ingestion_job",
    "metadata_update_job",
    "parse_raw_file_job_cached",
    "extraction_job",
    "extract_job",
    "asyncio_test_job",
    "parse_raw_file_job",
    "llama_parse_transform_job",
  ],
  title: "JobNames",
  description: "Enum for executable pipeline job names.",
} as const;

export const JobRecordSchema = {
  properties: {
    webhook_configurations: {
      anyOf: [
        {
          items: {
            $ref: "#/components/schemas/WebhookConfiguration",
          },
          type: "array",
        },
        {
          type: "null",
        },
      ],
      title: "Webhook Configurations",
      description: "The outbound webhook configurations",
    },
    job_name: {
      $ref: "#/components/schemas/JobNames",
      description: "The name of the job.",
    },
    partitions: {
      additionalProperties: {
        anyOf: [
          {
            type: "string",
            format: "uuid",
          },
          {
            type: "string",
          },
        ],
      },
      propertyNames: {
        $ref: "#/components/schemas/PartitionNames",
      },
      type: "object",
      title: "Partitions",
      description:
        "The partitions for this execution. Used for determining where to save job output.",
    },
    parameters: {
      anyOf: [
        {
          oneOf: [
            {
              $ref: "#/components/schemas/ParseJobConfig",
            },
            {
              $ref: "#/components/schemas/LegacyParseJobConfig",
            },
            {
              $ref: "#/components/schemas/LoadFilesJobConfig",
            },
            {
              $ref: "#/components/schemas/LLamaParseTransformConfig",
            },
            {
              $ref: "#/components/schemas/PipelineManagedIngestionJobParams",
            },
            {
              $ref: "#/components/schemas/DataSourceUpdateDispatcherConfig",
            },
            {
              $ref: "#/components/schemas/PipelineFileUpdateDispatcherConfig",
            },
            {
              $ref: "#/components/schemas/PipelineFileUpdaterConfig",
            },
            {
              $ref: "#/components/schemas/DocumentIngestionJobParams",
            },
          ],
          discriminator: {
            propertyName: "type",
            mapping: {
              data_source_update_dispatcher:
                "#/components/schemas/DataSourceUpdateDispatcherConfig",
              document_ingestion:
                "#/components/schemas/DocumentIngestionJobParams",
              legacy_parse: "#/components/schemas/LegacyParseJobConfig",
              llama_parse_transform:
                "#/components/schemas/LLamaParseTransformConfig",
              load_files: "#/components/schemas/LoadFilesJobConfig",
              parse: "#/components/schemas/ParseJobConfig",
              pipeline_file_update_dispatcher:
                "#/components/schemas/PipelineFileUpdateDispatcherConfig",
              pipeline_file_updater:
                "#/components/schemas/PipelineFileUpdaterConfig",
              pipeline_managed_ingestion:
                "#/components/schemas/PipelineManagedIngestionJobParams",
            },
          },
        },
        {
          type: "null",
        },
      ],
      title: "Parameters",
      description: "Additional metadata for the job execution.",
    },
    session_id: {
      anyOf: [
        {
          type: "string",
          format: "uuid",
        },
        {
          type: "null",
        },
      ],
      title: "Session Id",
      description:
        "The upstream request ID that created this job. Used for tracking the job across services.",
    },
    correlation_id: {
      anyOf: [
        {
          type: "string",
          format: "uuid",
        },
        {
          type: "null",
        },
      ],
      title: "Correlation Id",
      description:
        "The correlation ID for this job. Used for tracking the job across services.",
    },
    parent_job_execution_id: {
      anyOf: [
        {
          type: "string",
          format: "uuid",
        },
        {
          type: "null",
        },
      ],
      title: "Parent Job Execution Id",
      description: "The ID of the parent job execution.",
    },
    user_id: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "User Id",
      description: "The ID of the user that created this job",
    },
    created_at: {
      type: "string",
      format: "date-time",
      title: "Created At",
      description: "Creation datetime",
    },
    project_id: {
      anyOf: [
        {
          type: "string",
          format: "uuid",
        },
        {
          type: "null",
        },
      ],
      title: "Project Id",
      description: "The ID of the project this job belongs to.",
    },
    id: {
      type: "string",
      format: "uuid",
      title: "Id",
      description: "Unique identifier",
    },
    status: {
      $ref: "#/components/schemas/StatusEnum",
    },
    error_code: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Error Code",
    },
    error_message: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Error Message",
    },
    attempts: {
      anyOf: [
        {
          type: "integer",
        },
        {
          type: "null",
        },
      ],
      title: "Attempts",
      description: "The number of times this job has been attempted",
      default: 0,
    },
    started_at: {
      anyOf: [
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Started At",
    },
    ended_at: {
      anyOf: [
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Ended At",
    },
    updated_at: {
      type: "string",
      format: "date-time",
      title: "Updated At",
      description: "Update datetime",
    },
  },
  type: "object",
  required: ["job_name", "partitions", "created_at", "status"],
  title: "JobRecord",
  description: "Schema for a job's metadata.",
} as const;

export const JobRecordWithUsageMetricsSchema = {
  properties: {
    job_record: {
      $ref: "#/components/schemas/JobRecord",
    },
    usage_metrics: {
      anyOf: [
        {
          $ref: "#/components/schemas/UsageMetricResponse",
        },
        {
          type: "null",
        },
      ],
    },
    user: {
      $ref: "#/components/schemas/UserJobRecord",
    },
  },
  type: "object",
  required: ["job_record", "user"],
  title: "JobRecordWithUsageMetrics",
} as const;

export const LLMModelDataSchema = {
  properties: {
    name: {
      type: "string",
      title: "Name",
      description: "The name of the LLM model.",
    },
    description: {
      type: "string",
      title: "Description",
      description: "The description of the LLM model.",
    },
    multi_modal: {
      type: "boolean",
      title: "Multi Modal",
      description: "Whether the model supports multi-modal image input",
    },
    model_name: {
      type: "string",
      title: "Model Name",
      default: "The name of the model.",
    },
  },
  type: "object",
  required: ["name", "description", "multi_modal"],
  title: "LLMModelData",
  description: "Schema for an eval LLM model.",
} as const;

export const LLMParametersSchema = {
  properties: {
    model_name: {
      $ref: "#/components/schemas/SupportedLLMModelNames",
      description: "The name of the model to use for LLM completions.",
      default: "GPT_4O_MINI",
    },
    system_prompt: {
      anyOf: [
        {
          type: "string",
          maxLength: 3000,
        },
        {
          type: "null",
        },
      ],
      title: "System Prompt",
      description: "The system prompt to use for the completion.",
    },
    temperature: {
      anyOf: [
        {
          type: "number",
        },
        {
          type: "null",
        },
      ],
      title: "Temperature",
      description: "The temperature value for the model.",
      default: 0.1,
    },
    use_chain_of_thought_reasoning: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Use Chain Of Thought Reasoning",
      description: "Whether to use chain of thought reasoning.",
    },
    use_citation: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Use Citation",
      description: "Whether to show citations in the response.",
      default: true,
    },
    class_name: {
      type: "string",
      title: "Class Name",
      default: "base_component",
    },
  },
  type: "object",
  title: "LLMParameters",
} as const;

export const LLamaParseTransformConfigSchema = {
  properties: {
    custom_metadata: {
      anyOf: [
        {
          additionalProperties: true,
          type: "object",
        },
        {
          type: "null",
        },
      ],
      title: "Custom Metadata",
      description: "The custom metadata to attach to the documents.",
    },
    resource_info: {
      anyOf: [
        {
          additionalProperties: true,
          type: "object",
        },
        {
          type: "null",
        },
      ],
      title: "Resource Info",
      description: "The resource info about the file",
    },
    type: {
      type: "string",
      const: "llama_parse_transform",
      title: "Type",
      default: "llama_parse_transform",
    },
    file_output: {
      type: "string",
      title: "File Output",
      description: "Whether to delete the files",
    },
  },
  type: "object",
  required: ["file_output"],
  title: "LLamaParseTransformConfig",
  description: "Schema for the parameters of llamaparse transform job.",
} as const;

export const LegacyParseJobConfigSchema = {
  properties: {
    custom_metadata: {
      anyOf: [
        {
          additionalProperties: true,
          type: "object",
        },
        {
          type: "null",
        },
      ],
      title: "Custom Metadata",
      description: "The custom metadata to attach to the documents.",
    },
    resource_info: {
      anyOf: [
        {
          additionalProperties: true,
          type: "object",
        },
        {
          type: "null",
        },
      ],
      title: "Resource Info",
      description: "The resource info about the file",
    },
    type: {
      type: "string",
      const: "legacy_parse",
      title: "Type",
      default: "legacy_parse",
    },
    userId: {
      type: "string",
      title: "Userid",
      description: "The user ID.",
    },
    fileName: {
      type: "string",
      title: "Filename",
      description: "The file name.",
    },
    originalFileName: {
      type: "string",
      title: "Originalfilename",
      description: "The original file name.",
    },
    fileKey: {
      type: "string",
      title: "Filekey",
      description: "The file key.",
    },
    inputUrl: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Inputurl",
      description: "The input URL.",
    },
    httpProxy: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Httpproxy",
      description: "The HTTP proxy.",
    },
    fastMode: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Fastmode",
      description: "Whether to use fast mode.",
      default: false,
    },
    lang: {
      type: "string",
      title: "Lang",
      description: "The language.",
    },
    template: {
      type: "string",
      title: "Template",
      description: "The parsing instruction.",
      default: "",
    },
    pipelineId: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Pipelineid",
      description: "The pipeline ID.",
    },
    outputBucket: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Outputbucket",
      description: "The output bucket.",
    },
    fileId: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Fileid",
      description: "The file ID.",
    },
    fullFilePath: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Fullfilepath",
      description: "The full file path.",
    },
    fromLLamaCloud: {
      type: "boolean",
      title: "Fromllamacloud",
      description: "Whether the file is from LLama cloud.",
      default: false,
    },
    skipDiagonalText: {
      type: "boolean",
      title: "Skipdiagonaltext",
      description: "Whether to skip diagonal text.",
      default: false,
    },
    preserveLayoutAlignmentAcrossPages: {
      type: "boolean",
      title: "Preservelayoutalignmentacrosspages",
      description: "Whether to preserve layout alignment across pages.",
      default: false,
    },
    preserveVerySmallText: {
      type: "boolean",
      title: "Preserveverysmalltext",
      description: "Whether to preserve very small text lines.",
      default: false,
    },
    invalidateCache: {
      type: "boolean",
      title: "Invalidatecache",
      description: "Whether to invalidate the cache.",
    },
    outputPDFOfDocument: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Outputpdfofdocument",
      description: "Whether to output PDF of document",
      default: false,
    },
    outlinedTableExtraction: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Outlinedtableextraction",
      description: "Whether to try to extract outlined tables",
      default: false,
    },
    mergeTablesAcrossPagesInMarkdown: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Mergetablesacrosspagesinmarkdown",
      description: "Whether to merge tables across pages in markdown",
      default: false,
    },
    saveImages: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Saveimages",
      description: "Whether to output images contained in the document",
      default: false,
    },
    gpt4o: {
      type: "boolean",
      title: "Gpt4O",
      description: "Whether to use GPT4o.",
      default: false,
    },
    openAIAPIKey: {
      type: "string",
      title: "Openaiapikey",
      description: "The OpenAI API key.",
    },
    doNotUnrollColumns: {
      type: "boolean",
      title: "Donotunrollcolumns",
      description: "Whether to unroll columns.",
      default: false,
    },
    spreadSheetExtractSubTables: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Spreadsheetextractsubtables",
      description: "Whether to extract subTables from spreadsheet.",
      default: false,
    },
    spreadSheetForceFormulaComputation: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Spreadsheetforceformulacomputation",
      description:
        "Whether to force re-computation of spreadsheet cells containing formulas.",
      default: false,
    },
    extractLayout: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Extractlayout",
      description: "Whether to perform layout extraction.",
      default: false,
    },
    highResOcr: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Highresocr",
      description: "Whether to use high resolution OCR (Slow).",
      default: false,
    },
    htmlMakeAllElementsVisible: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Htmlmakeallelementsvisible",
      description: "Whether to make all elements visible.",
      default: false,
    },
    htmlRemoveFixedElements: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Htmlremovefixedelements",
      description: "Whether to remove fixed elements.",
      default: false,
    },
    htmlRemoveNavigationElements: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Htmlremovenavigationelements",
      description: "Whether to remove navigation elements.",
      default: false,
    },
    guessXLSXSheetName: {
      type: "boolean",
      title: "Guessxlsxsheetname",
      description:
        "Whether to guess the XLSX sheet name when generation output xlsx.",
      default: false,
    },
    doNotCache: {
      type: "boolean",
      title: "Donotcache",
      description: "Whether to cache.",
      default: false,
    },
    pageSeparator: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Pageseparator",
      description: "The page separator.",
    },
    boundingBox: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Boundingbox",
      description:
        "A string describing a bounding box to use to parse the document. Contain 4 value between 0 to 1 representing in clock wise order the margin top, right, bottom, left of the selection bounding box in ratio of the document.",
    },
    bboxTop: {
      anyOf: [
        {
          type: "number",
        },
        {
          type: "null",
        },
      ],
      title: "Bboxtop",
      description: "The top side of the bounding box.",
    },
    bboxRight: {
      anyOf: [
        {
          type: "number",
        },
        {
          type: "null",
        },
      ],
      title: "Bboxright",
      description: "The right side of the bounding box.",
    },
    bboxBottom: {
      anyOf: [
        {
          type: "number",
        },
        {
          type: "null",
        },
      ],
      title: "Bboxbottom",
      description: "The bottom side of the bounding box.",
    },
    bboxLeft: {
      anyOf: [
        {
          type: "number",
        },
        {
          type: "null",
        },
      ],
      title: "Bboxleft",
      description: "The left side of the bounding box.",
    },
    disableReconstruction: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Disablereconstruction",
      description: "Whether to disable markdown reconstruction.",
      default: false,
    },
    targetPages: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Targetpages",
      description:
        "A string containing a list of comma separated containing the page number to extract. If not specified all pages are extracted from the document. The first page is the page 0.",
    },
    multimodalPipeline: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Multimodalpipeline",
      description: "True if parsing happen in multimodal mode.",
    },
    multimodalModel: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Multimodalmodel",
      description: "The multimodal model to use.",
    },
    model: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Model",
      description: "The model to use.",
    },
    vendorAPIKey: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Vendorapikey",
      description: "The multimodal vendor API key.",
    },
    pagePrefix: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Pageprefix",
      description: "A page prefix to add before each page.",
    },
    pageSuffix: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Pagesuffix",
      description: "A page suffix to add after each page.",
    },
    webhookUrl: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Webhookurl",
      description:
        "The URL that needs to be called at the end of the parsing job.",
    },
    preset: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Preset",
      description: "The preset of options to be used.",
    },
    takeScreenshot: {
      type: "boolean",
      title: "Takescreenshot",
      description: "Force to capture an image of each pages",
      default: false,
    },
    isFormattingInstruction: {
      type: "boolean",
      title: "Isformattinginstruction",
      description: "Allow the parsing instruction to also format the output.",
      default: true,
    },
    premiumMode: {
      type: "boolean",
      title: "Premiummode",
      description: "Whether to use premiumMode pipeline.",
      default: false,
    },
    continuousMode: {
      type: "boolean",
      title: "Continuousmode",
      description: "Whether to use continuousMode pipeline.",
      default: false,
    },
    disableOcr: {
      type: "boolean",
      title: "Disableocr",
      description:
        "Disable the OCR on the document. LlamaParse will only extract the copyable text from the document",
      default: false,
    },
    disableImageExtraction: {
      type: "boolean",
      title: "Disableimageextraction",
      description:
        "Disable the image extraction from the document. LlamaParse will not extract any image from the document.",
      default: false,
    },
    annotateLinks: {
      type: "boolean",
      title: "Annotatelinks",
      description:
        "Annotate links in markdown. LlamaParse will try to add links from document into the markdown.",
      default: false,
    },
    adaptiveLongTable: {
      type: "boolean",
      title: "Adaptivelongtable",
      description:
        "Adaptive long table. LlamaParse will try to detect long table and adapt the output.",
      default: false,
    },
    compactMarkdownTable: {
      type: "boolean",
      title: "Compactmarkdowntable",
      description:
        "Compact markdown table. LlamaParse will compact the markdown table to not include too many spaces.",
      default: false,
    },
    inputS3Path: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Inputs3Path",
      description:
        "If specified, llamaParse will take the specified file. should be a valid s3:// url",
    },
    inputS3Region: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Inputs3Region",
      description: "The region for the input S3 bucket.",
    },
    outputS3PathPrefix: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Outputs3Pathprefix",
      description:
        "If specified, llamaParse will save the output to the specified path. All output file will use this 'prefix' should be a valid s3:// url",
    },
    outputS3Region: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Outputs3Region",
      description: "The region for the output S3 bucket.",
    },
    projectId: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Projectid",
      description: "The project ID.",
    },
    azureOpenAiDeploymentName: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Azureopenaideploymentname",
      description: "Custom azure deployment name.",
    },
    azureOpenAiEndpoint: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Azureopenaiendpoint",
      description: "Custom azure endpoint.",
    },
    azureOpenAiApiVersion: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Azureopenaiapiversion",
      description: "Custom azure API version.",
    },
    azureOpenAiKey: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Azureopenaikey",
      description: "Custom azure API key.",
    },
    autoMode: {
      type: "boolean",
      title: "Automode",
      description: "Whether to use auto mode.",
      default: false,
    },
    autoModeTriggerOnTableInPage: {
      type: "boolean",
      title: "Automodetriggerontableinpage",
      description: "Whether to trigger on table in page.",
      default: false,
    },
    autoModeTriggerOnImageInPage: {
      type: "boolean",
      title: "Automodetriggeronimageinpage",
      description: "Whether to trigger on image in page.",
      default: false,
    },
    autoModeTriggerOnRegexpInPage: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Automodetriggeronregexpinpage",
      description: "The regexp to trigger on.",
    },
    autoModeTriggerOnTextInPage: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Automodetriggerontextinpage",
      description: "The text to trigger on.",
    },
    autoModeConfigurationJSON: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Automodeconfigurationjson",
      description:
        "The auto mode configuration JSON. This is a JSON string that contains the configuration for the auto mode.",
    },
    structuredOutput: {
      type: "boolean",
      title: "Structuredoutput",
      description: "Whether to use structured output.",
      default: false,
    },
    structuredOutputJSONSchema: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Structuredoutputjsonschema",
      description: "The structured output JSON schema.",
    },
    structuredOutputJSONSchemaName: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Structuredoutputjsonschemaname",
      description: "The structured output JSON schema name.",
    },
    maxPages: {
      anyOf: [
        {
          type: "integer",
        },
        {
          type: "null",
        },
      ],
      title: "Maxpages",
      description: "The maximum number of pages to parse.",
    },
    extractCharts: {
      type: "boolean",
      title: "Extractcharts",
      description: "Extract charts from the document.",
      default: false,
    },
    formattingInstruction: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Formattinginstruction",
      description:
        "A natural language instruction on how to format the result. Override LlamaParse default instruction.",
    },
    complementalFormattingInstruction: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Complementalformattinginstruction",
      description:
        "A natural language instruction on how to format the result that complement LlamaParse default instruction.",
    },
    contentGuidelineInstruction: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Contentguidelineinstruction",
      description:
        "A natural language instruction on how to transform the content of the result (not the format).",
    },
    jobTimeoutInSeconds: {
      anyOf: [
        {
          type: "number",
        },
        {
          type: "null",
        },
      ],
      title: "Jobtimeoutinseconds",
      description: "Manually set a timeout in second for a job. Minimum is 120",
    },
    jobTimeoutExtraTimePerPageInSeconds: {
      anyOf: [
        {
          type: "number",
        },
        {
          type: "null",
        },
      ],
      title: "Jobtimeoutextratimeperpageinseconds",
      description:
        "Manually set additional time per page for timeout in second for a job.",
    },
    strictModeImageExtraction: {
      type: "boolean",
      title: "Strictmodeimageextraction",
      description:
        "If true, the job will fail when we are not able to extract an image from a document.",
      default: false,
    },
    strictModeImageOCR: {
      type: "boolean",
      title: "Strictmodeimageocr",
      description:
        "If true, the job will fail when we are not able to OCR an image from a document.",
      default: false,
    },
    strictModeReconstruction: {
      type: "boolean",
      title: "Strictmodereconstruction",
      description:
        "If true, the job will fail when we are not able to transform a page to Markdown in a document.",
      default: false,
    },
    strictModeBuggyFont: {
      type: "boolean",
      title: "Strictmodebuggyfont",
      description:
        "If true, the job will fail when we are not able to extract a glyph from the document due to buggy font.",
      default: false,
    },
    ignoreDocumentElementsForLayoutDetection: {
      type: "boolean",
      title: "Ignoredocumentelementsforlayoutdetection",
      description:
        "If true, the job will ignore document element for layout detection, and instead just rely on a visual model, only apply to layout detection.",
      default: false,
    },
    outputTablesAsHTML: {
      type: "boolean",
      title: "Outputtablesashtml",
      description:
        "If true, the job will output tables as HTML in the markdown output, useful for merged cells.",
      default: false,
    },
    parseMode: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Parsemode",
      description: "The parsing mode.",
    },
    systemPrompt: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Systemprompt",
      description: "The system prompt.",
    },
    systemPromptAppend: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Systempromptappend",
      description: "The append to system prompt.",
    },
    userPrompt: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Userprompt",
      description: "The user prompt.",
    },
    pageHeaderPrefix: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Pageheaderprefix",
      description: "The page header prefix.",
    },
    pageHeaderSuffix: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Pageheadersuffix",
      description: "The page header suffix.",
    },
    pageFooterPrefix: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Pagefooterprefix",
      description: "The page footer prefix.",
    },
    pageFooterSuffix: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Pagefootersuffix",
      description: "The page footer suffix.",
    },
    hideHeaders: {
      type: "boolean",
      title: "Hideheaders",
      description: "Whether to hide headers in the output.",
      default: false,
    },
    hideFooters: {
      type: "boolean",
      title: "Hidefooters",
      description: "Whether to hide footers in the output.",
      default: false,
    },
  },
  type: "object",
  required: [
    "userId",
    "fileName",
    "originalFileName",
    "fileKey",
    "lang",
    "invalidateCache",
    "openAIAPIKey",
  ],
  title: "LegacyParseJobConfig",
  description: "Configuration for llamaparse job",
} as const;

export const LlamaParseParametersSchema = {
  properties: {
    webhook_configurations: {
      anyOf: [
        {
          items: {
            $ref: "#/components/schemas/WebhookConfiguration",
          },
          type: "array",
        },
        {
          type: "null",
        },
      ],
      title: "Webhook Configurations",
      description: "The outbound webhook configurations",
    },
    priority: {
      anyOf: [
        {
          type: "string",
          enum: ["low", "medium", "high", "critical"],
        },
        {
          type: "null",
        },
      ],
      title: "Priority",
      description:
        "The priority for the request. This field may be ignored or overwritten depending on the organization tier.",
    },
    languages: {
      items: {
        $ref: "#/components/schemas/ParserLanguages",
      },
      type: "array",
      minItems: 1,
      title: "Languages",
    },
    parsing_instruction: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Parsing Instruction",
      default: "",
    },
    disable_ocr: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Disable Ocr",
      default: false,
    },
    annotate_links: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Annotate Links",
      default: false,
    },
    adaptive_long_table: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Adaptive Long Table",
      default: false,
    },
    compact_markdown_table: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Compact Markdown Table",
      default: false,
    },
    disable_reconstruction: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Disable Reconstruction",
      default: false,
    },
    disable_image_extraction: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Disable Image Extraction",
      default: false,
    },
    invalidate_cache: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Invalidate Cache",
      default: false,
    },
    outlined_table_extraction: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Outlined Table Extraction",
      default: false,
    },
    merge_tables_across_pages_in_markdown: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Merge Tables Across Pages In Markdown",
      default: false,
    },
    output_pdf_of_document: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Output Pdf Of Document",
      default: false,
    },
    do_not_cache: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Do Not Cache",
      default: false,
    },
    fast_mode: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Fast Mode",
      default: false,
    },
    skip_diagonal_text: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Skip Diagonal Text",
      default: false,
    },
    preserve_layout_alignment_across_pages: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Preserve Layout Alignment Across Pages",
      default: false,
    },
    preserve_very_small_text: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Preserve Very Small Text",
      default: false,
    },
    gpt4o_mode: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Gpt4O Mode",
      default: false,
    },
    gpt4o_api_key: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Gpt4O Api Key",
    },
    do_not_unroll_columns: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Do Not Unroll Columns",
      default: false,
    },
    extract_layout: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Extract Layout",
      default: false,
    },
    high_res_ocr: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "High Res Ocr",
      default: false,
    },
    html_make_all_elements_visible: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Html Make All Elements Visible",
      default: false,
    },
    layout_aware: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Layout Aware",
      default: false,
    },
    specialized_chart_parsing_agentic: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Specialized Chart Parsing Agentic",
      default: false,
    },
    specialized_chart_parsing_plus: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Specialized Chart Parsing Plus",
      default: false,
    },
    specialized_chart_parsing_efficient: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Specialized Chart Parsing Efficient",
      default: false,
    },
    specialized_image_parsing: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Specialized Image Parsing",
      default: false,
    },
    precise_bounding_box: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Precise Bounding Box",
      default: false,
    },
    html_remove_navigation_elements: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Html Remove Navigation Elements",
      default: false,
    },
    html_remove_fixed_elements: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Html Remove Fixed Elements",
      default: false,
    },
    guess_xlsx_sheet_name: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Guess Xlsx Sheet Name",
      default: false,
    },
    page_separator: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Page Separator",
    },
    bounding_box: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Bounding Box",
    },
    bbox_top: {
      anyOf: [
        {
          type: "number",
        },
        {
          type: "null",
        },
      ],
      title: "Bbox Top",
    },
    bbox_right: {
      anyOf: [
        {
          type: "number",
        },
        {
          type: "null",
        },
      ],
      title: "Bbox Right",
    },
    bbox_bottom: {
      anyOf: [
        {
          type: "number",
        },
        {
          type: "null",
        },
      ],
      title: "Bbox Bottom",
    },
    bbox_left: {
      anyOf: [
        {
          type: "number",
        },
        {
          type: "null",
        },
      ],
      title: "Bbox Left",
    },
    target_pages: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Target Pages",
    },
    use_vendor_multimodal_model: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Use Vendor Multimodal Model",
      default: false,
    },
    vendor_multimodal_model_name: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Vendor Multimodal Model Name",
    },
    model: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Model",
    },
    vendor_multimodal_api_key: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Vendor Multimodal Api Key",
    },
    page_prefix: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Page Prefix",
    },
    page_suffix: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Page Suffix",
    },
    webhook_url: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Webhook Url",
    },
    preset: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Preset",
    },
    take_screenshot: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Take Screenshot",
      default: false,
    },
    is_formatting_instruction: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Is Formatting Instruction",
      default: true,
    },
    premium_mode: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Premium Mode",
      default: false,
    },
    continuous_mode: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Continuous Mode",
      default: false,
    },
    input_s3_path: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Input S3 Path",
    },
    input_s3_region: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Input S3 Region",
    },
    output_s3_path_prefix: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Output S3 Path Prefix",
    },
    output_s3_region: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Output S3 Region",
    },
    project_id: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Project Id",
    },
    azure_openai_deployment_name: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Azure Openai Deployment Name",
    },
    azure_openai_endpoint: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Azure Openai Endpoint",
    },
    azure_openai_api_version: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Azure Openai Api Version",
    },
    azure_openai_key: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Azure Openai Key",
    },
    input_url: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Input Url",
    },
    http_proxy: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Http Proxy",
    },
    auto_mode: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Auto Mode",
      default: false,
    },
    auto_mode_trigger_on_regexp_in_page: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Auto Mode Trigger On Regexp In Page",
    },
    auto_mode_trigger_on_text_in_page: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Auto Mode Trigger On Text In Page",
    },
    auto_mode_trigger_on_table_in_page: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Auto Mode Trigger On Table In Page",
      default: false,
    },
    auto_mode_trigger_on_image_in_page: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Auto Mode Trigger On Image In Page",
      default: false,
    },
    auto_mode_configuration_json: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Auto Mode Configuration Json",
    },
    structured_output: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Structured Output",
      default: false,
    },
    structured_output_json_schema: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Structured Output Json Schema",
    },
    structured_output_json_schema_name: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Structured Output Json Schema Name",
    },
    max_pages: {
      anyOf: [
        {
          type: "integer",
        },
        {
          type: "null",
        },
      ],
      title: "Max Pages",
    },
    max_pages_enforced: {
      anyOf: [
        {
          type: "integer",
        },
        {
          type: "null",
        },
      ],
      title: "Max Pages Enforced",
    },
    extract_charts: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Extract Charts",
      default: false,
    },
    formatting_instruction: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Formatting Instruction",
    },
    complemental_formatting_instruction: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Complemental Formatting Instruction",
    },
    content_guideline_instruction: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Content Guideline Instruction",
    },
    spreadsheet_extract_sub_tables: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Spreadsheet Extract Sub Tables",
      default: false,
    },
    spreadsheet_force_formula_computation: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Spreadsheet Force Formula Computation",
      default: false,
    },
    inline_images_in_markdown: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Inline Images In Markdown",
      default: false,
    },
    job_timeout_in_seconds: {
      anyOf: [
        {
          type: "number",
        },
        {
          type: "null",
        },
      ],
      title: "Job Timeout In Seconds",
    },
    job_timeout_extra_time_per_page_in_seconds: {
      anyOf: [
        {
          type: "number",
        },
        {
          type: "null",
        },
      ],
      title: "Job Timeout Extra Time Per Page In Seconds",
    },
    strict_mode_image_extraction: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Strict Mode Image Extraction",
      default: false,
    },
    strict_mode_image_ocr: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Strict Mode Image Ocr",
      default: false,
    },
    strict_mode_reconstruction: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Strict Mode Reconstruction",
      default: false,
    },
    strict_mode_buggy_font: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Strict Mode Buggy Font",
      default: false,
    },
    save_images: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Save Images",
      default: true,
    },
    hide_headers: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Hide Headers",
      default: false,
    },
    hide_footers: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Hide Footers",
      default: false,
    },
    page_header_prefix: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Page Header Prefix",
    },
    page_header_suffix: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Page Header Suffix",
    },
    page_footer_prefix: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Page Footer Prefix",
    },
    page_footer_suffix: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Page Footer Suffix",
    },
    ignore_document_elements_for_layout_detection: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Ignore Document Elements For Layout Detection",
      default: false,
    },
    output_tables_as_HTML: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Output Tables As Html",
      default: false,
    },
    internal_is_screenshot_job: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Internal Is Screenshot Job",
      default: false,
    },
    parse_mode: {
      anyOf: [
        {
          $ref: "#/components/schemas/ParsingMode",
        },
        {
          type: "null",
        },
      ],
    },
    system_prompt: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "System Prompt",
    },
    system_prompt_append: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "System Prompt Append",
    },
    user_prompt: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "User Prompt",
    },
    page_error_tolerance: {
      anyOf: [
        {
          type: "number",
        },
        {
          type: "null",
        },
      ],
      title: "Page Error Tolerance",
      default: 0.05,
    },
    replace_failed_page_mode: {
      anyOf: [
        {
          $ref: "#/components/schemas/FailPageMode",
        },
        {
          type: "null",
        },
      ],
      default: "raw_text",
    },
    replace_failed_page_with_error_message_prefix: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Replace Failed Page With Error Message Prefix",
    },
    replace_failed_page_with_error_message_suffix: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Replace Failed Page With Error Message Suffix",
    },
    markdown_table_multiline_header_separator: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Markdown Table Multiline Header Separator",
    },
  },
  type: "object",
  title: "LlamaParseParameters",
  description:
    "Settings that can be configured for how to use LlamaParse to parse files within a LlamaCloud pipeline.",
} as const;

export const LlamaParseSupportedFileExtensionsSchema = {
  type: "string",
  enum: [
    ".pdf",
    ".doc",
    ".docx",
    ".docm",
    ".dot",
    ".dotx",
    ".dotm",
    ".rtf",
    ".wps",
    ".wpd",
    ".sxw",
    ".stw",
    ".sxg",
    ".pages",
    ".mw",
    ".mcw",
    ".uot",
    ".uof",
    ".uos",
    ".uop",
    ".ppt",
    ".pptx",
    ".pot",
    ".pptm",
    ".potx",
    ".potm",
    ".key",
    ".odp",
    ".odg",
    ".otp",
    ".fopd",
    ".sxi",
    ".sti",
    ".epub",
    ".jpg",
    ".jpeg",
    ".png",
    ".gif",
    ".bmp",
    ".svg",
    ".tiff",
    ".webp",
    ".html",
    ".htm",
    ".xls",
    ".xlsx",
    ".xlsm",
    ".xlsb",
    ".xlw",
    ".csv",
    ".dif",
    ".sylk",
    ".slk",
    ".prn",
    ".numbers",
    ".et",
    ".ods",
    ".fods",
    ".uos1",
    ".uos2",
    ".dbf",
    ".wk1",
    ".wk2",
    ".wk3",
    ".wk4",
    ".wks",
    ".wq1",
    ".wq2",
    ".wb1",
    ".wb2",
    ".wb3",
    ".qpw",
    ".xlr",
    ".eth",
    ".tsv",
  ],
  title: "LlamaParseSupportedFileExtensions",
} as const;

export const LoadFilesJobConfigSchema = {
  properties: {
    type: {
      type: "string",
      const: "load_files",
      title: "Type",
      default: "load_files",
    },
    file_ids: {
      anyOf: [
        {
          items: {
            type: "string",
            format: "uuid",
          },
          type: "array",
        },
        {
          type: "null",
        },
      ],
      title: "File Ids",
      description: "The names of the files this execution should run against.",
    },
  },
  type: "object",
  title: "LoadFilesJobConfig",
  description: "Schema for the parameters of a load files job.",
} as const;

export const ManagedIngestionStatusSchema = {
  type: "string",
  enum: [
    "NOT_STARTED",
    "IN_PROGRESS",
    "SUCCESS",
    "ERROR",
    "PARTIAL_SUCCESS",
    "CANCELLED",
  ],
  title: "ManagedIngestionStatus",
  description: "Status of managed ingestion with partial Updates.",
} as const;

export const ManagedIngestionStatusResponseSchema = {
  properties: {
    job_id: {
      anyOf: [
        {
          type: "string",
          format: "uuid",
        },
        {
          type: "null",
        },
      ],
      title: "Job Id",
      description: "ID of the latest job.",
    },
    deployment_date: {
      anyOf: [
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Deployment Date",
      description: "Date of the deployment.",
    },
    status: {
      $ref: "#/components/schemas/ManagedIngestionStatus",
      description: "Status of the ingestion.",
    },
    error: {
      anyOf: [
        {
          items: {
            $ref: "#/components/schemas/IngestionErrorResponse",
          },
          type: "array",
        },
        {
          type: "null",
        },
      ],
      title: "Error",
      description: "List of errors that occurred during ingestion.",
    },
    effective_at: {
      anyOf: [
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Effective At",
      description: "When the status is effective",
    },
  },
  type: "object",
  required: ["status"],
  title: "ManagedIngestionStatusResponse",
} as const;

export const ManagedOpenAIEmbeddingSchema = {
  properties: {
    model_name: {
      type: "string",
      const: "openai-text-embedding-3-small",
      title: "Model Name",
      description: "The name of the OpenAI embedding model.",
      default: "openai-text-embedding-3-small",
    },
    embed_batch_size: {
      type: "integer",
      maximum: 2048,
      exclusiveMinimum: 0,
      title: "Embed Batch Size",
      description: "The batch size for embedding calls.",
      default: 10,
    },
    num_workers: {
      anyOf: [
        {
          type: "integer",
        },
        {
          type: "null",
        },
      ],
      title: "Num Workers",
      description: "The number of workers to use for async embedding calls.",
    },
    class_name: {
      type: "string",
      title: "Class Name",
      default: "ManagedOpenAIEmbedding",
    },
  },
  type: "object",
  title: "ManagedOpenAIEmbedding",
} as const;

export const ManagedOpenAIEmbeddingConfigSchema = {
  properties: {
    type: {
      type: "string",
      const: "MANAGED_OPENAI_EMBEDDING",
      title: "Type",
      description: "Type of the embedding model.",
      default: "MANAGED_OPENAI_EMBEDDING",
    },
    component: {
      $ref: "#/components/schemas/ManagedOpenAIEmbedding",
      description: "Configuration for the Managed OpenAI embedding model.",
    },
  },
  type: "object",
  title: "ManagedOpenAIEmbeddingConfig",
} as const;

export const MessageAnnotationSchema = {
  properties: {
    type: {
      type: "string",
      title: "Type",
    },
    data: {
      type: "string",
      contentMediaType: "application/json",
      contentSchema: {},
      title: "Data",
    },
    class_name: {
      type: "string",
      title: "Class Name",
      default: "base_component",
    },
  },
  type: "object",
  required: ["type", "data"],
  title: "MessageAnnotation",
} as const;

export const MessageRoleSchema = {
  type: "string",
  enum: [
    "system",
    "developer",
    "user",
    "assistant",
    "function",
    "tool",
    "chatbot",
    "model",
  ],
  title: "MessageRole",
  description: "Message role.",
} as const;

export const MetadataFilterSchema = {
  properties: {
    key: {
      type: "string",
      title: "Key",
    },
    value: {
      anyOf: [
        {
          type: "integer",
        },
        {
          type: "number",
        },
        {
          type: "string",
        },
        {
          items: {
            type: "string",
          },
          type: "array",
        },
        {
          items: {
            type: "number",
          },
          type: "array",
        },
        {
          items: {
            type: "integer",
          },
          type: "array",
        },
        {
          type: "null",
        },
      ],
      title: "Value",
    },
    operator: {
      $ref: "#/components/schemas/FilterOperator",
      default: "==",
    },
  },
  type: "object",
  required: ["key", "value"],
  title: "MetadataFilter",
  description: `Comprehensive metadata filter for vector stores to support more operators.

Value uses Strict types, as int, float and str are compatible types and were all
converted to string before.

See: https://docs.pydantic.dev/latest/usage/types/#strict-types`,
} as const;

export const MetadataFiltersSchema = {
  properties: {
    filters: {
      items: {
        anyOf: [
          {
            $ref: "#/components/schemas/MetadataFilter",
          },
          {
            $ref: "#/components/schemas/MetadataFilters",
          },
        ],
      },
      type: "array",
      title: "Filters",
    },
    condition: {
      anyOf: [
        {
          $ref: "#/components/schemas/FilterCondition",
        },
        {
          type: "null",
        },
      ],
      default: "and",
    },
  },
  type: "object",
  required: ["filters"],
  title: "MetadataFilters",
  description: "Metadata filters for vector stores.",
} as const;

export const MetronomeDashboardResponseSchema = {
  properties: {
    url: {
      type: "string",
      title: "Url",
    },
  },
  type: "object",
  required: ["url"],
  title: "MetronomeDashboardResponse",
} as const;

export const MetronomeDashboardTypeSchema = {
  type: "string",
  enum: ["invoices", "usage"],
  title: "MetronomeDashboardType",
} as const;

export const NodeRelationshipSchema = {
  type: "string",
  enum: ["1", "2", "3", "4", "5"],
  title: "NodeRelationship",
  description: `Node relationships used in \`BaseNode\` class.

Attributes:
    SOURCE: The node is the source document.
    PREVIOUS: The node is the previous node in the document.
    NEXT: The node is the next node in the document.
    PARENT: The node is the parent node in the document.
    CHILD: The node is a child node in the document.`,
} as const;

export const NoneChunkingConfigSchema = {
  properties: {
    mode: {
      type: "string",
      const: "none",
      title: "Mode",
      default: "none",
    },
  },
  type: "object",
  title: "NoneChunkingConfig",
} as const;

export const NoneSegmentationConfigSchema = {
  properties: {
    mode: {
      type: "string",
      const: "none",
      title: "Mode",
      default: "none",
    },
  },
  type: "object",
  title: "NoneSegmentationConfig",
} as const;

export const ObjectTypeSchema = {
  type: "string",
  enum: ["1", "2", "3", "4", "5"],
  title: "ObjectType",
} as const;

export const OpenAIEmbeddingSchema = {
  properties: {
    model_name: {
      type: "string",
      title: "Model Name",
      description: "The name of the OpenAI embedding model.",
      default: "text-embedding-ada-002",
    },
    embed_batch_size: {
      type: "integer",
      maximum: 2048,
      exclusiveMinimum: 0,
      title: "Embed Batch Size",
      description: "The batch size for embedding calls.",
      default: 10,
    },
    num_workers: {
      anyOf: [
        {
          type: "integer",
        },
        {
          type: "null",
        },
      ],
      title: "Num Workers",
      description: "The number of workers to use for async embedding calls.",
    },
    additional_kwargs: {
      additionalProperties: true,
      type: "object",
      title: "Additional Kwargs",
      description: "Additional kwargs for the OpenAI API.",
    },
    api_key: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Api Key",
      description: "The OpenAI API key.",
    },
    api_base: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Api Base",
      description: "The base URL for OpenAI API.",
      default: "https://api.openai.com/v1",
    },
    api_version: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Api Version",
      description: "The version for OpenAI API.",
      default: "",
    },
    max_retries: {
      type: "integer",
      title: "Max Retries",
      description: "Maximum number of retries.",
      default: 10,
      gte: 0,
    },
    timeout: {
      type: "number",
      title: "Timeout",
      description: "Timeout for each request.",
      default: 60,
      gte: 0,
    },
    default_headers: {
      anyOf: [
        {
          additionalProperties: {
            type: "string",
          },
          type: "object",
        },
        {
          type: "null",
        },
      ],
      title: "Default Headers",
      description: "The default headers for API requests.",
    },
    reuse_client: {
      type: "boolean",
      title: "Reuse Client",
      description:
        "Reuse the OpenAI client between requests. When doing anything with large volumes of async API calls, setting this to false can improve stability.",
      default: true,
    },
    dimensions: {
      anyOf: [
        {
          type: "integer",
        },
        {
          type: "null",
        },
      ],
      title: "Dimensions",
      description:
        "The number of dimensions on the output embedding vectors. Works only with v3 embedding models.",
    },
    class_name: {
      type: "string",
      title: "Class Name",
      default: "OpenAIEmbedding",
    },
  },
  type: "object",
  title: "OpenAIEmbedding",
} as const;

export const OpenAIEmbeddingConfigSchema = {
  properties: {
    type: {
      type: "string",
      const: "OPENAI_EMBEDDING",
      title: "Type",
      description: "Type of the embedding model.",
      default: "OPENAI_EMBEDDING",
    },
    component: {
      $ref: "#/components/schemas/OpenAIEmbedding",
      description: "Configuration for the OpenAI embedding model.",
    },
  },
  type: "object",
  title: "OpenAIEmbeddingConfig",
} as const;

export const OrganizationSchema = {
  properties: {
    id: {
      type: "string",
      format: "uuid",
      title: "Id",
      description: "Unique identifier",
    },
    created_at: {
      anyOf: [
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Created At",
      description: "Creation datetime",
    },
    updated_at: {
      anyOf: [
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Updated At",
      description: "Update datetime",
    },
    name: {
      type: "string",
      maxLength: 3000,
      minLength: 1,
      title: "Name",
      description: "A name for the organization.",
    },
    stripe_customer_id: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Stripe Customer Id",
      description: "The Stripe customer ID for the organization.",
    },
    parse_plan_level: {
      $ref: "#/components/schemas/ParsePlanLevel",
      description: "Whether the organization is a Parse Premium customer.",
      default: "DEFAULT",
    },
    feature_flags: {
      anyOf: [
        {
          additionalProperties: true,
          type: "object",
        },
        {
          type: "null",
        },
      ],
      title: "Feature Flags",
      description: "Feature flags for the organization.",
    },
  },
  type: "object",
  required: ["id", "name"],
  title: "Organization",
  description: "Schema for an organization.",
} as const;

export const OrganizationCreateSchema = {
  properties: {
    name: {
      type: "string",
      maxLength: 3000,
      minLength: 1,
      title: "Name",
      description: "A name for the organization.",
    },
  },
  type: "object",
  required: ["name"],
  title: "OrganizationCreate",
  description: "Schema for creating an organization.",
} as const;

export const OrganizationUpdateSchema = {
  properties: {
    name: {
      type: "string",
      maxLength: 3000,
      minLength: 1,
      title: "Name",
      description: "A name for the organization.",
    },
    feature_flags: {
      anyOf: [
        {
          additionalProperties: true,
          type: "object",
        },
        {
          type: "null",
        },
      ],
      title: "Feature Flags",
      description: "Feature flags for the organization.",
    },
  },
  type: "object",
  required: ["name"],
  title: "OrganizationUpdate",
  description: "Schema for updating an organization.",
} as const;

export const PGVectorDistanceMethodSchema = {
  type: "string",
  enum: ["l2", "ip", "cosine", "l1", "hamming", "jaccard"],
  title: "PGVectorDistanceMethod",
  description: `Distance methods for PGVector.
Docs:
https://github.com/pgvector/pgvector?tab=readme-ov-file#query-options`,
} as const;

export const PGVectorHNSWSettingsSchema = {
  properties: {
    ef_construction: {
      type: "integer",
      minimum: 1,
      title: "Ef Construction",
      description: "The number of edges to use during the construction phase.",
      default: 64,
    },
    ef_search: {
      type: "integer",
      minimum: 1,
      title: "Ef Search",
      description: "The number of edges to use during the search phase.",
      default: 40,
    },
    m: {
      type: "integer",
      minimum: 1,
      title: "M",
      description:
        "The number of bi-directional links created for each new element.",
      default: 16,
    },
    vector_type: {
      $ref: "#/components/schemas/PGVectorVectorType",
      description: "The type of vector to use.",
      default: "vector",
    },
    distance_method: {
      $ref: "#/components/schemas/PGVectorDistanceMethod",
      description: "The distance method to use.",
      default: "cosine",
    },
  },
  type: "object",
  title: "PGVectorHNSWSettings",
  description: "HNSW settings for PGVector.",
} as const;

export const PGVectorVectorTypeSchema = {
  type: "string",
  enum: ["vector", "half_vec", "bit", "sparse_vec"],
  title: "PGVectorVectorType",
  description: `Vector storage formats for PGVector.
Docs:
https://github.com/pgvector/pgvector?tab=readme-ov-file#query-options`,
} as const;

export const PageFigureMetadataSchema = {
  properties: {
    figure_name: {
      type: "string",
      title: "Figure Name",
      description: "The name of the figure",
    },
    file_id: {
      type: "string",
      format: "uuid",
      title: "File Id",
      description: "The ID of the file that the figure was taken from",
    },
    page_index: {
      type: "integer",
      minimum: 0,
      title: "Page Index",
      description:
        "The index of the page for which the figure is taken (0-indexed)",
    },
    figure_size: {
      type: "integer",
      minimum: 0,
      title: "Figure Size",
      description: "The size of the figure in bytes",
    },
    is_likely_noise: {
      type: "boolean",
      title: "Is Likely Noise",
      description: "Whether the figure is likely to be noise",
      default: false,
    },
    confidence: {
      type: "number",
      maximum: 1,
      minimum: 0,
      title: "Confidence",
      description: "The confidence of the figure",
    },
    metadata: {
      anyOf: [
        {
          additionalProperties: true,
          type: "object",
        },
        {
          type: "null",
        },
      ],
      title: "Metadata",
      description: "Metadata for the figure",
    },
  },
  type: "object",
  required: [
    "figure_name",
    "file_id",
    "page_index",
    "figure_size",
    "confidence",
  ],
  title: "PageFigureMetadata",
} as const;

export const PageFigureNodeWithScoreSchema = {
  properties: {
    node: {
      $ref: "#/components/schemas/PageFigureMetadata",
    },
    score: {
      type: "number",
      title: "Score",
      description: "The score of the figure node",
    },
    class_name: {
      type: "string",
      title: "Class Name",
      default: "PageFigureNodeWithScore",
    },
  },
  type: "object",
  required: ["node", "score"],
  title: "PageFigureNodeWithScore",
  description: "Page figure metadata with score",
} as const;

export const PageScreenshotMetadataSchema = {
  properties: {
    page_index: {
      type: "integer",
      minimum: 0,
      title: "Page Index",
      description:
        "The index of the page for which the screenshot is taken (0-indexed)",
    },
    file_id: {
      type: "string",
      format: "uuid",
      title: "File Id",
      description: "The ID of the file that the page screenshot was taken from",
    },
    image_size: {
      type: "integer",
      minimum: 0,
      title: "Image Size",
      description: "The size of the image in bytes",
    },
    metadata: {
      anyOf: [
        {
          additionalProperties: true,
          type: "object",
        },
        {
          type: "null",
        },
      ],
      title: "Metadata",
      description: "Metadata for the screenshot",
    },
  },
  type: "object",
  required: ["page_index", "file_id", "image_size"],
  title: "PageScreenshotMetadata",
} as const;

export const PageScreenshotNodeWithScoreSchema = {
  properties: {
    node: {
      $ref: "#/components/schemas/PageScreenshotMetadata",
    },
    score: {
      type: "number",
      title: "Score",
      description: "The score of the screenshot node",
    },
    class_name: {
      type: "string",
      title: "Class Name",
      default: "NodeWithScore",
    },
  },
  type: "object",
  required: ["node", "score"],
  title: "PageScreenshotNodeWithScore",
  description: "Page screenshot metadata with score",
} as const;

export const PageSegmentationConfigSchema = {
  properties: {
    mode: {
      type: "string",
      const: "page",
      title: "Mode",
      default: "page",
    },
    page_separator: {
      type: "string",
      title: "Page Separator",
      default: `
---
`,
    },
  },
  type: "object",
  title: "PageSegmentationConfig",
} as const;

export const PaginatedExtractRunsResponseSchema = {
  properties: {
    items: {
      items: {
        $ref: "#/components/schemas/ExtractRun",
      },
      type: "array",
      title: "Items",
      description: "The list of extraction runs",
    },
    total: {
      type: "integer",
      title: "Total",
      description: "The total number of extraction runs",
    },
    skip: {
      type: "integer",
      title: "Skip",
      description: "The number of extraction runs skipped",
    },
    limit: {
      type: "integer",
      title: "Limit",
      description: "The maximum number of extraction runs returned",
    },
  },
  type: "object",
  required: ["items", "total", "skip", "limit"],
  title: "PaginatedExtractRunsResponse",
  description: "Schema for paginated extraction runs response.",
} as const;

export const PaginatedJobsHistoryWithMetricsSchema = {
  properties: {
    jobs: {
      items: {
        $ref: "#/components/schemas/JobRecordWithUsageMetrics",
      },
      type: "array",
      title: "Jobs",
    },
    total_count: {
      type: "integer",
      title: "Total Count",
    },
    limit: {
      type: "integer",
      title: "Limit",
    },
    offset: {
      type: "integer",
      title: "Offset",
    },
  },
  type: "object",
  required: ["jobs", "total_count", "limit", "offset"],
  title: "PaginatedJobsHistoryWithMetrics",
} as const;

export const PaginatedListCloudDocumentsResponseSchema = {
  properties: {
    documents: {
      items: {
        $ref: "#/components/schemas/CloudDocument",
      },
      type: "array",
      title: "Documents",
      description: "The documents to list",
    },
    limit: {
      type: "integer",
      title: "Limit",
      description: "The limit of the documents",
    },
    offset: {
      type: "integer",
      title: "Offset",
      description: "The offset of the documents",
    },
    total_count: {
      type: "integer",
      title: "Total Count",
      description: "The total number of documents",
    },
  },
  type: "object",
  required: ["documents", "limit", "offset", "total_count"],
  title: "PaginatedListCloudDocumentsResponse",
} as const;

export const PaginatedListPipelineFilesResponseSchema = {
  properties: {
    files: {
      items: {
        $ref: "#/components/schemas/PipelineFile",
      },
      type: "array",
      title: "Files",
      description: "The files to list",
    },
    limit: {
      type: "integer",
      title: "Limit",
      description: "The limit of the files",
    },
    offset: {
      type: "integer",
      title: "Offset",
      description: "The offset of the files",
    },
    total_count: {
      type: "integer",
      title: "Total Count",
      description: "The total number of files",
    },
  },
  type: "object",
  required: ["files", "limit", "offset", "total_count"],
  title: "PaginatedListPipelineFilesResponse",
} as const;

export const PaginatedResponse_AgentData_Schema = {
  properties: {
    items: {
      items: {
        $ref: "#/components/schemas/AgentData",
      },
      type: "array",
      title: "Items",
      description: "The list of items.",
    },
    next_page_token: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Next Page Token",
      description:
        "A token, which can be sent as page_token to retrieve the next page. If this field is omitted, there are no subsequent pages.",
    },
    total_size: {
      anyOf: [
        {
          type: "integer",
        },
        {
          type: "null",
        },
      ],
      title: "Total Size",
      description:
        "The total number of items available. This is only populated when specifically requested. The value may be an estimate and can be used for display purposes only.",
    },
  },
  type: "object",
  required: ["items"],
  title: "PaginatedResponse[AgentData]",
} as const;

export const PaginatedResponse_AggregateGroup_Schema = {
  properties: {
    items: {
      items: {
        $ref: "#/components/schemas/AggregateGroup",
      },
      type: "array",
      title: "Items",
      description: "The list of items.",
    },
    next_page_token: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Next Page Token",
      description:
        "A token, which can be sent as page_token to retrieve the next page. If this field is omitted, there are no subsequent pages.",
    },
    total_size: {
      anyOf: [
        {
          type: "integer",
        },
        {
          type: "null",
        },
      ],
      title: "Total Size",
      description:
        "The total number of items available. This is only populated when specifically requested. The value may be an estimate and can be used for display purposes only.",
    },
  },
  type: "object",
  required: ["items"],
  title: "PaginatedResponse[AggregateGroup]",
} as const;

export const PaginatedResponse_ClassifyJob_Schema = {
  properties: {
    items: {
      items: {
        $ref: "#/components/schemas/ClassifyJob",
      },
      type: "array",
      title: "Items",
      description: "The list of items.",
    },
    next_page_token: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Next Page Token",
      description:
        "A token, which can be sent as page_token to retrieve the next page. If this field is omitted, there are no subsequent pages.",
    },
    total_size: {
      anyOf: [
        {
          type: "integer",
        },
        {
          type: "null",
        },
      ],
      title: "Total Size",
      description:
        "The total number of items available. This is only populated when specifically requested. The value may be an estimate and can be used for display purposes only.",
    },
  },
  type: "object",
  required: ["items"],
  title: "PaginatedResponse[ClassifyJob]",
} as const;

export const PaginatedResponse_QuotaConfiguration_Schema = {
  properties: {
    total: {
      type: "integer",
      title: "Total",
    },
    page: {
      type: "integer",
      title: "Page",
    },
    size: {
      type: "integer",
      title: "Size",
    },
    pages: {
      type: "integer",
      title: "Pages",
    },
    items: {
      items: {
        $ref: "#/components/schemas/QuotaConfiguration",
      },
      type: "array",
      title: "Items",
    },
  },
  type: "object",
  required: ["total", "page", "size", "pages", "items"],
  title: "PaginatedResponse[QuotaConfiguration]",
} as const;

export const PaginatedResponse_SpreadsheetJob_Schema = {
  properties: {
    items: {
      items: {
        $ref: "#/components/schemas/SpreadsheetJob",
      },
      type: "array",
      title: "Items",
      description: "The list of items.",
    },
    next_page_token: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Next Page Token",
      description:
        "A token, which can be sent as page_token to retrieve the next page. If this field is omitted, there are no subsequent pages.",
    },
    total_size: {
      anyOf: [
        {
          type: "integer",
        },
        {
          type: "null",
        },
      ],
      title: "Total Size",
      description:
        "The total number of items available. This is only populated when specifically requested. The value may be an estimate and can be used for display purposes only.",
    },
  },
  type: "object",
  required: ["items"],
  title: "PaginatedResponse[SpreadsheetJob]",
} as const;

export const ParseConfigurationSchema = {
  properties: {
    id: {
      type: "string",
      title: "Id",
      description: "Unique identifier for the parse configuration",
    },
    name: {
      type: "string",
      title: "Name",
      description: "Name of the parse configuration",
    },
    source_type: {
      type: "string",
      title: "Source Type",
      description: "Type of the source (e.g., 'project')",
    },
    source_id: {
      type: "string",
      title: "Source Id",
      description: "ID of the source",
    },
    creator: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Creator",
      description: "Creator of the configuration",
    },
    version: {
      type: "string",
      title: "Version",
      description: "Version of the configuration",
    },
    parameters: {
      $ref: "#/components/schemas/LlamaParseParameters",
      description: "LlamaParseParameters configuration",
    },
    created_at: {
      type: "string",
      format: "date-time",
      title: "Created At",
      description: "Creation timestamp",
    },
    updated_at: {
      type: "string",
      format: "date-time",
      title: "Updated At",
      description: "Last update timestamp",
    },
  },
  type: "object",
  required: [
    "id",
    "name",
    "source_type",
    "source_id",
    "version",
    "parameters",
    "created_at",
    "updated_at",
  ],
  title: "ParseConfiguration",
  description: "Parse configuration schema.",
} as const;

export const ParseConfigurationCreateSchema = {
  properties: {
    name: {
      type: "string",
      title: "Name",
      description: "Name of the parse configuration",
    },
    source_type: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Source Type",
      description: "Type of the source (e.g., 'project')",
    },
    source_id: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Source Id",
      description: "ID of the source",
    },
    creator: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Creator",
      description: "Creator of the configuration",
    },
    version: {
      type: "string",
      title: "Version",
      description: "Version of the configuration",
    },
    parameters: {
      $ref: "#/components/schemas/LlamaParseParameters",
      description: "LlamaParseParameters configuration",
    },
  },
  type: "object",
  required: ["name", "version", "parameters"],
  title: "ParseConfigurationCreate",
  description: "Schema for creating a new parse configuration (API boundary).",
} as const;

export const ParseConfigurationFilterSchema = {
  properties: {
    name: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Name",
      description: "Filter by name",
    },
    source_type: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Source Type",
      description: "Filter by source type",
    },
    source_id: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Source Id",
      description: "Filter by source ID",
    },
    creator: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Creator",
      description: "Filter by creator",
    },
    version: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Version",
      description: "Filter by version",
    },
    parse_config_ids: {
      anyOf: [
        {
          items: {
            type: "string",
          },
          type: "array",
        },
        {
          type: "null",
        },
      ],
      title: "Parse Config Ids",
      description: "Filter by specific parse configuration IDs",
    },
  },
  type: "object",
  title: "ParseConfigurationFilter",
  description: "Filter parameters for parse configuration queries.",
} as const;

export const ParseConfigurationQueryRequestSchema = {
  properties: {
    page_size: {
      anyOf: [
        {
          type: "integer",
        },
        {
          type: "null",
        },
      ],
      title: "Page Size",
      description:
        "The maximum number of items to return. The service may return fewer than this value. If unspecified, a default page size will be used. The maximum value is typically 1000; values above this will be coerced to the maximum.",
    },
    page_token: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Page Token",
      description:
        "A page token, received from a previous list call. Provide this to retrieve the subsequent page.",
    },
    filter: {
      anyOf: [
        {
          $ref: "#/components/schemas/ParseConfigurationFilter",
        },
        {
          type: "null",
        },
      ],
      description:
        "A filter object or expression that filters resources listed in the response.",
    },
    order_by: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Order By",
      description:
        "A comma-separated list of fields to order by, sorted in ascending order. Use 'field_name desc' to specify descending order.",
    },
  },
  type: "object",
  title: "ParseConfigurationQueryRequest",
  description:
    "Request schema for querying parse configurations with pagination and filtering.",
} as const;

export const ParseConfigurationQueryResponseSchema = {
  properties: {
    items: {
      items: {
        $ref: "#/components/schemas/ParseConfiguration",
      },
      type: "array",
      title: "Items",
      description: "The list of items.",
    },
    next_page_token: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Next Page Token",
      description:
        "A token, which can be sent as page_token to retrieve the next page. If this field is omitted, there are no subsequent pages.",
    },
    total_size: {
      anyOf: [
        {
          type: "integer",
        },
        {
          type: "null",
        },
      ],
      title: "Total Size",
      description:
        "The total number of items available. This is only populated when specifically requested. The value may be an estimate and can be used for display purposes only.",
    },
  },
  type: "object",
  required: ["items"],
  title: "ParseConfigurationQueryResponse",
  description: "Response schema for paginated parse configuration queries.",
} as const;

export const ParseConfigurationUpdateSchema = {
  properties: {
    parameters: {
      anyOf: [
        {
          $ref: "#/components/schemas/LlamaParseParameters",
        },
        {
          type: "null",
        },
      ],
      description: "Updated LlamaParseParameters configuration",
    },
  },
  type: "object",
  title: "ParseConfigurationUpdate",
  description: "Schema for updating an existing parse configuration.",
} as const;

export const ParseJobConfigSchema = {
  properties: {
    webhook_configurations: {
      anyOf: [
        {
          items: {
            $ref: "#/components/schemas/WebhookConfiguration",
          },
          type: "array",
        },
        {
          type: "null",
        },
      ],
      title: "Webhook Configurations",
      description: "The outbound webhook configurations",
    },
    priority: {
      anyOf: [
        {
          type: "string",
          enum: ["low", "medium", "high", "critical"],
        },
        {
          type: "null",
        },
      ],
      title: "Priority",
      description:
        "The priority for the request. This field may be ignored or overwritten depending on the organization tier.",
    },
    custom_metadata: {
      anyOf: [
        {
          additionalProperties: true,
          type: "object",
        },
        {
          type: "null",
        },
      ],
      title: "Custom Metadata",
      description: "The custom metadata to attach to the documents.",
    },
    resource_info: {
      anyOf: [
        {
          additionalProperties: true,
          type: "object",
        },
        {
          type: "null",
        },
      ],
      title: "Resource Info",
      description: "The resource info about the file",
    },
    languages: {
      items: {
        $ref: "#/components/schemas/ParserLanguages",
      },
      type: "array",
      minItems: 1,
      title: "Languages",
    },
    parsing_instruction: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Parsing Instruction",
      default: "",
    },
    disable_ocr: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Disable Ocr",
      default: false,
    },
    annotate_links: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Annotate Links",
      default: false,
    },
    adaptive_long_table: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Adaptive Long Table",
      default: false,
    },
    compact_markdown_table: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Compact Markdown Table",
      default: false,
    },
    disable_reconstruction: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Disable Reconstruction",
      default: false,
    },
    disable_image_extraction: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Disable Image Extraction",
      default: false,
    },
    invalidate_cache: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Invalidate Cache",
      default: false,
    },
    outlined_table_extraction: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Outlined Table Extraction",
      default: false,
    },
    merge_tables_across_pages_in_markdown: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Merge Tables Across Pages In Markdown",
      default: false,
    },
    output_pdf_of_document: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Output Pdf Of Document",
      default: false,
    },
    do_not_cache: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Do Not Cache",
      default: false,
    },
    fast_mode: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Fast Mode",
      default: false,
    },
    skip_diagonal_text: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Skip Diagonal Text",
      default: false,
    },
    preserve_layout_alignment_across_pages: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Preserve Layout Alignment Across Pages",
      default: false,
    },
    preserve_very_small_text: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Preserve Very Small Text",
      default: false,
    },
    gpt4o_mode: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Gpt4O Mode",
      default: false,
    },
    gpt4o_api_key: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Gpt4O Api Key",
    },
    do_not_unroll_columns: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Do Not Unroll Columns",
      default: false,
    },
    extract_layout: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Extract Layout",
      default: false,
    },
    high_res_ocr: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "High Res Ocr",
      default: false,
    },
    html_make_all_elements_visible: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Html Make All Elements Visible",
      default: false,
    },
    layout_aware: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Layout Aware",
      default: false,
    },
    specialized_chart_parsing_agentic: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Specialized Chart Parsing Agentic",
      default: false,
    },
    specialized_chart_parsing_plus: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Specialized Chart Parsing Plus",
      default: false,
    },
    specialized_chart_parsing_efficient: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Specialized Chart Parsing Efficient",
      default: false,
    },
    specialized_image_parsing: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Specialized Image Parsing",
      default: false,
    },
    precise_bounding_box: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Precise Bounding Box",
      default: false,
    },
    html_remove_navigation_elements: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Html Remove Navigation Elements",
      default: false,
    },
    html_remove_fixed_elements: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Html Remove Fixed Elements",
      default: false,
    },
    guess_xlsx_sheet_name: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Guess Xlsx Sheet Name",
      default: false,
    },
    page_separator: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Page Separator",
    },
    bounding_box: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Bounding Box",
    },
    bbox_top: {
      anyOf: [
        {
          type: "number",
        },
        {
          type: "null",
        },
      ],
      title: "Bbox Top",
    },
    bbox_right: {
      anyOf: [
        {
          type: "number",
        },
        {
          type: "null",
        },
      ],
      title: "Bbox Right",
    },
    bbox_bottom: {
      anyOf: [
        {
          type: "number",
        },
        {
          type: "null",
        },
      ],
      title: "Bbox Bottom",
    },
    bbox_left: {
      anyOf: [
        {
          type: "number",
        },
        {
          type: "null",
        },
      ],
      title: "Bbox Left",
    },
    target_pages: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Target Pages",
    },
    use_vendor_multimodal_model: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Use Vendor Multimodal Model",
      default: false,
    },
    vendor_multimodal_model_name: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Vendor Multimodal Model Name",
    },
    model: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Model",
    },
    vendor_multimodal_api_key: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Vendor Multimodal Api Key",
    },
    page_prefix: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Page Prefix",
    },
    page_suffix: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Page Suffix",
    },
    webhook_url: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Webhook Url",
    },
    preset: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Preset",
    },
    take_screenshot: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Take Screenshot",
      default: false,
    },
    is_formatting_instruction: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Is Formatting Instruction",
      default: true,
    },
    premium_mode: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Premium Mode",
      default: false,
    },
    continuous_mode: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Continuous Mode",
      default: false,
    },
    input_s3_path: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Input S3 Path",
      description:
        "If specified, llamaParse will take the specified file. should be a valid s3:// url",
    },
    input_s3_region: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Input S3 Region",
      description: "The region for the input S3 bucket.",
    },
    output_s3_path_prefix: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Output S3 Path Prefix",
      description:
        "If specified, llamaParse will save the output to the specified path. All output file will use this 'prefix' should be a valid s3:// url",
    },
    output_s3_region: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Output S3 Region",
      description: "The region for the output S3 bucket.",
    },
    project_id: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Project Id",
    },
    azure_openai_deployment_name: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Azure Openai Deployment Name",
    },
    azure_openai_endpoint: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Azure Openai Endpoint",
    },
    azure_openai_api_version: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Azure Openai Api Version",
    },
    azure_openai_key: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Azure Openai Key",
    },
    input_url: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Input Url",
    },
    http_proxy: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Http Proxy",
    },
    auto_mode: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Auto Mode",
      default: false,
    },
    auto_mode_trigger_on_regexp_in_page: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Auto Mode Trigger On Regexp In Page",
    },
    auto_mode_trigger_on_text_in_page: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Auto Mode Trigger On Text In Page",
    },
    auto_mode_trigger_on_table_in_page: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Auto Mode Trigger On Table In Page",
      default: false,
    },
    auto_mode_trigger_on_image_in_page: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Auto Mode Trigger On Image In Page",
      default: false,
    },
    auto_mode_configuration_json: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Auto Mode Configuration Json",
    },
    structured_output: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Structured Output",
      default: false,
    },
    structured_output_json_schema: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Structured Output Json Schema",
    },
    structured_output_json_schema_name: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Structured Output Json Schema Name",
    },
    max_pages: {
      anyOf: [
        {
          type: "integer",
        },
        {
          type: "null",
        },
      ],
      title: "Max Pages",
    },
    max_pages_enforced: {
      anyOf: [
        {
          type: "integer",
        },
        {
          type: "null",
        },
      ],
      title: "Max Pages Enforced",
    },
    extract_charts: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Extract Charts",
      default: false,
    },
    formatting_instruction: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Formatting Instruction",
    },
    complemental_formatting_instruction: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Complemental Formatting Instruction",
    },
    content_guideline_instruction: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Content Guideline Instruction",
    },
    spreadsheet_extract_sub_tables: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Spreadsheet Extract Sub Tables",
      default: false,
    },
    spreadsheet_force_formula_computation: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Spreadsheet Force Formula Computation",
      default: false,
    },
    inline_images_in_markdown: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Inline Images In Markdown",
      default: false,
    },
    job_timeout_in_seconds: {
      anyOf: [
        {
          type: "number",
        },
        {
          type: "null",
        },
      ],
      title: "Job Timeout In Seconds",
    },
    job_timeout_extra_time_per_page_in_seconds: {
      anyOf: [
        {
          type: "number",
        },
        {
          type: "null",
        },
      ],
      title: "Job Timeout Extra Time Per Page In Seconds",
    },
    strict_mode_image_extraction: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Strict Mode Image Extraction",
      default: false,
    },
    strict_mode_image_ocr: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Strict Mode Image Ocr",
      default: false,
    },
    strict_mode_reconstruction: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Strict Mode Reconstruction",
      default: false,
    },
    strict_mode_buggy_font: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Strict Mode Buggy Font",
      default: false,
    },
    save_images: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Save Images",
      default: true,
    },
    hide_headers: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Hide Headers",
      default: false,
    },
    hide_footers: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Hide Footers",
      default: false,
    },
    page_header_prefix: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Page Header Prefix",
    },
    page_header_suffix: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Page Header Suffix",
    },
    page_footer_prefix: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Page Footer Prefix",
    },
    page_footer_suffix: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Page Footer Suffix",
    },
    ignore_document_elements_for_layout_detection: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Ignore Document Elements For Layout Detection",
      default: false,
    },
    output_tables_as_HTML: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Output Tables As Html",
      default: false,
    },
    internal_is_screenshot_job: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Internal Is Screenshot Job",
      default: false,
    },
    parse_mode: {
      anyOf: [
        {
          $ref: "#/components/schemas/ParsingMode",
        },
        {
          type: "null",
        },
      ],
    },
    system_prompt: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "System Prompt",
    },
    system_prompt_append: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "System Prompt Append",
    },
    user_prompt: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "User Prompt",
    },
    page_error_tolerance: {
      anyOf: [
        {
          type: "number",
        },
        {
          type: "null",
        },
      ],
      title: "Page Error Tolerance",
      default: 0.05,
    },
    replace_failed_page_mode: {
      anyOf: [
        {
          $ref: "#/components/schemas/FailPageMode",
        },
        {
          type: "null",
        },
      ],
      default: "raw_text",
    },
    replace_failed_page_with_error_message_prefix: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Replace Failed Page With Error Message Prefix",
    },
    replace_failed_page_with_error_message_suffix: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Replace Failed Page With Error Message Suffix",
    },
    markdown_table_multiline_header_separator: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Markdown Table Multiline Header Separator",
    },
    type: {
      type: "string",
      const: "parse",
      title: "Type",
      default: "parse",
    },
    file_name: {
      type: "string",
      title: "File Name",
      description: "The file name.",
    },
    original_file_name: {
      type: "string",
      title: "Original File Name",
      description: "The original file name.",
    },
    file_key: {
      type: "string",
      title: "File Key",
      description: "The file key.",
    },
    lang: {
      type: "string",
      title: "Lang",
      description: "The language.",
    },
    outputBucket: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Outputbucket",
      description: "The output bucket.",
    },
    file_id: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "File Id",
      description: "The file ID.",
    },
    pipeline_id: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Pipeline Id",
      description: "The pipeline ID.",
    },
  },
  type: "object",
  required: ["file_name", "original_file_name", "file_key", "lang"],
  title: "ParseJobConfig",
  description: "Configuration for llamaparse job",
} as const;

export const ParsePlanLevelSchema = {
  type: "string",
  enum: ["DEFAULT", "PREMIUM"],
  title: "ParsePlanLevel",
  description: "Enum for the Parse plan level.",
} as const;

export const ParserLanguagesSchema = {
  type: "string",
  enum: [
    "af",
    "az",
    "bs",
    "cs",
    "cy",
    "da",
    "de",
    "en",
    "es",
    "et",
    "fr",
    "ga",
    "hr",
    "hu",
    "id",
    "is",
    "it",
    "ku",
    "la",
    "lt",
    "lv",
    "mi",
    "ms",
    "mt",
    "nl",
    "no",
    "oc",
    "pi",
    "pl",
    "pt",
    "ro",
    "rs_latin",
    "sk",
    "sl",
    "sq",
    "sv",
    "sw",
    "tl",
    "tr",
    "uz",
    "vi",
    "ar",
    "fa",
    "ug",
    "ur",
    "bn",
    "as",
    "mni",
    "ru",
    "rs_cyrillic",
    "be",
    "bg",
    "uk",
    "mn",
    "abq",
    "ady",
    "kbd",
    "ava",
    "dar",
    "inh",
    "che",
    "lbe",
    "lez",
    "tab",
    "tjk",
    "hi",
    "mr",
    "ne",
    "bh",
    "mai",
    "ang",
    "bho",
    "mah",
    "sck",
    "new",
    "gom",
    "sa",
    "bgc",
    "th",
    "ch_sim",
    "ch_tra",
    "ja",
    "ko",
    "ta",
    "te",
    "kn",
  ],
  title: "ParserLanguages",
  description: "Enum for representing the languages supported by the parser",
} as const;

export const ParsingHistoryItemSchema = {
  properties: {
    user_id: {
      type: "string",
      title: "User Id",
    },
    day: {
      type: "string",
      title: "Day",
    },
    job_id: {
      type: "string",
      title: "Job Id",
    },
    file_name: {
      type: "string",
      title: "File Name",
    },
    original_file_name: {
      type: "string",
      title: "Original File Name",
    },
    expired: {
      type: "boolean",
      title: "Expired",
      default: false,
    },
    pages: {
      anyOf: [
        {
          type: "number",
        },
        {
          type: "null",
        },
      ],
      title: "Pages",
    },
    images: {
      anyOf: [
        {
          type: "number",
        },
        {
          type: "null",
        },
      ],
      title: "Images",
    },
    time: {
      anyOf: [
        {
          type: "number",
        },
        {
          type: "null",
        },
      ],
      title: "Time",
    },
  },
  type: "object",
  required: ["user_id", "day", "job_id", "file_name", "original_file_name"],
  title: "ParsingHistoryItem",
} as const;

export const ParsingJobSchema = {
  properties: {
    id: {
      type: "string",
      format: "uuid",
      title: "Id",
    },
    status: {
      $ref: "#/components/schemas/StatusEnum",
    },
    error_code: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Error Code",
    },
    error_message: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Error Message",
    },
  },
  type: "object",
  required: ["id", "status"],
  title: "ParsingJob",
} as const;

export const ParsingJobJsonResultSchema = {
  properties: {
    pages: {
      title: "Pages",
      description: "The json result of the parsing job",
    },
    job_metadata: {
      title: "Job Metadata",
      description: "Parsing job metadata , including usage",
    },
  },
  type: "object",
  required: ["pages", "job_metadata"],
  title: "ParsingJobJsonResult",
} as const;

export const ParsingJobMarkdownResultSchema = {
  properties: {
    markdown: {
      type: "string",
      title: "Markdown",
      description: "The markdown result of the parsing job",
    },
    job_metadata: {
      title: "Job Metadata",
      description: "Parsing job metadata , including usage",
    },
  },
  type: "object",
  required: ["markdown", "job_metadata"],
  title: "ParsingJobMarkdownResult",
} as const;

export const ParsingJobStructuredResultSchema = {
  properties: {
    structured: {
      title: "Structured",
      description: "The json result of the structured parsing job",
    },
    job_metadata: {
      title: "Job Metadata",
      description: "Parsing job metadata , including usage",
    },
  },
  type: "object",
  required: ["structured", "job_metadata"],
  title: "ParsingJobStructuredResult",
} as const;

export const ParsingJobTextResultSchema = {
  properties: {
    text: {
      type: "string",
      title: "Text",
      description: "The text result of the parsing job",
    },
    job_metadata: {
      title: "Job Metadata",
      description: "Parsing job metadata , including usage",
    },
  },
  type: "object",
  required: ["text", "job_metadata"],
  title: "ParsingJobTextResult",
} as const;

export const ParsingModeSchema = {
  type: "string",
  enum: [
    "parse_page_without_llm",
    "parse_page_with_llm",
    "parse_page_with_lvm",
    "parse_page_with_agent",
    "parse_page_with_layout_agent",
    "parse_document_with_llm",
    "parse_document_with_lvm",
    "parse_document_with_agent",
  ],
  title: "ParsingMode",
  description: "Enum for representing the mode of parsing to be used",
} as const;

export const PartitionNamesSchema = {
  type: "string",
  enum: [
    "data_source_id_partition",
    "pipeline_id_partition",
    "eval_dataset_id_partition",
    "file_id_partition",
    "pipeline_file_id_partition",
    "file_parsing_id_partition",
    "extraction_schema_id_partition",
  ],
  title: "PartitionNames",
  description: "Enum for dataset partition names.",
} as const;

export const PermissionSchema = {
  properties: {
    id: {
      type: "string",
      format: "uuid",
      title: "Id",
      description: "Unique identifier",
    },
    created_at: {
      anyOf: [
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Created At",
      description: "Creation datetime",
    },
    updated_at: {
      anyOf: [
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Updated At",
      description: "Update datetime",
    },
    name: {
      type: "string",
      maxLength: 3000,
      minLength: 1,
      title: "Name",
      description: "A name for the permission.",
    },
    description: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Description",
      description: "A description for the permission.",
    },
    access: {
      type: "boolean",
      title: "Access",
      description: "Whether the permission is granted or not.",
    },
  },
  type: "object",
  required: ["id", "name", "description", "access"],
  title: "Permission",
  description: "Schema for a permission.",
} as const;

export const PipelineSchema = {
  properties: {
    id: {
      type: "string",
      format: "uuid",
      title: "Id",
      description: "Unique identifier",
    },
    created_at: {
      anyOf: [
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Created At",
      description: "Creation datetime",
    },
    updated_at: {
      anyOf: [
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Updated At",
      description: "Update datetime",
    },
    name: {
      type: "string",
      title: "Name",
    },
    project_id: {
      type: "string",
      format: "uuid",
      title: "Project Id",
    },
    embedding_model_config_id: {
      anyOf: [
        {
          type: "string",
          format: "uuid",
        },
        {
          type: "null",
        },
      ],
      title: "Embedding Model Config Id",
      description: "The ID of the EmbeddingModelConfig this pipeline is using.",
    },
    embedding_model_config: {
      anyOf: [
        {
          $ref: "#/components/schemas/EmbeddingModelConfig",
        },
        {
          type: "null",
        },
      ],
      description: "The embedding model configuration for this pipeline.",
    },
    pipeline_type: {
      $ref: "#/components/schemas/PipelineType",
      description: "Type of pipeline. Either PLAYGROUND or MANAGED.",
      default: "MANAGED",
    },
    managed_pipeline_id: {
      anyOf: [
        {
          type: "string",
          format: "uuid",
        },
        {
          type: "null",
        },
      ],
      title: "Managed Pipeline Id",
      description:
        "The ID of the ManagedPipeline this playground pipeline is linked to.",
    },
    embedding_config: {
      oneOf: [
        {
          $ref: "#/components/schemas/ManagedOpenAIEmbeddingConfig",
        },
        {
          $ref: "#/components/schemas/AzureOpenAIEmbeddingConfig",
        },
        {
          $ref: "#/components/schemas/CohereEmbeddingConfig",
        },
        {
          $ref: "#/components/schemas/GeminiEmbeddingConfig",
        },
        {
          $ref: "#/components/schemas/HuggingFaceInferenceAPIEmbeddingConfig",
        },
        {
          $ref: "#/components/schemas/OpenAIEmbeddingConfig",
        },
        {
          $ref: "#/components/schemas/VertexAIEmbeddingConfig",
        },
        {
          $ref: "#/components/schemas/BedrockEmbeddingConfig",
        },
      ],
      title: "Embedding Config",
      discriminator: {
        propertyName: "type",
        mapping: {
          AZURE_EMBEDDING: "#/components/schemas/AzureOpenAIEmbeddingConfig",
          BEDROCK_EMBEDDING: "#/components/schemas/BedrockEmbeddingConfig",
          COHERE_EMBEDDING: "#/components/schemas/CohereEmbeddingConfig",
          GEMINI_EMBEDDING: "#/components/schemas/GeminiEmbeddingConfig",
          HUGGINGFACE_API_EMBEDDING:
            "#/components/schemas/HuggingFaceInferenceAPIEmbeddingConfig",
          MANAGED_OPENAI_EMBEDDING:
            "#/components/schemas/ManagedOpenAIEmbeddingConfig",
          OPENAI_EMBEDDING: "#/components/schemas/OpenAIEmbeddingConfig",
          VERTEXAI_EMBEDDING: "#/components/schemas/VertexAIEmbeddingConfig",
        },
      },
    },
    sparse_model_config: {
      anyOf: [
        {
          $ref: "#/components/schemas/SparseModelConfig",
        },
        {
          type: "null",
        },
      ],
      description: "Configuration for the sparse model used in hybrid search.",
    },
    config_hash: {
      anyOf: [
        {
          $ref: "#/components/schemas/PipelineConfigurationHashes",
        },
        {
          type: "null",
        },
      ],
      description: "Hashes for the configuration of the pipeline.",
    },
    transform_config: {
      anyOf: [
        {
          $ref: "#/components/schemas/AutoTransformConfig",
        },
        {
          $ref: "#/components/schemas/AdvancedModeTransformConfig",
        },
      ],
      title: "Transform Config",
      description: "Configuration for the transformation.",
    },
    preset_retrieval_parameters: {
      $ref: "#/components/schemas/PresetRetrievalParams",
      description: "Preset retrieval parameters for the pipeline.",
    },
    eval_parameters: {
      $ref: "#/components/schemas/EvalExecutionParams",
      description: "Eval parameters for the pipeline.",
    },
    llama_parse_parameters: {
      anyOf: [
        {
          $ref: "#/components/schemas/LlamaParseParameters",
        },
        {
          type: "null",
        },
      ],
      description:
        "Settings that can be configured for how to use LlamaParse to parse files within a LlamaCloud pipeline.",
    },
    data_sink: {
      anyOf: [
        {
          $ref: "#/components/schemas/DataSink",
        },
        {
          type: "null",
        },
      ],
      description:
        "The data sink for the pipeline. If None, the pipeline will use the fully managed data sink.",
    },
    status: {
      anyOf: [
        {
          type: "string",
          enum: ["CREATED", "DELETING"],
        },
        {
          type: "null",
        },
      ],
      title: "Status",
      description: "Status of the pipeline.",
    },
    metadata_config: {
      anyOf: [
        {
          $ref: "#/components/schemas/PipelineMetadataConfig",
        },
        {
          type: "null",
        },
      ],
      description: "Metadata configuration for the pipeline.",
    },
  },
  type: "object",
  required: ["id", "name", "project_id", "embedding_config"],
  title: "Pipeline",
  description: "Schema for a pipeline.",
} as const;

export const PipelineConfigurationHashesSchema = {
  properties: {
    embedding_config_hash: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Embedding Config Hash",
      description: "Hash of the embedding config.",
      default: "",
    },
    parsing_config_hash: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Parsing Config Hash",
      description: "Hash of the llama parse parameters.",
      default: "",
    },
    transform_config_hash: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Transform Config Hash",
      description: "Hash of the transform config.",
      default: "",
    },
  },
  type: "object",
  title: "PipelineConfigurationHashes",
  description: "Hashes for the configuration of a pipeline.",
} as const;

export const PipelineCreateSchema = {
  properties: {
    embedding_config: {
      anyOf: [
        {
          oneOf: [
            {
              $ref: "#/components/schemas/AzureOpenAIEmbeddingConfig",
            },
            {
              $ref: "#/components/schemas/CohereEmbeddingConfig",
            },
            {
              $ref: "#/components/schemas/GeminiEmbeddingConfig",
            },
            {
              $ref: "#/components/schemas/HuggingFaceInferenceAPIEmbeddingConfig",
            },
            {
              $ref: "#/components/schemas/OpenAIEmbeddingConfig",
            },
            {
              $ref: "#/components/schemas/VertexAIEmbeddingConfig",
            },
            {
              $ref: "#/components/schemas/BedrockEmbeddingConfig",
            },
          ],
          discriminator: {
            propertyName: "type",
            mapping: {
              AZURE_EMBEDDING:
                "#/components/schemas/AzureOpenAIEmbeddingConfig",
              BEDROCK_EMBEDDING: "#/components/schemas/BedrockEmbeddingConfig",
              COHERE_EMBEDDING: "#/components/schemas/CohereEmbeddingConfig",
              GEMINI_EMBEDDING: "#/components/schemas/GeminiEmbeddingConfig",
              HUGGINGFACE_API_EMBEDDING:
                "#/components/schemas/HuggingFaceInferenceAPIEmbeddingConfig",
              OPENAI_EMBEDDING: "#/components/schemas/OpenAIEmbeddingConfig",
              VERTEXAI_EMBEDDING:
                "#/components/schemas/VertexAIEmbeddingConfig",
            },
          },
        },
        {
          type: "null",
        },
      ],
      title: "Embedding Config",
    },
    transform_config: {
      anyOf: [
        {
          $ref: "#/components/schemas/AutoTransformConfig",
        },
        {
          $ref: "#/components/schemas/AdvancedModeTransformConfig",
        },
        {
          type: "null",
        },
      ],
      title: "Transform Config",
      description: "Configuration for the transformation.",
    },
    sparse_model_config: {
      anyOf: [
        {
          $ref: "#/components/schemas/SparseModelConfig",
        },
        {
          type: "null",
        },
      ],
      description: "Configuration for the sparse model used in hybrid search.",
    },
    data_sink_id: {
      anyOf: [
        {
          type: "string",
          format: "uuid",
        },
        {
          type: "null",
        },
      ],
      title: "Data Sink Id",
      description:
        "Data sink ID. When provided instead of data_sink, the data sink will be looked up by ID.",
    },
    embedding_model_config_id: {
      anyOf: [
        {
          type: "string",
          format: "uuid",
        },
        {
          type: "null",
        },
      ],
      title: "Embedding Model Config Id",
      description:
        "Embedding model config ID. When provided instead of embedding_config, the embedding model config will be looked up by ID.",
    },
    data_sink: {
      anyOf: [
        {
          $ref: "#/components/schemas/DataSinkCreate",
        },
        {
          type: "null",
        },
      ],
      description:
        "Data sink. When provided instead of data_sink_id, the data sink will be created.",
    },
    preset_retrieval_parameters: {
      $ref: "#/components/schemas/PresetRetrievalParams",
      description: "Preset retrieval parameters for the pipeline.",
    },
    eval_parameters: {
      $ref: "#/components/schemas/EvalExecutionParams",
      description: "Eval parameters for the pipeline.",
    },
    llama_parse_parameters: {
      $ref: "#/components/schemas/LlamaParseParameters",
    },
    status: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Status",
      description: "Status of the pipeline deployment.",
    },
    metadata_config: {
      anyOf: [
        {
          $ref: "#/components/schemas/PipelineMetadataConfig",
        },
        {
          type: "null",
        },
      ],
      description: "Metadata configuration for the pipeline.",
    },
    name: {
      type: "string",
      maxLength: 3000,
      minLength: 1,
      title: "Name",
    },
    pipeline_type: {
      $ref: "#/components/schemas/PipelineType",
      description: "Type of pipeline. Either PLAYGROUND or MANAGED.",
      default: "MANAGED",
    },
    managed_pipeline_id: {
      anyOf: [
        {
          type: "string",
          format: "uuid",
        },
        {
          type: "null",
        },
      ],
      title: "Managed Pipeline Id",
      description:
        "The ID of the ManagedPipeline this playground pipeline is linked to.",
    },
  },
  type: "object",
  required: ["name"],
  title: "PipelineCreate",
  description: "Schema for creating a pipeline.",
} as const;

export const PipelineDataSourceSchema = {
  properties: {
    id: {
      type: "string",
      format: "uuid",
      title: "Id",
      description: "Unique identifier",
    },
    created_at: {
      anyOf: [
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Created At",
      description: "Creation datetime",
    },
    updated_at: {
      anyOf: [
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Updated At",
      description: "Update datetime",
    },
    name: {
      type: "string",
      title: "Name",
      description: "The name of the data source.",
    },
    source_type: {
      $ref: "#/components/schemas/ConfigurableDataSourceNames",
    },
    custom_metadata: {
      anyOf: [
        {
          additionalProperties: {
            anyOf: [
              {
                additionalProperties: true,
                type: "object",
              },
              {
                items: {},
                type: "array",
              },
              {
                type: "string",
              },
              {
                type: "integer",
              },
              {
                type: "number",
              },
              {
                type: "boolean",
              },
              {
                type: "null",
              },
            ],
          },
          type: "object",
        },
        {
          type: "null",
        },
      ],
      title: "Custom Metadata",
      description:
        "Custom metadata that will be present on all data loaded from the data source",
    },
    component: {
      anyOf: [
        {
          additionalProperties: true,
          type: "object",
        },
        {
          $ref: "#/components/schemas/CloudS3DataSource",
        },
        {
          $ref: "#/components/schemas/CloudAzStorageBlobDataSource",
        },
        {
          $ref: "#/components/schemas/CloudOneDriveDataSource",
        },
        {
          $ref: "#/components/schemas/CloudSharepointDataSource",
        },
        {
          $ref: "#/components/schemas/CloudSlackDataSource",
        },
        {
          $ref: "#/components/schemas/CloudNotionPageDataSource",
        },
        {
          $ref: "#/components/schemas/CloudConfluenceDataSource",
        },
        {
          $ref: "#/components/schemas/CloudJiraDataSource",
        },
        {
          $ref: "#/components/schemas/CloudJiraDataSourceV2",
        },
        {
          $ref: "#/components/schemas/CloudBoxDataSource",
        },
      ],
      title: "DataSourceCreateComponent",
      description: "Component that implements the data source",
    },
    version_metadata: {
      anyOf: [
        {
          $ref: "#/components/schemas/DataSourceReaderVersionMetadata",
        },
        {
          type: "null",
        },
      ],
      description: "Version metadata for the data source",
    },
    project_id: {
      type: "string",
      format: "uuid",
      title: "Project Id",
    },
    data_source_id: {
      type: "string",
      format: "uuid",
      title: "Data Source Id",
      description: "The ID of the data source.",
    },
    pipeline_id: {
      type: "string",
      format: "uuid",
      title: "Pipeline Id",
      description: "The ID of the pipeline.",
    },
    last_synced_at: {
      type: "string",
      format: "date-time",
      title: "Last Synced At",
      description: "The last time the data source was automatically synced.",
    },
    sync_interval: {
      anyOf: [
        {
          type: "number",
        },
        {
          type: "null",
        },
      ],
      title: "Sync Interval",
      description: "The interval at which the data source should be synced.",
    },
    sync_schedule_set_by: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Sync Schedule Set By",
      description: "The id of the user who set the sync schedule.",
    },
    status: {
      anyOf: [
        {
          type: "string",
          enum: ["NOT_STARTED", "IN_PROGRESS", "SUCCESS", "ERROR", "CANCELLED"],
        },
        {
          type: "null",
        },
      ],
      title: "Status",
      description: "The status of the data source in the pipeline.",
    },
    status_updated_at: {
      anyOf: [
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Status Updated At",
      description: "The last time the status was updated.",
    },
  },
  type: "object",
  required: [
    "id",
    "name",
    "source_type",
    "component",
    "project_id",
    "data_source_id",
    "pipeline_id",
    "last_synced_at",
  ],
  title: "PipelineDataSource",
  description: "Schema for a data source in a pipeline.",
} as const;

export const PipelineDataSourceCreateSchema = {
  properties: {
    data_source_id: {
      type: "string",
      format: "uuid",
      title: "Data Source Id",
      description: "The ID of the data source.",
    },
    sync_interval: {
      anyOf: [
        {
          type: "number",
        },
        {
          type: "null",
        },
      ],
      title: "Sync Interval",
      description:
        "The interval at which the data source should be synced. Valid values are: 21600, 43200, 86400",
    },
  },
  type: "object",
  required: ["data_source_id"],
  title: "PipelineDataSourceCreate",
  description:
    "Schema for creating an association between a data source and a pipeline.",
} as const;

export const PipelineDataSourceUpdateSchema = {
  properties: {
    sync_interval: {
      anyOf: [
        {
          type: "number",
        },
        {
          type: "null",
        },
      ],
      title: "Sync Interval",
      description: "The interval at which the data source should be synced.",
    },
  },
  type: "object",
  title: "PipelineDataSourceUpdate",
  description:
    "Schema for updating an association between a data source and a pipeline.",
} as const;

export const PipelineDeploymentSchema = {
  properties: {
    id: {
      type: "string",
      format: "uuid",
      title: "Id",
      description: "Unique identifier",
    },
    created_at: {
      anyOf: [
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Created At",
      description: "Creation datetime",
    },
    updated_at: {
      anyOf: [
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Updated At",
      description: "Update datetime",
    },
    status: {
      $ref: "#/components/schemas/ManagedIngestionStatus",
      description: "Status of the pipeline deployment.",
    },
    started_at: {
      anyOf: [
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Started At",
      description: "Time the pipeline deployment started.",
    },
    ended_at: {
      anyOf: [
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Ended At",
      description: "Time the pipeline deployment finished.",
    },
  },
  type: "object",
  required: ["id", "status"],
  title: "PipelineDeployment",
} as const;

export const PipelineFileSchema = {
  properties: {
    id: {
      type: "string",
      format: "uuid",
      title: "Id",
      description: "Unique identifier",
    },
    created_at: {
      anyOf: [
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Created At",
      description: "Creation datetime",
    },
    updated_at: {
      anyOf: [
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Updated At",
      description: "Update datetime",
    },
    name: {
      anyOf: [
        {
          type: "string",
          maxLength: 3000,
          minLength: 1,
        },
        {
          type: "null",
        },
      ],
      title: "Name",
      description: "Name of the file",
    },
    external_file_id: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "External File Id",
      description: "The ID of the file in the external system",
    },
    file_size: {
      anyOf: [
        {
          type: "integer",
          minimum: 0,
        },
        {
          type: "null",
        },
      ],
      title: "File Size",
      description: "Size of the file in bytes",
    },
    file_type: {
      anyOf: [
        {
          type: "string",
          maxLength: 3000,
          minLength: 1,
        },
        {
          type: "null",
        },
      ],
      title: "File Type",
      description: "File type (e.g. pdf, docx, etc.)",
    },
    project_id: {
      anyOf: [
        {
          type: "string",
          format: "uuid",
        },
        {
          type: "null",
        },
      ],
      title: "Project Id",
      description: "The ID of the project that the file belongs to",
    },
    last_modified_at: {
      anyOf: [
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Last Modified At",
      description: "The last modified time of the file",
    },
    file_id: {
      anyOf: [
        {
          type: "string",
          format: "uuid",
        },
        {
          type: "null",
        },
      ],
      title: "File Id",
      description: "The ID of the file",
    },
    pipeline_id: {
      type: "string",
      format: "uuid",
      title: "Pipeline Id",
      description: "The ID of the pipeline that the file is associated with",
    },
    resource_info: {
      anyOf: [
        {
          additionalProperties: {
            anyOf: [
              {
                additionalProperties: true,
                type: "object",
              },
              {
                items: {},
                type: "array",
              },
              {
                type: "string",
              },
              {
                type: "integer",
              },
              {
                type: "number",
              },
              {
                type: "boolean",
              },
              {
                type: "null",
              },
            ],
          },
          type: "object",
        },
        {
          type: "null",
        },
      ],
      title: "Resource Info",
      description: "Resource information for the file",
    },
    permission_info: {
      anyOf: [
        {
          additionalProperties: {
            anyOf: [
              {
                additionalProperties: true,
                type: "object",
              },
              {
                items: {},
                type: "array",
              },
              {
                type: "string",
              },
              {
                type: "integer",
              },
              {
                type: "number",
              },
              {
                type: "boolean",
              },
              {
                type: "null",
              },
            ],
          },
          type: "object",
        },
        {
          type: "null",
        },
      ],
      title: "Permission Info",
      description: "Permission information for the file",
    },
    custom_metadata: {
      anyOf: [
        {
          additionalProperties: {
            anyOf: [
              {
                additionalProperties: true,
                type: "object",
              },
              {
                items: {},
                type: "array",
              },
              {
                type: "string",
              },
              {
                type: "integer",
              },
              {
                type: "number",
              },
              {
                type: "boolean",
              },
              {
                type: "null",
              },
            ],
          },
          type: "object",
        },
        {
          type: "null",
        },
      ],
      title: "Custom Metadata",
      description: "Custom metadata for the file",
    },
    data_source_id: {
      anyOf: [
        {
          type: "string",
          format: "uuid",
        },
        {
          type: "null",
        },
      ],
      title: "Data Source Id",
      description: "The ID of the data source that the file belongs to",
    },
    config_hash: {
      anyOf: [
        {
          additionalProperties: {
            anyOf: [
              {
                additionalProperties: true,
                type: "object",
              },
              {
                items: {},
                type: "array",
              },
              {
                type: "string",
              },
              {
                type: "integer",
              },
              {
                type: "number",
              },
              {
                type: "boolean",
              },
              {
                type: "null",
              },
            ],
          },
          type: "object",
        },
        {
          type: "null",
        },
      ],
      title: "Config Hash",
      description: "Hashes for the configuration of the pipeline.",
    },
    indexed_page_count: {
      anyOf: [
        {
          type: "integer",
        },
        {
          type: "null",
        },
      ],
      title: "Indexed Page Count",
      description: "The number of pages that have been indexed for this file",
    },
    status: {
      anyOf: [
        {
          type: "string",
          enum: ["NOT_STARTED", "IN_PROGRESS", "SUCCESS", "ERROR", "CANCELLED"],
        },
        {
          type: "null",
        },
      ],
      title: "Status",
      description: "Status of the pipeline file",
    },
    status_updated_at: {
      anyOf: [
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Status Updated At",
      description: "The last time the status was updated",
    },
  },
  type: "object",
  required: ["id", "pipeline_id"],
  title: "PipelineFile",
  description: "Schema for a file that is associated with a pipeline.",
} as const;

export const PipelineFileCreateSchema = {
  properties: {
    file_id: {
      type: "string",
      format: "uuid",
      title: "File Id",
      description: "The ID of the file",
    },
    custom_metadata: {
      anyOf: [
        {
          additionalProperties: {
            anyOf: [
              {
                additionalProperties: true,
                type: "object",
              },
              {
                items: {},
                type: "array",
              },
              {
                type: "string",
              },
              {
                type: "integer",
              },
              {
                type: "number",
              },
              {
                type: "boolean",
              },
              {
                type: "null",
              },
            ],
          },
          type: "object",
        },
        {
          type: "null",
        },
      ],
      title: "Custom Metadata",
      description: "Custom metadata for the file",
    },
  },
  type: "object",
  required: ["file_id"],
  title: "PipelineFileCreate",
  description: "Schema for creating a file that is associated with a pipeline.",
} as const;

export const PipelineFileUpdateSchema = {
  properties: {
    custom_metadata: {
      anyOf: [
        {
          additionalProperties: {
            anyOf: [
              {
                additionalProperties: true,
                type: "object",
              },
              {
                items: {},
                type: "array",
              },
              {
                type: "string",
              },
              {
                type: "integer",
              },
              {
                type: "number",
              },
              {
                type: "boolean",
              },
              {
                type: "null",
              },
            ],
          },
          type: "object",
        },
        {
          type: "null",
        },
      ],
      title: "Custom Metadata",
      description: "Custom metadata for the file",
    },
  },
  type: "object",
  title: "PipelineFileUpdate",
  description: "Schema for updating a file that is associated with a pipeline.",
} as const;

export const PipelineFileUpdateDispatcherConfigSchema = {
  properties: {
    type: {
      type: "string",
      const: "pipeline_file_update_dispatcher",
      title: "Type",
      default: "pipeline_file_update_dispatcher",
    },
    pipeline_file_ids: {
      anyOf: [
        {
          items: {
            type: "string",
            format: "uuid",
          },
          type: "array",
        },
        {
          type: "null",
        },
      ],
      title: "Pipeline File Ids",
      description: "The IDs for the files this execution ran against.",
    },
    should_delete: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Should Delete",
      description: "Whether to delete the files",
      default: false,
    },
    delete_info: {
      anyOf: [
        {
          $ref: "#/components/schemas/DeleteParams",
        },
        {
          type: "null",
        },
      ],
      description: "The parameters for the delete job.",
    },
  },
  type: "object",
  title: "PipelineFileUpdateDispatcherConfig",
  description: "Schema for the parameters of a load files job.",
} as const;

export const PipelineFileUpdaterConfigSchema = {
  properties: {
    custom_metadata: {
      anyOf: [
        {
          additionalProperties: true,
          type: "object",
        },
        {
          type: "null",
        },
      ],
      title: "Custom Metadata",
      description: "The custom metadata to attach to the documents.",
    },
    resource_info: {
      anyOf: [
        {
          additionalProperties: true,
          type: "object",
        },
        {
          type: "null",
        },
      ],
      title: "Resource Info",
      description: "The resource info about the file",
    },
    type: {
      type: "string",
      const: "pipeline_file_updater",
      title: "Type",
      default: "pipeline_file_updater",
    },
    should_delete: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Should Delete",
      description: "Whether to delete the files",
      default: false,
    },
    should_parse: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Should Parse",
      description: "Whether to parse the files",
      default: true,
    },
    delete_info: {
      anyOf: [
        {
          $ref: "#/components/schemas/DeleteParams",
        },
        {
          type: "null",
        },
      ],
      description: "The parameters for the delete job.",
    },
    is_new_file: {
      type: "boolean",
      title: "Is New File",
      description: "Whether the file is new",
      default: false,
    },
    data_source_project_file_changed: {
      type: "boolean",
      title: "Data Source Project File Changed",
      description: "Whether the data source project file has changed",
      default: false,
    },
  },
  type: "object",
  title: "PipelineFileUpdaterConfig",
  description: "Schema for the parameters of a load files job.",
} as const;

export const PipelineManagedIngestionJobParamsSchema = {
  properties: {
    type: {
      type: "string",
      const: "pipeline_managed_ingestion",
      title: "Type",
      default: "pipeline_managed_ingestion",
    },
    should_delete: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Should Delete",
      description: "Whether to delete the data sources from the pipeline",
      default: false,
    },
    delete_info: {
      anyOf: [
        {
          $ref: "#/components/schemas/DeleteParams",
        },
        {
          type: "null",
        },
      ],
      description: "The parameters for the delete job.",
    },
  },
  type: "object",
  title: "PipelineManagedIngestionJobParams",
  description: "Schema for the parameters of a managed pipeline ingestion job.",
} as const;

export const PipelineMetadataConfigSchema = {
  properties: {
    excluded_embed_metadata_keys: {
      items: {
        type: "string",
      },
      type: "array",
      title: "Excluded Embed Metadata Keys",
      description: "List of metadata keys to exclude from embeddings",
    },
    excluded_llm_metadata_keys: {
      items: {
        type: "string",
      },
      type: "array",
      title: "Excluded Llm Metadata Keys",
      description: "List of metadata keys to exclude from LLM during retrieval",
    },
  },
  type: "object",
  title: "PipelineMetadataConfig",
} as const;

export const PipelineTypeSchema = {
  type: "string",
  enum: ["PLAYGROUND", "MANAGED"],
  title: "PipelineType",
  description: "Enum for representing the type of a pipeline",
} as const;

export const PipelineUpdateSchema = {
  properties: {
    embedding_config: {
      anyOf: [
        {
          oneOf: [
            {
              $ref: "#/components/schemas/AzureOpenAIEmbeddingConfig",
            },
            {
              $ref: "#/components/schemas/CohereEmbeddingConfig",
            },
            {
              $ref: "#/components/schemas/GeminiEmbeddingConfig",
            },
            {
              $ref: "#/components/schemas/HuggingFaceInferenceAPIEmbeddingConfig",
            },
            {
              $ref: "#/components/schemas/OpenAIEmbeddingConfig",
            },
            {
              $ref: "#/components/schemas/VertexAIEmbeddingConfig",
            },
            {
              $ref: "#/components/schemas/BedrockEmbeddingConfig",
            },
          ],
          discriminator: {
            propertyName: "type",
            mapping: {
              AZURE_EMBEDDING:
                "#/components/schemas/AzureOpenAIEmbeddingConfig",
              BEDROCK_EMBEDDING: "#/components/schemas/BedrockEmbeddingConfig",
              COHERE_EMBEDDING: "#/components/schemas/CohereEmbeddingConfig",
              GEMINI_EMBEDDING: "#/components/schemas/GeminiEmbeddingConfig",
              HUGGINGFACE_API_EMBEDDING:
                "#/components/schemas/HuggingFaceInferenceAPIEmbeddingConfig",
              OPENAI_EMBEDDING: "#/components/schemas/OpenAIEmbeddingConfig",
              VERTEXAI_EMBEDDING:
                "#/components/schemas/VertexAIEmbeddingConfig",
            },
          },
        },
        {
          type: "null",
        },
      ],
      title: "Embedding Config",
    },
    transform_config: {
      anyOf: [
        {
          $ref: "#/components/schemas/AutoTransformConfig",
        },
        {
          $ref: "#/components/schemas/AdvancedModeTransformConfig",
        },
        {
          type: "null",
        },
      ],
      title: "Transform Config",
      description: "Configuration for the transformation.",
    },
    sparse_model_config: {
      anyOf: [
        {
          $ref: "#/components/schemas/SparseModelConfig",
        },
        {
          type: "null",
        },
      ],
      description: "Configuration for the sparse model used in hybrid search.",
    },
    data_sink_id: {
      anyOf: [
        {
          type: "string",
          format: "uuid",
        },
        {
          type: "null",
        },
      ],
      title: "Data Sink Id",
      description:
        "Data sink ID. When provided instead of data_sink, the data sink will be looked up by ID.",
    },
    embedding_model_config_id: {
      anyOf: [
        {
          type: "string",
          format: "uuid",
        },
        {
          type: "null",
        },
      ],
      title: "Embedding Model Config Id",
      description:
        "Embedding model config ID. When provided instead of embedding_config, the embedding model config will be looked up by ID.",
    },
    data_sink: {
      anyOf: [
        {
          $ref: "#/components/schemas/DataSinkCreate",
        },
        {
          type: "null",
        },
      ],
      description:
        "Data sink. When provided instead of data_sink_id, the data sink will be created.",
    },
    preset_retrieval_parameters: {
      anyOf: [
        {
          $ref: "#/components/schemas/PresetRetrievalParams",
        },
        {
          type: "null",
        },
      ],
      description: "Preset retrieval parameters for the pipeline.",
    },
    eval_parameters: {
      anyOf: [
        {
          $ref: "#/components/schemas/EvalExecutionParams",
        },
        {
          type: "null",
        },
      ],
      description: "Eval parameters for the pipeline.",
    },
    llama_parse_parameters: {
      anyOf: [
        {
          $ref: "#/components/schemas/LlamaParseParameters",
        },
        {
          type: "null",
        },
      ],
      description:
        "Settings that can be configured for how to use LlamaParse to parse files within a LlamaCloud pipeline.",
      deprecated: true,
    },
    status: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Status",
      description: "Status of the pipeline deployment.",
    },
    metadata_config: {
      anyOf: [
        {
          $ref: "#/components/schemas/PipelineMetadataConfig",
        },
        {
          type: "null",
        },
      ],
      description: "Metadata configuration for the pipeline.",
    },
    name: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Name",
    },
    managed_pipeline_id: {
      anyOf: [
        {
          type: "string",
          format: "uuid",
        },
        {
          type: "null",
        },
      ],
      title: "Managed Pipeline Id",
      description:
        "The ID of the ManagedPipeline this playground pipeline is linked to.",
    },
  },
  type: "object",
  title: "PipelineUpdate",
  description: "Schema for updating a pipeline.",
} as const;

export const PlanLimitsSchema = {
  properties: {
    allow_pay_as_you_go: {
      type: "boolean",
      title: "Allow Pay As You Go",
      description: "Whether usage is allowed after credit grants are exhausted",
    },
    subscription_cost_usd: {
      type: "integer",
      title: "Subscription Cost Usd",
    },
    max_monthly_invoice_total_usd: {
      anyOf: [
        {
          type: "integer",
        },
        {
          type: "null",
        },
      ],
      title: "Max Monthly Invoice Total Usd",
    },
    spending_soft_alerts_usd_cents: {
      anyOf: [
        {
          items: {
            type: "integer",
          },
          type: "array",
        },
        {
          type: "null",
        },
      ],
      title: "Spending Soft Alerts Usd Cents",
      description:
        "The amount of USD cents at which a soft alert should be triggered",
    },
    max_concurrent_parse_jobs_premium: {
      anyOf: [
        {
          type: "integer",
        },
        {
          type: "null",
        },
      ],
      title: "Max Concurrent Parse Jobs Premium",
    },
    max_concurrent_parse_jobs_other: {
      anyOf: [
        {
          type: "integer",
        },
        {
          type: "null",
        },
      ],
      title: "Max Concurrent Parse Jobs Other",
    },
    max_extraction_agents: {
      anyOf: [
        {
          type: "integer",
        },
        {
          type: "null",
        },
      ],
      title: "Max Extraction Agents",
    },
    max_extraction_runs: {
      anyOf: [
        {
          type: "integer",
        },
        {
          type: "null",
        },
      ],
      title: "Max Extraction Runs",
    },
    max_extraction_jobs: {
      anyOf: [
        {
          type: "integer",
        },
        {
          type: "null",
        },
      ],
      title: "Max Extraction Jobs",
    },
    max_pages_per_index: {
      anyOf: [
        {
          type: "integer",
        },
        {
          type: "null",
        },
      ],
      title: "Max Pages Per Index",
    },
    max_files_per_index: {
      anyOf: [
        {
          type: "integer",
        },
        {
          type: "null",
        },
      ],
      title: "Max Files Per Index",
    },
    max_indexes: {
      anyOf: [
        {
          type: "integer",
        },
        {
          type: "null",
        },
      ],
      title: "Max Indexes",
    },
    max_concurrent_index_jobs: {
      anyOf: [
        {
          type: "integer",
        },
        {
          type: "null",
        },
      ],
      title: "Max Concurrent Index Jobs",
    },
    max_data_sources: {
      anyOf: [
        {
          type: "integer",
        },
        {
          type: "null",
        },
      ],
      title: "Max Data Sources",
    },
    max_embedding_models: {
      anyOf: [
        {
          type: "integer",
        },
        {
          type: "null",
        },
      ],
      title: "Max Embedding Models",
    },
    max_data_sinks: {
      anyOf: [
        {
          type: "integer",
        },
        {
          type: "null",
        },
      ],
      title: "Max Data Sinks",
    },
    max_published_agents: {
      anyOf: [
        {
          type: "integer",
        },
        {
          type: "null",
        },
      ],
      title: "Max Published Agents",
    },
    max_report_agent_sessions: {
      anyOf: [
        {
          type: "integer",
        },
        {
          type: "null",
        },
      ],
      title: "Max Report Agent Sessions",
    },
    max_users: {
      anyOf: [
        {
          type: "integer",
        },
        {
          type: "null",
        },
      ],
      title: "Max Users",
    },
    max_organizations: {
      anyOf: [
        {
          type: "integer",
        },
        {
          type: "null",
        },
      ],
      title: "Max Organizations",
    },
    max_projects: {
      anyOf: [
        {
          type: "integer",
        },
        {
          type: "null",
        },
      ],
      title: "Max Projects",
    },
    mfa_enabled: {
      type: "boolean",
      title: "Mfa Enabled",
    },
    sso_enabled: {
      type: "boolean",
      title: "Sso Enabled",
    },
  },
  type: "object",
  required: [
    "allow_pay_as_you_go",
    "subscription_cost_usd",
    "max_monthly_invoice_total_usd",
    "max_concurrent_parse_jobs_premium",
    "max_concurrent_parse_jobs_other",
    "max_extraction_agents",
    "max_extraction_runs",
    "max_extraction_jobs",
    "max_pages_per_index",
    "max_files_per_index",
    "max_indexes",
    "max_concurrent_index_jobs",
    "max_data_sources",
    "max_embedding_models",
    "max_data_sinks",
    "max_published_agents",
    "max_report_agent_sessions",
    "max_users",
    "max_organizations",
    "max_projects",
    "mfa_enabled",
    "sso_enabled",
  ],
  title: "PlanLimits",
} as const;

export const PlaygroundSessionSchema = {
  properties: {
    id: {
      type: "string",
      format: "uuid",
      title: "Id",
      description: "Unique identifier",
    },
    created_at: {
      anyOf: [
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Created At",
      description: "Creation datetime",
    },
    updated_at: {
      anyOf: [
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Updated At",
      description: "Update datetime",
    },
    pipeline_id: {
      type: "string",
      format: "uuid",
      title: "Pipeline Id",
    },
    user_id: {
      type: "string",
      title: "User Id",
    },
    llm_params_id: {
      type: "string",
      format: "uuid",
      title: "Llm Params Id",
    },
    llm_params: {
      $ref: "#/components/schemas/LLMParameters",
      description: "LLM parameters last used in this session.",
    },
    retrieval_params_id: {
      type: "string",
      format: "uuid",
      title: "Retrieval Params Id",
    },
    retrieval_params: {
      $ref: "#/components/schemas/PresetRetrievalParams",
      description: "Preset retrieval parameters last used in this session.",
    },
    chat_messages: {
      items: {
        $ref: "#/components/schemas/ChatMessage",
      },
      type: "array",
      title: "Chat Messages",
      description: "Chat message history for this session.",
    },
  },
  type: "object",
  required: [
    "id",
    "pipeline_id",
    "user_id",
    "llm_params_id",
    "retrieval_params_id",
  ],
  title: "PlaygroundSession",
  description: "A playground session for a user.",
} as const;

export const PoolingSchema = {
  type: "string",
  enum: ["cls", "mean", "last"],
  title: "Pooling",
  description: "Enum of possible pooling choices with pooling behaviors.",
} as const;

export const PresetCompositeRetrievalParamsSchema = {
  properties: {
    mode: {
      $ref: "#/components/schemas/CompositeRetrievalMode",
      description: "The mode of composite retrieval.",
      default: "full",
    },
    rerank_top_n: {
      anyOf: [
        {
          type: "integer",
        },
        {
          type: "null",
        },
      ],
      title: "Rerank Top N",
      description:
        "(use rerank_config.top_n instead) The number of nodes to retrieve after reranking over retrieved nodes from all retrieval tools.",
      deprecated: true,
    },
    rerank_config: {
      $ref: "#/components/schemas/ReRankConfig",
      description: "The rerank configuration for composite retrieval.",
    },
  },
  type: "object",
  title: "PresetCompositeRetrievalParams",
} as const;

export const PresetRetrievalParamsSchema = {
  properties: {
    dense_similarity_top_k: {
      anyOf: [
        {
          type: "integer",
          maximum: 100,
          minimum: 1,
        },
        {
          type: "null",
        },
      ],
      title: "Dense Similarity Top K",
      description: "Number of nodes for dense retrieval.",
      default: 30,
    },
    dense_similarity_cutoff: {
      anyOf: [
        {
          type: "number",
          maximum: 1,
          minimum: 0,
        },
        {
          type: "null",
        },
      ],
      title: "Dense Similarity Cutoff",
      description: "Minimum similarity score wrt query for retrieval",
      default: 0,
    },
    sparse_similarity_top_k: {
      anyOf: [
        {
          type: "integer",
          maximum: 100,
          minimum: 1,
        },
        {
          type: "null",
        },
      ],
      title: "Sparse Similarity Top K",
      description: "Number of nodes for sparse retrieval.",
      default: 30,
    },
    enable_reranking: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Enable Reranking",
      description: "Enable reranking for retrieval",
    },
    rerank_top_n: {
      anyOf: [
        {
          type: "integer",
          maximum: 100,
          minimum: 1,
        },
        {
          type: "null",
        },
      ],
      title: "Rerank Top N",
      description: "Number of reranked nodes for returning.",
      default: 6,
    },
    alpha: {
      anyOf: [
        {
          type: "number",
          maximum: 1,
          minimum: 0,
        },
        {
          type: "null",
        },
      ],
      title: "Alpha",
      description:
        "Alpha value for hybrid retrieval to determine the weights between dense and sparse retrieval. 0 is sparse retrieval and 1 is dense retrieval.",
    },
    search_filters: {
      anyOf: [
        {
          $ref: "#/components/schemas/MetadataFilters",
        },
        {
          type: "null",
        },
      ],
      description: "Search filters for retrieval.",
    },
    search_filters_inference_schema: {
      anyOf: [
        {
          additionalProperties: {
            anyOf: [
              {
                additionalProperties: true,
                type: "object",
              },
              {
                items: {},
                type: "array",
              },
              {
                type: "string",
              },
              {
                type: "integer",
              },
              {
                type: "number",
              },
              {
                type: "boolean",
              },
              {
                type: "null",
              },
            ],
          },
          type: "object",
        },
        {
          type: "null",
        },
      ],
      title: "Search Filters Inference Schema",
      description:
        "JSON Schema that will be used to infer search_filters. Omit or leave as null to skip inference.",
    },
    files_top_k: {
      anyOf: [
        {
          type: "integer",
          maximum: 5,
          minimum: 1,
        },
        {
          type: "null",
        },
      ],
      title: "Files Top K",
      description:
        "Number of files to retrieve (only for retrieval mode files_via_metadata and files_via_content).",
      default: 1,
    },
    retrieval_mode: {
      $ref: "#/components/schemas/RetrievalMode",
      description: "The retrieval mode for the query.",
      default: "chunks",
    },
    retrieve_image_nodes: {
      type: "boolean",
      title: "Retrieve Image Nodes",
      description: "Whether to retrieve image nodes.",
      default: false,
      deprecated: true,
    },
    retrieve_page_screenshot_nodes: {
      type: "boolean",
      title: "Retrieve Page Screenshot Nodes",
      description: "Whether to retrieve page screenshot nodes.",
      default: false,
    },
    retrieve_page_figure_nodes: {
      type: "boolean",
      title: "Retrieve Page Figure Nodes",
      description: "Whether to retrieve page figure nodes.",
      default: false,
    },
    class_name: {
      type: "string",
      title: "Class Name",
      default: "base_component",
    },
  },
  type: "object",
  title: "PresetRetrievalParams",
  description:
    "Schema for the search params for an retrieval execution that can be preset for a pipeline.",
} as const;

export const PresignedUrlSchema = {
  properties: {
    url: {
      type: "string",
      minLength: 1,
      format: "uri",
      title: "Url",
      description: "A presigned URL for IO operations against a private file",
    },
    expires_at: {
      type: "string",
      format: "date-time",
      title: "Expires At",
      description: "The time at which the presigned URL expires",
    },
    form_fields: {
      anyOf: [
        {
          additionalProperties: {
            type: "string",
          },
          type: "object",
        },
        {
          type: "null",
        },
      ],
      title: "Form Fields",
      description: "Form fields for a presigned POST request",
    },
  },
  type: "object",
  required: ["url", "expires_at"],
  title: "PresignedUrl",
  description: "Schema for a presigned URL.",
} as const;

export const ProjectSchema = {
  properties: {
    name: {
      type: "string",
      maxLength: 3000,
      minLength: 1,
      title: "Name",
    },
    id: {
      type: "string",
      format: "uuid",
      title: "Id",
      description: "Unique identifier",
    },
    created_at: {
      anyOf: [
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Created At",
      description: "Creation datetime",
    },
    updated_at: {
      anyOf: [
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Updated At",
      description: "Update datetime",
    },
    ad_hoc_eval_dataset_id: {
      anyOf: [
        {
          type: "string",
          format: "uuid",
        },
        {
          type: "null",
        },
      ],
      title: "Ad Hoc Eval Dataset Id",
    },
    organization_id: {
      type: "string",
      format: "uuid",
      title: "Organization Id",
      description: "The Organization ID the project is under.",
    },
    is_default: {
      type: "boolean",
      title: "Is Default",
      description: "Whether this project is the default project for the user.",
      default: false,
    },
  },
  type: "object",
  required: ["name", "id", "organization_id"],
  title: "Project",
  description: "Schema for a project.",
} as const;

export const ProjectCreateSchema = {
  properties: {
    name: {
      type: "string",
      maxLength: 3000,
      minLength: 1,
      title: "Name",
    },
  },
  type: "object",
  required: ["name"],
  title: "ProjectCreate",
  description: "Schema for creating a project.",
} as const;

export const ProjectUpdateSchema = {
  properties: {
    name: {
      type: "string",
      maxLength: 3000,
      minLength: 1,
      title: "Name",
    },
  },
  type: "object",
  required: ["name"],
  title: "ProjectUpdate",
  description: "Schema for updating a project.",
} as const;

export const PublicModelNameSchema = {
  type: "string",
  enum: [
    "openai-gpt-4o",
    "openai-gpt-4o-mini",
    "openai-gpt-4-1",
    "openai-gpt-4-1-mini",
    "openai-gpt-4-1-nano",
    "openai-gpt-5",
    "openai-gpt-5-mini",
    "openai-gpt-5-nano",
    "openai-text-embedding-3-small",
    "openai-text-embedding-3-large",
    "openai-whisper-1",
    "anthropic-sonnet-3.5",
    "anthropic-sonnet-3.5-v2",
    "anthropic-sonnet-3.7",
    "anthropic-sonnet-4.0",
    "gemini-2.5-flash",
    "gemini-2.5-pro",
    "gemini-2.0-flash",
    "gemini-2.0-flash-lite",
    "gemini-2.5-flash-lite",
    "gemini-1.5-flash",
    "gemini-1.5-pro",
  ],
  title: "PublicModelName",
} as const;

export const QuotaConfigurationSchema = {
  properties: {
    source_type: {
      type: "string",
      const: "organization",
      title: "Source Type",
      description: "The source type, e.g. 'organization'",
    },
    source_id: {
      type: "string",
      title: "Source Id",
      description: "The source ID, e.g. the organization ID",
    },
    configuration_type: {
      type: "string",
      enum: [
        "rate_limit_parse_concurrent_premium",
        "rate_limit_parse_concurrent_default",
        "rate_limit_concurrent_jobs_in_execution_default",
        "rate_limit_concurrent_jobs_in_execution_doc_ingest",
        "limit_embedding_character",
      ],
      title: "Configuration Type",
      description: "The quota configuration type",
    },
    configuration_value: {
      $ref: "#/components/schemas/QuotaRateLimitConfigurationValue",
      description: "The quota configuration value",
    },
    configuration_metadata: {
      anyOf: [
        {
          additionalProperties: true,
          type: "object",
        },
        {
          type: "null",
        },
      ],
      title: "Configuration Metadata",
      description: "The configuration metadata",
    },
    started_at: {
      type: "string",
      format: "date-time",
      title: "Started At",
      description: "The start date of the quota",
    },
    ended_at: {
      anyOf: [
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Ended At",
      description: "The end date of the quota",
    },
    idempotency_key: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Idempotency Key",
      description: "The idempotency key",
    },
    status: {
      type: "string",
      enum: ["ACTIVE", "INACTIVE"],
      title: "Status",
      description: "The status of the quota, i.e. 'ACTIVE' or 'INACTIVE'",
    },
    id: {
      anyOf: [
        {
          type: "string",
          format: "uuid",
        },
        {
          type: "null",
        },
      ],
      title: "Id",
      description: "The system-generated UUID for the quota",
    },
    created_at: {
      anyOf: [
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Created At",
      description:
        "The creation date of the quota configuration in the database",
    },
    updated_at: {
      anyOf: [
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Updated At",
      description:
        "The last updated date of the quota configuration in the database",
    },
  },
  type: "object",
  required: [
    "source_type",
    "source_id",
    "configuration_type",
    "configuration_value",
    "configuration_metadata",
    "status",
  ],
  title: "QuotaConfiguration",
  description: "Full quota configuration model.",
} as const;

export const QuotaRateLimitConfigurationValueSchema = {
  properties: {
    numerator: {
      type: "integer",
      title: "Numerator",
      description: "The rate numerator",
    },
    denominator: {
      anyOf: [
        {
          type: "integer",
        },
        {
          type: "null",
        },
      ],
      title: "Denominator",
      description: "The rate limit denominator",
    },
    denominator_units: {
      anyOf: [
        {
          type: "string",
          enum: ["second", "minute", "hour", "day"],
        },
        {
          type: "null",
        },
      ],
      title: "Denominator Units",
      description: "The default rate limit denominator units",
    },
  },
  type: "object",
  required: ["numerator"],
  title: "QuotaRateLimitConfigurationValue",
  description: "Quota-specific wrapper for default rate limit configuration.",
} as const;

export const ReRankConfigSchema = {
  properties: {
    top_n: {
      type: "integer",
      title: "Top N",
      description:
        "The number of nodes to retrieve after reranking over retrieved nodes from all retrieval tools.",
      default: 6,
      gte: 1,
    },
    type: {
      $ref: "#/components/schemas/ReRankerType",
      description: "The type of reranker to use.",
      default: "system_default",
    },
  },
  type: "object",
  title: "ReRankConfig",
} as const;

export const ReRankerTypeSchema = {
  type: "string",
  enum: ["system_default", "llm", "cohere", "bedrock", "score", "disabled"],
  title: "ReRankerType",
  description: "Enum for the reranker type.",
} as const;

export const RecurringCreditGrantSchema = {
  properties: {
    name: {
      type: "string",
      title: "Name",
    },
    credit_amount: {
      type: "integer",
      title: "Credit Amount",
    },
    credit_type: {
      $ref: "#/components/schemas/CreditType",
    },
    product_id: {
      type: "string",
      title: "Product Id",
      description:
        "The ID of the product in Metronome used to represent the credit grant",
    },
    priority: {
      type: "number",
      title: "Priority",
    },
    rollover_fraction: {
      type: "number",
      title: "Rollover Fraction",
      description:
        "The fraction of the credit that will roll over to the next period, between 0 and 1",
    },
    periods_duration: {
      type: "number",
      title: "Periods Duration",
      description: "How many billing periods the credit grant will last for",
      default: 1,
    },
  },
  type: "object",
  required: [
    "name",
    "credit_amount",
    "credit_type",
    "product_id",
    "priority",
    "rollover_fraction",
  ],
  title: "RecurringCreditGrant",
} as const;

export const RelatedNodeInfoSchema = {
  properties: {
    node_id: {
      type: "string",
      title: "Node Id",
    },
    node_type: {
      anyOf: [
        {
          $ref: "#/components/schemas/ObjectType",
        },
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Node Type",
    },
    metadata: {
      additionalProperties: true,
      type: "object",
      title: "Metadata",
    },
    hash: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Hash",
    },
    class_name: {
      type: "string",
      title: "Class Name",
      default: "RelatedNodeInfo",
    },
  },
  type: "object",
  required: ["node_id"],
  title: "RelatedNodeInfo",
} as const;

export const RestrictSchema = {
  properties: {
    project_id: {
      anyOf: [
        {
          type: "string",
          format: "uuid",
        },
        {
          type: "null",
        },
      ],
      title: "Project Id",
      description: "The project ID to restrict the user to.",
    },
  },
  type: "object",
  required: ["project_id"],
  title: "Restrict",
} as const;

export const RetrievalModeSchema = {
  type: "string",
  enum: ["chunks", "files_via_metadata", "files_via_content", "auto_routed"],
  title: "RetrievalMode",
} as const;

export const RetrievalParamsSchema = {
  properties: {
    dense_similarity_top_k: {
      anyOf: [
        {
          type: "integer",
          maximum: 100,
          minimum: 1,
        },
        {
          type: "null",
        },
      ],
      title: "Dense Similarity Top K",
      description: "Number of nodes for dense retrieval.",
      default: 30,
    },
    dense_similarity_cutoff: {
      anyOf: [
        {
          type: "number",
          maximum: 1,
          minimum: 0,
        },
        {
          type: "null",
        },
      ],
      title: "Dense Similarity Cutoff",
      description: "Minimum similarity score wrt query for retrieval",
      default: 0,
    },
    sparse_similarity_top_k: {
      anyOf: [
        {
          type: "integer",
          maximum: 100,
          minimum: 1,
        },
        {
          type: "null",
        },
      ],
      title: "Sparse Similarity Top K",
      description: "Number of nodes for sparse retrieval.",
      default: 30,
    },
    enable_reranking: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Enable Reranking",
      description: "Enable reranking for retrieval",
    },
    rerank_top_n: {
      anyOf: [
        {
          type: "integer",
          maximum: 100,
          minimum: 1,
        },
        {
          type: "null",
        },
      ],
      title: "Rerank Top N",
      description: "Number of reranked nodes for returning.",
      default: 6,
    },
    alpha: {
      anyOf: [
        {
          type: "number",
          maximum: 1,
          minimum: 0,
        },
        {
          type: "null",
        },
      ],
      title: "Alpha",
      description:
        "Alpha value for hybrid retrieval to determine the weights between dense and sparse retrieval. 0 is sparse retrieval and 1 is dense retrieval.",
    },
    search_filters: {
      anyOf: [
        {
          $ref: "#/components/schemas/MetadataFilters",
        },
        {
          type: "null",
        },
      ],
      description: "Search filters for retrieval.",
    },
    search_filters_inference_schema: {
      anyOf: [
        {
          additionalProperties: {
            anyOf: [
              {
                additionalProperties: true,
                type: "object",
              },
              {
                items: {},
                type: "array",
              },
              {
                type: "string",
              },
              {
                type: "integer",
              },
              {
                type: "number",
              },
              {
                type: "boolean",
              },
              {
                type: "null",
              },
            ],
          },
          type: "object",
        },
        {
          type: "null",
        },
      ],
      title: "Search Filters Inference Schema",
      description:
        "JSON Schema that will be used to infer search_filters. Omit or leave as null to skip inference.",
    },
    files_top_k: {
      anyOf: [
        {
          type: "integer",
          maximum: 5,
          minimum: 1,
        },
        {
          type: "null",
        },
      ],
      title: "Files Top K",
      description:
        "Number of files to retrieve (only for retrieval mode files_via_metadata and files_via_content).",
      default: 1,
    },
    retrieval_mode: {
      $ref: "#/components/schemas/RetrievalMode",
      description: "The retrieval mode for the query.",
      default: "chunks",
    },
    retrieve_image_nodes: {
      type: "boolean",
      title: "Retrieve Image Nodes",
      description: "Whether to retrieve image nodes.",
      default: false,
      deprecated: true,
    },
    retrieve_page_screenshot_nodes: {
      type: "boolean",
      title: "Retrieve Page Screenshot Nodes",
      description: "Whether to retrieve page screenshot nodes.",
      default: false,
    },
    retrieve_page_figure_nodes: {
      type: "boolean",
      title: "Retrieve Page Figure Nodes",
      description: "Whether to retrieve page figure nodes.",
      default: false,
    },
    query: {
      type: "string",
      minLength: 1,
      title: "Query",
      description: "The query to retrieve against.",
    },
    class_name: {
      type: "string",
      title: "Class Name",
      default: "base_component",
    },
  },
  type: "object",
  required: ["query"],
  title: "RetrievalParams",
  description: "Schema for the search params for an retrieval execution.",
} as const;

export const RetrieveResultsSchema = {
  properties: {
    pipeline_id: {
      type: "string",
      format: "uuid",
      title: "Pipeline Id",
      description:
        "The ID of the pipeline that the query was retrieved against.",
    },
    retrieval_nodes: {
      items: {
        $ref: "#/components/schemas/TextNodeWithScore",
      },
      type: "array",
      title: "Retrieval Nodes",
      description: "The nodes retrieved by the pipeline for the given query.",
    },
    image_nodes: {
      items: {
        $ref: "#/components/schemas/PageScreenshotNodeWithScore",
      },
      type: "array",
      title: "Image Nodes",
      description:
        "The image nodes retrieved by the pipeline for the given query. Deprecated - will soon be replaced with 'page_screenshot_nodes'.",
      deprecated: true,
    },
    page_figure_nodes: {
      items: {
        $ref: "#/components/schemas/PageFigureNodeWithScore",
      },
      type: "array",
      title: "Page Figure Nodes",
      description:
        "The page figure nodes retrieved by the pipeline for the given query.",
    },
    retrieval_latency: {
      additionalProperties: {
        type: "number",
      },
      type: "object",
      title: "Retrieval Latency",
      description: "The end-to-end latency for retrieval and reranking.",
    },
    metadata: {
      additionalProperties: {
        type: "string",
      },
      type: "object",
      title: "Metadata",
      description: "Metadata associated with the retrieval execution",
    },
    inferred_search_filters: {
      anyOf: [
        {
          $ref: "#/components/schemas/MetadataFilters",
        },
        {
          type: "null",
        },
      ],
      description: "The inferred search filters for the query.",
    },
    class_name: {
      type: "string",
      title: "Class Name",
      default: "RetrieveResults",
    },
  },
  type: "object",
  required: ["pipeline_id", "retrieval_nodes"],
  title: "RetrieveResults",
  description: "Schema for the result of an retrieval execution.",
} as const;

export const RetrieverSchema = {
  properties: {
    name: {
      type: "string",
      maxLength: 3000,
      minLength: 1,
      title: "Name",
      description:
        "A name for the retriever tool. Will default to the pipeline name if not provided.",
    },
    pipelines: {
      items: {
        $ref: "#/components/schemas/RetrieverPipeline",
      },
      type: "array",
      title: "Pipelines",
      description: "The pipelines this retriever uses.",
    },
    id: {
      type: "string",
      format: "uuid",
      title: "Id",
      description: "Unique identifier",
    },
    created_at: {
      anyOf: [
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Created At",
      description: "Creation datetime",
    },
    updated_at: {
      anyOf: [
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Updated At",
      description: "Update datetime",
    },
    project_id: {
      type: "string",
      format: "uuid",
      title: "Project Id",
      description: "The ID of the project this retriever resides in.",
    },
  },
  type: "object",
  required: ["name", "id", "project_id"],
  title: "Retriever",
  description:
    "An entity that retrieves context nodes from several sub RetrieverTools.",
} as const;

export const RetrieverCreateSchema = {
  properties: {
    name: {
      type: "string",
      maxLength: 3000,
      minLength: 1,
      title: "Name",
      description:
        "A name for the retriever tool. Will default to the pipeline name if not provided.",
    },
    pipelines: {
      items: {
        $ref: "#/components/schemas/RetrieverPipeline",
      },
      type: "array",
      title: "Pipelines",
      description: "The pipelines this retriever uses.",
    },
  },
  type: "object",
  required: ["name"],
  title: "RetrieverCreate",
} as const;

export const RetrieverPipelineSchema = {
  properties: {
    name: {
      anyOf: [
        {
          type: "string",
          maxLength: 3000,
          minLength: 1,
        },
        {
          type: "null",
        },
      ],
      title: "Name",
      description:
        "A name for the retriever tool. Will default to the pipeline name if not provided.",
    },
    description: {
      anyOf: [
        {
          type: "string",
          maxLength: 15000,
        },
        {
          type: "null",
        },
      ],
      title: "Description",
      description: "A description of the retriever tool.",
    },
    pipeline_id: {
      type: "string",
      format: "uuid",
      title: "Pipeline Id",
      description: "The ID of the pipeline this tool uses.",
    },
    preset_retrieval_parameters: {
      $ref: "#/components/schemas/PresetRetrievalParams",
      description: "Parameters for retrieval configuration.",
    },
  },
  type: "object",
  required: ["name", "description", "pipeline_id"],
  title: "RetrieverPipeline",
} as const;

export const RetrieverUpdateSchema = {
  properties: {
    name: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Name",
      description: "A name for the retriever.",
    },
    pipelines: {
      anyOf: [
        {
          items: {
            $ref: "#/components/schemas/RetrieverPipeline",
          },
          type: "array",
        },
        {
          type: "null",
        },
      ],
      title: "Pipelines",
      description: "The pipelines this retriever uses.",
    },
  },
  type: "object",
  required: ["pipelines"],
  title: "RetrieverUpdate",
} as const;

export const RoleSchema = {
  properties: {
    id: {
      type: "string",
      format: "uuid",
      title: "Id",
      description: "Unique identifier",
    },
    created_at: {
      anyOf: [
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Created At",
      description: "Creation datetime",
    },
    updated_at: {
      anyOf: [
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Updated At",
      description: "Update datetime",
    },
    name: {
      type: "string",
      maxLength: 3000,
      minLength: 1,
      title: "Name",
      description: "A name for the role.",
    },
    permissions: {
      items: {
        $ref: "#/components/schemas/Permission",
      },
      type: "array",
      title: "Permissions",
      description: "The actual permissions of the role.",
    },
  },
  type: "object",
  required: ["id", "name", "permissions"],
  title: "Role",
  description: "Schema for a role.",
} as const;

export const SearchRequestSchema = {
  properties: {
    page_size: {
      anyOf: [
        {
          type: "integer",
        },
        {
          type: "null",
        },
      ],
      title: "Page Size",
      description:
        "The maximum number of items to return. The service may return fewer than this value. If unspecified, a default page size will be used. The maximum value is typically 1000; values above this will be coerced to the maximum.",
    },
    page_token: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Page Token",
      description:
        "A page token, received from a previous list call. Provide this to retrieve the subsequent page.",
    },
    filter: {
      anyOf: [
        {
          additionalProperties: {
            $ref: "#/components/schemas/FilterOperation",
          },
          type: "object",
        },
        {
          type: "null",
        },
      ],
      title: "Filter",
      description:
        "A filter object or expression that filters resources listed in the response.",
    },
    order_by: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Order By",
      description:
        "A comma-separated list of fields to order by, sorted in ascending order. Use 'field_name desc' to specify descending order.",
    },
    deployment_name: {
      type: "string",
      title: "Deployment Name",
      description: "The agent deployment's name to search within",
    },
    collection: {
      type: "string",
      title: "Collection",
      description: "The logical agent data collection to search within",
      default: "default",
    },
    include_total: {
      type: "boolean",
      title: "Include Total",
      description:
        "Whether to include the total number of items in the response",
      default: false,
    },
    offset: {
      anyOf: [
        {
          type: "integer",
          maximum: 1000,
          minimum: 0,
        },
        {
          type: "null",
        },
      ],
      title: "Offset",
      description:
        "The offset to start from. If not provided, the first page is returned",
      default: 0,
    },
  },
  type: "object",
  required: ["deployment_name"],
  title: "SearchRequest",
  description: "API request body for searching agent data",
} as const;

export const SemanticChunkingConfigSchema = {
  properties: {
    mode: {
      type: "string",
      const: "semantic",
      title: "Mode",
      default: "semantic",
    },
    buffer_size: {
      type: "integer",
      title: "Buffer Size",
      default: 1,
    },
    breakpoint_percentile_threshold: {
      type: "integer",
      title: "Breakpoint Percentile Threshold",
      default: 95,
    },
  },
  type: "object",
  title: "SemanticChunkingConfig",
} as const;

export const SentenceChunkingConfigSchema = {
  properties: {
    chunk_size: {
      type: "integer",
      exclusiveMinimum: 0,
      title: "Chunk Size",
      default: 1024,
    },
    chunk_overlap: {
      type: "integer",
      title: "Chunk Overlap",
      default: 200,
      gte: 0,
    },
    mode: {
      type: "string",
      const: "sentence",
      title: "Mode",
      default: "sentence",
    },
    separator: {
      type: "string",
      title: "Separator",
      default: " ",
    },
    paragraph_separator: {
      type: "string",
      title: "Paragraph Separator",
      default: `


`,
    },
  },
  type: "object",
  title: "SentenceChunkingConfig",
} as const;

export const SparseModelConfigSchema = {
  properties: {
    model_type: {
      $ref: "#/components/schemas/SparseModelType",
      description:
        "The sparse model type to use. 'auto' selects based on deployment mode (BYOC uses term frequency, Cloud uses Splade), 'splade' uses HuggingFace Splade model, 'bm25' uses Qdrant's FastEmbed BM25 model.",
      default: "auto",
    },
    class_name: {
      type: "string",
      title: "Class Name",
      default: "SparseModelConfig",
    },
  },
  type: "object",
  title: "SparseModelConfig",
  description: `Configuration for sparse embedding models used in hybrid search.

This allows users to choose between Splade and BM25 models for
sparse retrieval in managed data sinks.`,
} as const;

export const SparseModelTypeSchema = {
  type: "string",
  enum: ["splade", "bm25", "auto"],
  title: "SparseModelType",
  description: `Enum for sparse model types supported in LlamaCloud.

SPLADE: Uses HuggingFace Splade model for sparse embeddings
BM25: Uses Qdrant's FastEmbed BM25 model for sparse embeddings
AUTO: Automatically selects based on deployment mode (BYOC uses term frequency, Cloud uses Splade)`,
} as const;

export const SpreadsheetJobSchema = {
  properties: {
    id: {
      type: "string",
      title: "Id",
      description: "The ID of the job",
    },
    user_id: {
      type: "string",
      title: "User Id",
      description: "The ID of the user",
    },
    project_id: {
      type: "string",
      format: "uuid",
      title: "Project Id",
      description: "The ID of the project",
    },
    file_id: {
      type: "string",
      format: "uuid",
      title: "File Id",
      description: "The ID of the file to parse",
    },
    config: {
      $ref: "#/components/schemas/SpreadsheetParsingConfig",
      description: "Configuration for the parsing job",
    },
    status: {
      $ref: "#/components/schemas/StatusEnum",
      description: "The status of the parsing job",
    },
    created_at: {
      type: "string",
      title: "Created At",
      description: "When the job was created",
    },
    updated_at: {
      type: "string",
      title: "Updated At",
      description: "When the job was last updated",
    },
    success: {
      anyOf: [
        {
          type: "boolean",
        },
        {
          type: "null",
        },
      ],
      title: "Success",
      description: "Whether the job completed successfully",
    },
    tables: {
      items: {
        $ref: "#/components/schemas/ExtractedTable",
      },
      type: "array",
      title: "Tables",
      description: "All extracted tables (populated when job is complete)",
    },
    errors: {
      items: {
        type: "string",
      },
      type: "array",
      title: "Errors",
      description: "Any errors encountered",
    },
  },
  type: "object",
  required: [
    "id",
    "user_id",
    "project_id",
    "file_id",
    "config",
    "status",
    "created_at",
    "updated_at",
  ],
  title: "SpreadsheetJob",
  description: "A spreadsheet parsing job",
} as const;

export const SpreadsheetJobCreateSchema = {
  properties: {
    file_id: {
      type: "string",
      format: "uuid",
      title: "File Id",
      description: "The ID of the file to parse",
    },
    config: {
      $ref: "#/components/schemas/SpreadsheetParsingConfig",
      description: "Configuration for the parsing job",
    },
  },
  type: "object",
  required: ["file_id"],
  title: "SpreadsheetJobCreate",
  description: "Request to create a spreadsheet parsing job",
} as const;

export const SpreadsheetParsingConfigSchema = {
  properties: {
    sheet_names: {
      anyOf: [
        {
          items: {
            type: "string",
          },
          type: "array",
        },
        {
          type: "null",
        },
      ],
      title: "Sheet Names",
      description:
        "The names of the sheets to parse. If empty, all sheets will be parsed.",
    },
  },
  type: "object",
  title: "SpreadsheetParsingConfig",
  description: "Configuration for spreadsheet parsing",
} as const;

export const StatusEnumSchema = {
  type: "string",
  enum: ["PENDING", "SUCCESS", "ERROR", "PARTIAL_SUCCESS", "CANCELLED"],
  title: "StatusEnum",
  description: "Enum for representing the status of a job",
} as const;

export const SupportedLLMModelSchema = {
  properties: {
    name: {
      type: "string",
      title: "Name",
      description: "The name of the supported LLM model.",
    },
    enabled: {
      type: "boolean",
      title: "Enabled",
      description: "Whether the LLM model is enabled for use in LlamaCloud.",
      default: true,
    },
    details: {
      $ref: "#/components/schemas/LLMModelData",
      description: "The details of the supported LLM model.",
    },
  },
  type: "object",
  required: ["name", "details"],
  title: "SupportedLLMModel",
  description: "Response Schema for a supported eval LLM model.",
} as const;

export const SupportedLLMModelNamesSchema = {
  type: "string",
  enum: [
    "GPT_4O",
    "GPT_4O_MINI",
    "GPT_4_1",
    "GPT_4_1_NANO",
    "GPT_4_1_MINI",
    "AZURE_OPENAI_GPT_4O",
    "AZURE_OPENAI_GPT_4O_MINI",
    "AZURE_OPENAI_GPT_4_1",
    "AZURE_OPENAI_GPT_4_1_MINI",
    "AZURE_OPENAI_GPT_4_1_NANO",
    "CLAUDE_3_5_SONNET",
    "BEDROCK_CLAUDE_3_5_SONNET_V1",
    "BEDROCK_CLAUDE_3_5_SONNET_V2",
    "VERTEX_AI_CLAUDE_3_5_SONNET_V2",
  ],
  title: "SupportedLLMModelNames",
} as const;

export const TextNodeSchema = {
  properties: {
    id_: {
      type: "string",
      title: "Id",
      description: "Unique ID of the node.",
    },
    embedding: {
      anyOf: [
        {
          items: {
            type: "number",
          },
          type: "array",
        },
        {
          type: "null",
        },
      ],
      title: "Embedding",
      description: "Embedding of the node.",
    },
    extra_info: {
      additionalProperties: true,
      type: "object",
      title: "Extra Info",
      description: "A flat dictionary of metadata fields",
    },
    excluded_embed_metadata_keys: {
      items: {
        type: "string",
      },
      type: "array",
      title: "Excluded Embed Metadata Keys",
      description:
        "Metadata keys that are excluded from text for the embed model.",
    },
    excluded_llm_metadata_keys: {
      items: {
        type: "string",
      },
      type: "array",
      title: "Excluded Llm Metadata Keys",
      description: "Metadata keys that are excluded from text for the LLM.",
    },
    relationships: {
      additionalProperties: {
        anyOf: [
          {
            $ref: "#/components/schemas/RelatedNodeInfo",
          },
          {
            items: {
              $ref: "#/components/schemas/RelatedNodeInfo",
            },
            type: "array",
          },
        ],
      },
      propertyNames: {
        $ref: "#/components/schemas/NodeRelationship",
      },
      type: "object",
      title: "Relationships",
      description: "A mapping of relationships to other node information.",
    },
    metadata_template: {
      type: "string",
      title: "Metadata Template",
      description:
        "Template for how metadata is formatted, with {key} and {value} placeholders.",
      default: "{key}: {value}",
    },
    metadata_seperator: {
      type: "string",
      title: "Metadata Seperator",
      description:
        "Separator between metadata fields when converting to string.",
      default: `
`,
    },
    text: {
      type: "string",
      title: "Text",
      description: "Text content of the node.",
      default: "",
    },
    mimetype: {
      type: "string",
      title: "Mimetype",
      description: "MIME type of the node content.",
      default: "text/plain",
    },
    start_char_idx: {
      anyOf: [
        {
          type: "integer",
        },
        {
          type: "null",
        },
      ],
      title: "Start Char Idx",
      description: "Start char index of the node.",
    },
    end_char_idx: {
      anyOf: [
        {
          type: "integer",
        },
        {
          type: "null",
        },
      ],
      title: "End Char Idx",
      description: "End char index of the node.",
    },
    text_template: {
      type: "string",
      title: "Text Template",
      description:
        "Template for how text is formatted, with {content} and {metadata_str} placeholders.",
      default: `{metadata_str}

{content}`,
    },
    class_name: {
      type: "string",
      title: "Class Name",
      default: "TextNode",
    },
  },
  type: "object",
  title: "TextNode",
  description: `Provided for backward compatibility.

Note: we keep the field with the typo "seperator" to maintain backward compatibility for
serialized objects.`,
} as const;

export const TextNodeWithScoreSchema = {
  properties: {
    node: {
      $ref: "#/components/schemas/TextNode",
    },
    score: {
      anyOf: [
        {
          type: "number",
        },
        {
          type: "null",
        },
      ],
      title: "Score",
    },
    class_name: {
      type: "string",
      title: "Class Name",
      default: "TextNodeWithScore",
    },
  },
  type: "object",
  required: ["node"],
  title: "TextNodeWithScore",
  description: `Same as NodeWithScore but type for node is a TextNode instead of BaseNode.
FastAPI doesn't accept abstract classes like BaseNode.`,
} as const;

export const TokenChunkingConfigSchema = {
  properties: {
    chunk_size: {
      type: "integer",
      exclusiveMinimum: 0,
      title: "Chunk Size",
      default: 1024,
    },
    chunk_overlap: {
      type: "integer",
      title: "Chunk Overlap",
      default: 200,
      gte: 0,
    },
    mode: {
      type: "string",
      const: "token",
      title: "Mode",
      default: "token",
    },
    separator: {
      type: "string",
      title: "Separator",
      default: " ",
    },
  },
  type: "object",
  title: "TokenChunkingConfig",
} as const;

export const UsageAndPlanSchema = {
  properties: {
    plan: {
      $ref: "#/components/schemas/BasePlan",
    },
    usage: {
      $ref: "#/components/schemas/UsageResponse",
    },
  },
  type: "object",
  required: ["plan", "usage"],
  title: "UsageAndPlan",
} as const;

export const UsageMetricResponseSchema = {
  properties: {
    feature_usage: {
      additionalProperties: true,
      type: "object",
      title: "Feature Usage",
    },
    day: {
      type: "string",
      title: "Day",
    },
    source: {
      type: "string",
      title: "Source",
    },
    job_id: {
      type: "string",
      title: "Job Id",
    },
  },
  type: "object",
  required: ["feature_usage", "day", "source", "job_id"],
  title: "UsageMetricResponse",
} as const;

export const UsageResponseSchema = {
  properties: {
    active_free_credits_usage: {
      items: {
        $ref: "#/components/schemas/FreeCreditsUsage",
      },
      type: "array",
      title: "Active Free Credits Usage",
      default: [],
    },
    total_users: {
      type: "integer",
      title: "Total Users",
      default: 0,
    },
    total_indexes: {
      type: "integer",
      title: "Total Indexes",
      default: 0,
    },
    total_indexed_pages: {
      type: "integer",
      title: "Total Indexed Pages",
      default: 0,
    },
    active_alerts: {
      items: {
        type: "string",
        enum: [
          "plan_spend_limit_exceeded",
          "plan_spend_limit_soft_alert",
          "configured_spend_limit_exceeded",
          "free_credits_exhausted",
          "internal_spending_alert",
          "has_spending_alert",
        ],
      },
      type: "array",
      title: "Active Alerts",
      default: [],
    },
    current_invoice_total_usd_cents: {
      anyOf: [
        {
          type: "integer",
        },
        {
          type: "null",
        },
      ],
      title: "Current Invoice Total Usd Cents",
    },
    total_extraction_agents: {
      type: "integer",
      title: "Total Extraction Agents",
      default: 0,
    },
  },
  type: "object",
  title: "UsageResponse",
  description: "Response model",
} as const;

export const UserSchema = {
  properties: {
    id: {
      type: "string",
      title: "Id",
    },
    email: {
      type: "string",
      format: "email",
      title: "Email",
    },
    last_login_provider: {
      type: "string",
      enum: ["oidc", "basic", "no_auth"],
      title: "Last Login Provider",
      description: "The last login provider.",
      default: "oidc",
    },
    name: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Name",
      description: "The user's name.",
    },
    first_name: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "First Name",
      description: "The user's first name.",
    },
    last_name: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Last Name",
      description: "The user's last name.",
    },
    claims: {
      $ref: "#/components/schemas/CustomClaims",
      description: "The user's custom claims.",
    },
    restrict: {
      anyOf: [
        {
          $ref: "#/components/schemas/Restrict",
        },
        {
          type: "null",
        },
      ],
      description: "The restrictions on the user.",
    },
    created_at: {
      anyOf: [
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Created At",
      description: "The user's creation date.",
    },
  },
  type: "object",
  required: ["id", "email"],
  title: "User",
} as const;

export const UserJobRecordSchema = {
  properties: {
    id: {
      type: "string",
      title: "Id",
      description: "The user id from who triggered the job",
    },
    name: {
      type: "string",
      title: "Name",
      description: "The name of the user",
    },
  },
  type: "object",
  required: ["id", "name"],
  title: "UserJobRecord",
} as const;

export const UserOrganizationSchema = {
  properties: {
    id: {
      type: "string",
      format: "uuid",
      title: "Id",
      description: "Unique identifier",
    },
    created_at: {
      anyOf: [
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Created At",
      description: "Creation datetime",
    },
    updated_at: {
      anyOf: [
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Updated At",
      description: "Update datetime",
    },
    email: {
      anyOf: [
        {
          type: "string",
          format: "email",
        },
        {
          type: "null",
        },
      ],
      title: "Email",
      description: "The user's email address.",
    },
    user_id: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "User Id",
      description: "The user's ID.",
    },
    organization_id: {
      type: "string",
      format: "uuid",
      title: "Organization Id",
      description: "The organization's ID.",
    },
    pending: {
      type: "boolean",
      title: "Pending",
      description: "Whether the user's membership is pending account signup.",
      default: true,
    },
    invited_by_user_id: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Invited By User Id",
      description:
        "The user ID of the user who added the user to the organization.",
    },
    invited_by_user_email: {
      anyOf: [
        {
          type: "string",
          format: "email",
        },
        {
          type: "null",
        },
      ],
      title: "Invited By User Email",
      description:
        "The email address of the user who added the user to the organization.",
    },
    roles: {
      items: {
        $ref: "#/components/schemas/UserOrganizationRole",
      },
      type: "array",
      title: "Roles",
      description: "The roles of the user in the organization.",
    },
  },
  type: "object",
  required: ["id", "organization_id", "roles"],
  title: "UserOrganization",
  description: "Schema for a user's membership to an organization.",
} as const;

export const UserOrganizationCreateSchema = {
  properties: {
    user_id: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "User Id",
      description: "The user's ID.",
    },
    email: {
      anyOf: [
        {
          type: "string",
          format: "email",
        },
        {
          type: "null",
        },
      ],
      title: "Email",
      description: "The user's email address.",
    },
    project_ids: {
      anyOf: [
        {
          items: {
            type: "string",
            format: "uuid",
          },
          type: "array",
        },
        {
          type: "null",
        },
      ],
      title: "Project Ids",
      description: "The project IDs to add the user to.",
    },
    role_id: {
      anyOf: [
        {
          type: "string",
          format: "uuid",
        },
        {
          type: "null",
        },
      ],
      title: "Role Id",
      description: "The role ID to assign to the user.",
    },
  },
  type: "object",
  required: ["project_ids"],
  title: "UserOrganizationCreate",
  description: "Schema for creating a user's membership to an organization.",
} as const;

export const UserOrganizationDeleteSchema = {
  properties: {
    user_id: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "User Id",
      description: "The user's ID.",
    },
    email: {
      anyOf: [
        {
          type: "string",
          format: "email",
        },
        {
          type: "null",
        },
      ],
      title: "Email",
      description: "The user's email address.",
    },
    project_id_list: {
      anyOf: [
        {
          items: {
            type: "string",
            format: "uuid",
          },
          type: "array",
        },
        {
          type: "null",
        },
      ],
      title: "Project Id List",
      description: "The project ids",
    },
  },
  type: "object",
  title: "UserOrganizationDelete",
  description: "Schema for deleting a user's membership to an organization.",
} as const;

export const UserOrganizationRoleSchema = {
  properties: {
    id: {
      type: "string",
      format: "uuid",
      title: "Id",
      description: "Unique identifier",
    },
    created_at: {
      anyOf: [
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Created At",
      description: "Creation datetime",
    },
    updated_at: {
      anyOf: [
        {
          type: "string",
          format: "date-time",
        },
        {
          type: "null",
        },
      ],
      title: "Updated At",
      description: "Update datetime",
    },
    user_id: {
      type: "string",
      title: "User Id",
      description: "The user's ID.",
    },
    organization_id: {
      type: "string",
      format: "uuid",
      title: "Organization Id",
      description: "The organization's ID.",
    },
    project_ids: {
      anyOf: [
        {
          items: {
            type: "string",
            format: "uuid",
          },
          type: "array",
        },
        {
          type: "null",
        },
      ],
      title: "Project Ids",
      description: "The project ID scope.",
    },
    role: {
      $ref: "#/components/schemas/Role",
      description: "The role.",
    },
  },
  type: "object",
  required: ["id", "user_id", "organization_id", "role"],
  title: "UserOrganizationRole",
  description: "Schema for a user's role in an organization.",
} as const;

export const UserOrganizationRoleCreateSchema = {
  properties: {
    user_id: {
      type: "string",
      title: "User Id",
      description: "The user's ID.",
    },
    organization_id: {
      type: "string",
      format: "uuid",
      title: "Organization Id",
      description: "The organization's ID.",
    },
    role_id: {
      type: "string",
      format: "uuid",
      title: "Role Id",
      description: "The role's ID.",
    },
  },
  type: "object",
  required: ["user_id", "organization_id", "role_id"],
  title: "UserOrganizationRoleCreate",
  description: "Schema for creating a user's role in an organization.",
} as const;

export const ValidationErrorSchema = {
  properties: {
    loc: {
      items: {
        anyOf: [
          {
            type: "string",
          },
          {
            type: "integer",
          },
        ],
      },
      type: "array",
      title: "Location",
    },
    msg: {
      type: "string",
      title: "Message",
    },
    type: {
      type: "string",
      title: "Error Type",
    },
  },
  type: "object",
  required: ["loc", "msg", "type"],
  title: "ValidationError",
} as const;

export const VertexAIEmbeddingConfigSchema = {
  properties: {
    type: {
      type: "string",
      const: "VERTEXAI_EMBEDDING",
      title: "Type",
      description: "Type of the embedding model.",
      default: "VERTEXAI_EMBEDDING",
    },
    component: {
      $ref: "#/components/schemas/VertexTextEmbedding",
      description: "Configuration for the VertexAI embedding model.",
    },
  },
  type: "object",
  title: "VertexAIEmbeddingConfig",
} as const;

export const VertexEmbeddingModeSchema = {
  type: "string",
  enum: ["default", "classification", "clustering", "similarity", "retrieval"],
  title: "VertexEmbeddingMode",
  description: `Copied from llama_index.embeddings.vertex.base.VertexEmbeddingMode
since importing llama_index.embeddings.vertex.base incurs a lot of memory usage.`,
} as const;

export const VertexTextEmbeddingSchema = {
  properties: {
    model_name: {
      type: "string",
      title: "Model Name",
      description: "The modelId of the VertexAI model to use.",
      default: "textembedding-gecko@003",
    },
    embed_batch_size: {
      type: "integer",
      maximum: 2048,
      exclusiveMinimum: 0,
      title: "Embed Batch Size",
      description: "The batch size for embedding calls.",
      default: 10,
    },
    num_workers: {
      anyOf: [
        {
          type: "integer",
        },
        {
          type: "null",
        },
      ],
      title: "Num Workers",
      description: "The number of workers to use for async embedding calls.",
    },
    location: {
      type: "string",
      title: "Location",
      description: "The default location to use when making API calls.",
    },
    project: {
      type: "string",
      title: "Project",
      description:
        "The default GCP project to use when making Vertex API calls.",
    },
    embed_mode: {
      $ref: "#/components/schemas/VertexEmbeddingMode",
      description: "The embedding mode to use.",
      default: "retrieval",
    },
    additional_kwargs: {
      additionalProperties: true,
      type: "object",
      title: "Additional Kwargs",
      description: "Additional kwargs for the Vertex.",
    },
    client_email: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Client Email",
      description: "The client email for the VertexAI credentials.",
    },
    token_uri: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Token Uri",
      description: "The token URI for the VertexAI credentials.",
    },
    private_key_id: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Private Key Id",
      description: "The private key ID for the VertexAI credentials.",
    },
    private_key: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Private Key",
      description: "The private key for the VertexAI credentials.",
    },
    class_name: {
      type: "string",
      title: "Class Name",
      default: "VertexTextEmbedding",
    },
  },
  type: "object",
  required: [
    "location",
    "project",
    "client_email",
    "token_uri",
    "private_key_id",
    "private_key",
  ],
  title: "VertexTextEmbedding",
} as const;

export const WebhookConfigurationSchema = {
  properties: {
    webhook_url: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Webhook Url",
      description: "The URL to send webhook notifications to.",
    },
    webhook_headers: {
      anyOf: [
        {
          additionalProperties: {
            type: "string",
          },
          type: "object",
        },
        {
          type: "null",
        },
      ],
      title: "Webhook Headers",
      description: "Custom HTTP headers to include with webhook requests.",
    },
    webhook_events: {
      anyOf: [
        {
          items: {
            type: "string",
            enum: [
              "extract.pending",
              "extract.success",
              "extract.error",
              "extract.partial_success",
              "extract.cancelled",
              "parse.pending",
              "parse.success",
              "parse.error",
              "parse.partial_success",
              "parse.cancelled",
              "unmapped_event",
            ],
          },
          type: "array",
        },
        {
          type: "null",
        },
      ],
      title: "Webhook Events",
      description: "List of event names to subscribe to",
    },
    webhook_output_format: {
      anyOf: [
        {
          type: "string",
        },
        {
          type: "null",
        },
      ],
      title: "Webhook Output Format",
      description:
        "The output format to use for the webhook. Defaults to string if none supplied. Currently supported values: string, json",
    },
  },
  type: "object",
  title: "WebhookConfiguration",
  description:
    "Allows the user to configure webhook options for notifications and callbacks.",
} as const;
