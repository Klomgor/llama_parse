// This file is auto-generated by @hey-api/openapi-ts

/**
 * Schema for an API Key.
 */
export type ApiKey = {
  /**
   * Unique identifier
   */
  id: string;
  /**
   * Creation datetime
   */
  created_at?: string | null;
  /**
   * Update datetime
   */
  updated_at?: string | null;
  name?: string | null;
  project_id?: string | null;
  key_type?: ApiKeyType;
  user_id: string;
  redacted_api_key: string;
};

/**
 * Schema for creating an API key.
 */
export type ApiKeyCreate = {
  name?: string | null;
  /**
   * The project ID to associate with the API key.
   */
  project_id?: string | null;
  key_type?: ApiKeyType;
};

/**
 * Response schema for paginated API key queries.
 */
export type ApiKeyQueryResponse = {
  /**
   * The list of items.
   */
  items: Array<ApiKey>;
  /**
   * A token, which can be sent as page_token to retrieve the next page. If this field is omitted, there are no subsequent pages.
   */
  next_page_token?: string | null;
  /**
   * The total number of items available. This is only populated when specifically requested. The value may be an estimate and can be used for display purposes only.
   */
  total_size?: number | null;
};

export type ApiKeyType = "user" | "agent";

export const ApiKeyType = {
  USER: "user",
  AGENT: "agent",
} as const;

export type AdvancedModeTransformConfig = {
  mode?: "advanced";
  /**
   * Configuration for the segmentation.
   */
  segmentation_config?:
    | NoneSegmentationConfig
    | PageSegmentationConfig
    | ElementSegmentationConfig;
  /**
   * Configuration for the chunking.
   */
  chunking_config?:
    | NoneChunkingConfig
    | CharacterChunkingConfig
    | TokenChunkingConfig
    | SentenceChunkingConfig
    | SemanticChunkingConfig;
};

/**
 * API Result for a single agent data item
 */
export type AgentData = {
  id?: string | null;
  deployment_name: string;
  collection?: string;
  data: {
    [key: string]: unknown;
  };
  created_at?: string | null;
  updated_at?: string | null;
};

/**
 * API request model for creating agent data
 */
export type AgentDataCreate = {
  deployment_name: string;
  collection?: string;
  data: {
    [key: string]: unknown;
  };
};

/**
 * API request model for updating agent data
 */
export type AgentDataUpdate = {
  data: {
    [key: string]: unknown;
  };
};

export type AgentDeploymentList = {
  /**
   * List of deployments
   */
  deployments: Array<AgentDeploymentSummary>;
};

export type AgentDeploymentSummary = {
  /**
   * Deployment ID. Prefixed with dpl-
   */
  id: string;
  /**
   * Project ID
   */
  project_id: string;
  /**
   * Identifier of the deployed app
   */
  deployment_name: string;
  /**
   * Thumbnail URL of the deployed app
   */
  thumbnail_url?: string | null;
  /**
   * Base URL of the deployed app
   */
  base_url: string;
  /**
   * Timestamp when the app deployment was created
   */
  created_at: string;
  /**
   * Timestamp when the app deployment was last updated
   */
  updated_at: string;
  /**
   * API key ID
   */
  api_key_id?: string | null;
};

/**
 * API Result for a single group in the aggregate response
 */
export type AggregateGroup = {
  group_key: {
    [key: string]: unknown;
  };
  count?: number | null;
  first_item?: {
    [key: string]: unknown;
  } | null;
};

/**
 * API request body for aggregating agent data
 */
export type AggregateRequest = {
  /**
   * The maximum number of items to return. The service may return fewer than this value. If unspecified, a default page size will be used. The maximum value is typically 1000; values above this will be coerced to the maximum.
   */
  page_size?: number | null;
  /**
   * A page token, received from a previous list call. Provide this to retrieve the subsequent page.
   */
  page_token?: string | null;
  /**
   * A filter object or expression that filters resources listed in the response.
   */
  filter?: {
    [key: string]: FilterOperation;
  } | null;
  /**
   * A comma-separated list of fields to order by, sorted in ascending order. Use 'field_name desc' to specify descending order.
   */
  order_by?: string | null;
  /**
   * The agent deployment's name to aggregate data for
   */
  deployment_name: string;
  /**
   * The logical agent data collection to aggregate data for
   */
  collection?: string;
  /**
   * The fields to group by. If empty, the entire dataset is grouped on. e.g. if left out, can be used for simple count operations
   */
  group_by?: Array<string> | null;
  /**
   * Whether to count the number of items in each group
   */
  count?: boolean | null;
  /**
   * Whether to return the first item in each group (Sorted by created_at)
   */
  first?: boolean | null;
  /**
   * The offset to start from. If not provided, the first page is returned
   */
  offset?: number | null;
};

/**
 * This is the input schema for the chat app endpoint
 */
export type AppChatInputParams = {
  messages?: Array<InputMessage>;
};

export type AutoTransformConfig = {
  mode?: "auto";
  /**
   * Chunk size for the transformation.
   */
  chunk_size?: number;
  /**
   * Chunk overlap for the transformation.
   */
  chunk_overlap?: number;
};

export type AzureOpenAiEmbedding = {
  /**
   * The name of the OpenAI embedding model.
   */
  model_name?: string;
  /**
   * The batch size for embedding calls.
   */
  embed_batch_size?: number;
  /**
   * The number of workers to use for async embedding calls.
   */
  num_workers?: number | null;
  /**
   * Additional kwargs for the OpenAI API.
   */
  additional_kwargs?: {
    [key: string]: unknown;
  };
  /**
   * The OpenAI API key.
   */
  api_key?: string | null;
  /**
   * The base URL for Azure deployment.
   */
  api_base?: string;
  /**
   * The version for Azure OpenAI API.
   */
  api_version?: string;
  /**
   * Maximum number of retries.
   */
  max_retries?: number;
  /**
   * Timeout for each request.
   */
  timeout?: number;
  /**
   * The default headers for API requests.
   */
  default_headers?: {
    [key: string]: string;
  } | null;
  /**
   * Reuse the OpenAI client between requests. When doing anything with large volumes of async API calls, setting this to false can improve stability.
   */
  reuse_client?: boolean;
  /**
   * The number of dimensions on the output embedding vectors. Works only with v3 embedding models.
   */
  dimensions?: number | null;
  /**
   * The Azure endpoint to use.
   */
  azure_endpoint?: string | null;
  /**
   * The Azure deployment to use.
   */
  azure_deployment?: string | null;
  class_name?: string;
};

export type AzureOpenAiEmbeddingConfig = {
  /**
   * Type of the embedding model.
   */
  type?: "AZURE_EMBEDDING";
  /**
   * Configuration for the Azure OpenAI embedding model.
   */
  component?: AzureOpenAiEmbedding;
};

/**
 * Base response model for connection validation.
 */
export type BaseConnectionValidation = {
  success: boolean;
  message: string;
};

export type BasePlan = {
  /**
   * The ID of the plan in Metronome
   */
  id?: string | null;
  name:
    | "free"
    | "llama_parse"
    | "enterprise"
    | "unknown"
    | "free_contract"
    | "pro"
    | "enterprise_contract"
    | "enterprise_poc"
    | "free_v1"
    | "starter_v1"
    | "pro_v1";
  metronome_plan_type: "plan" | "contract";
  metronome_rate_card_alias: string | null;
  limits: PlanLimits;
  recurring_credits?: Array<RecurringCreditGrant> | null;
  plan_frequency: "MONTHLY" | "QUARTERLY" | "ANNUAL";
  /**
   * The ID of the customer in Metronome
   */
  metronome_customer_id?: string | null;
  /**
   * The date the plan starts on
   */
  starting_on?: string | null;
  /**
   * The date the plan ends on
   */
  ending_before?: string | null;
  /**
   * The current billing period
   */
  current_billing_period?: BillingPeriod | null;
  /**
   * Whether the organization has a failed payment that requires support contact
   */
  is_payment_failed?: boolean;
  /**
   * The number of payment failures for this organization
   */
  failure_count?: number;
};

export type Batch = {
  /**
   * The tool to be used for all requests in the batch.
   */
  tool: string;
  /**
   * The data to be used for the tool.
   */
  tool_data?: LlamaParseParameters | null;
  /**
   * The type of input file. Currently only 'datasource' is supported.
   */
  input_type: string;
  /**
   * The ID of the input file for the batch.
   */
  input_id: string;
  /**
   * The type of output file. Currently only 'datasource' is supported.
   */
  output_type?: string | null;
  /**
   * The ID of the output file for the batch.
   */
  output_id?: string | null;
  /**
   * Unique identifier for the batch
   */
  id: string;
  /**
   * The ID of the project to which the batch belongs
   */
  project_id: string;
  /**
   * The ID of the organization to which the batch belongs
   */
  organization_id: string;
  /**
   * The ID of the user who created the batch
   */
  user_id: string;
  /**
   * A developer-provided ID for the batch. This ID will be returned in the response.
   */
  external_id?: string | null;
  /**
   * The time frame within which the batch should be processed
   */
  completion_window: number;
  /**
   * The ID of the pipeline to which the batch belongs
   */
  pipeline_id: string;
  /**
   * The current status of the batch
   */
  status: string;
  /**
   * The Unix timestamp (in seconds) for when the batch was created
   */
  created_at?: string | null;
  /**
   * The Unix timestamp (in seconds) for when the batch was last updated
   */
  updated_at?: string | null;
};

export type BatchCreate = {
  /**
   * The tool to be used for all requests in the batch.
   */
  tool: string;
  /**
   * The data to be used for the tool.
   */
  tool_data?: LlamaParseParameters | null;
  /**
   * The type of input file. Currently only 'datasource' is supported.
   */
  input_type: string;
  /**
   * The ID of the input file for the batch.
   */
  input_id: string;
  /**
   * The type of output file. Currently only 'datasource' is supported.
   */
  output_type?: string | null;
  /**
   * The ID of the output file for the batch.
   */
  output_id?: string | null;
  /**
   * The ID of the project to which the batch belongs
   */
  project_id: string;
  /**
   * A developer-provided ID for the batch. This ID will be returned in the response.
   */
  external_id: string;
  /**
   * The time frame within which the batch should be processed. Currently only 24h is supported.
   */
  completion_window?: number;
};

export type BatchItem = {
  /**
   * Unique identifier for the batch item
   */
  id: string;
  /**
   * The ID of the batch to which the item belongs
   */
  batch_id: string;
  /**
   * The current status of the batch item
   */
  status: string;
  /**
   * The Unix timestamp (in seconds) for when the batch item status was last updated
   */
  status_updated_at?: string | null;
  /**
   * The Unix timestamp (in seconds) for when the batch item was created
   */
  created_at?: string | null;
  /**
   * The Unix timestamp (in seconds) for when the batch item was last updated
   */
  updated_at?: string | null;
  /**
   * The input file associated with the batch item
   */
  input_file: string;
  /**
   * The output file associated with the batch item
   */
  output_file?: string | null;
  /**
   * Worker Task for that item
   */
  task?: FileParsePublic | null;
};

export type BatchPaginatedList = {
  /**
   * List of batches
   */
  data: Array<Batch>;
  /**
   * Pagination limit
   */
  limit: number;
  /**
   * Pagination offset
   */
  offset: number;
  /**
   * Total number of batches
   */
  total_count: number;
};

export type BatchPublicOutput = {
  batch: Batch;
  batch_items: Array<BatchItem>;
  ingestion_status: ManagedIngestionStatusResponse;
};

export type BedrockEmbedding = {
  /**
   * The modelId of the Bedrock model to use.
   */
  model_name?: string;
  /**
   * The batch size for embedding calls.
   */
  embed_batch_size?: number;
  /**
   * The number of workers to use for async embedding calls.
   */
  num_workers?: number | null;
  /**
   * The name of aws profile to use. If not given, then the default profile is used.
   */
  profile_name?: string | null;
  /**
   * AWS Access Key ID to use
   */
  aws_access_key_id?: string | null;
  /**
   * AWS Secret Access Key to use
   */
  aws_secret_access_key?: string | null;
  /**
   * AWS Session Token to use
   */
  aws_session_token?: string | null;
  /**
   * AWS region name to use. Uses region configured in AWS CLI if not passed
   */
  region_name?: string | null;
  /**
   * The maximum number of API retries.
   */
  max_retries?: number;
  /**
   * The timeout for the Bedrock API request in seconds. It will be used for both connect and read timeouts.
   */
  timeout?: number;
  /**
   * Additional kwargs for the bedrock client.
   */
  additional_kwargs?: {
    [key: string]: unknown;
  };
  class_name?: string;
};

export type BedrockEmbeddingConfig = {
  /**
   * Type of the embedding model.
   */
  type?: "BEDROCK_EMBEDDING";
  /**
   * Configuration for the Bedrock embedding model.
   */
  component?: BedrockEmbedding;
};

export type BillingPeriod = {
  start_date: string;
  end_date: string;
};

export type BodyImportPipelineMetadataApiV1PipelinesPipelineIdMetadataPut = {
  upload_file: Blob | File;
};

export type BodyRunJobOnFileApiV1ExtractionJobsFilePost = {
  /**
   * The id of the extraction agent
   */
  extraction_agent_id: string;
  /**
   * The file to run the job on
   */
  file: Blob | File;
  /**
   * The data schema to override the extraction agent's data schema with as a JSON string
   */
  data_schema_override?: string | null;
  /**
   * The config to override the extraction agent's config with as a JSON string
   */
  config_override?: string | null;
};

export type BodyRunJobTestUserApiV1ExtractionJobsTestPost = {
  job_create: ExtractJobCreate;
  extract_settings?: LlamaExtractSettings | null;
};

export type BodyScreenshotApiParsingScreenshotPost = {
  file?: (Blob | File) | null;
  do_not_cache?: boolean;
  http_proxy?: string;
  input_s3_path?: string;
  input_s3_region?: string;
  input_url?: string;
  invalidate_cache?: boolean;
  max_pages?: number | null;
  output_s3_path_prefix?: string;
  output_s3_region?: string;
  target_pages?: string;
  webhook_url?: string;
  webhook_configurations?: string;
  job_timeout_in_seconds?: number;
  job_timeout_extra_time_per_page_in_seconds?: number;
};

export type BodyScreenshotApiV1ParsingScreenshotPost = {
  file?: (Blob | File) | null;
  do_not_cache?: boolean;
  http_proxy?: string;
  input_s3_path?: string;
  input_s3_region?: string;
  input_url?: string;
  invalidate_cache?: boolean;
  max_pages?: number | null;
  output_s3_path_prefix?: string;
  output_s3_region?: string;
  target_pages?: string;
  webhook_url?: string;
  webhook_configurations?: string;
  job_timeout_in_seconds?: number;
  job_timeout_extra_time_per_page_in_seconds?: number;
};

export type BodyUploadFileApiParsingUploadPost = {
  file?: (Blob | File) | null;
  adaptive_long_table?: boolean;
  annotate_links?: boolean;
  auto_mode?: boolean;
  auto_mode_trigger_on_image_in_page?: boolean;
  auto_mode_trigger_on_table_in_page?: boolean;
  auto_mode_trigger_on_text_in_page?: string;
  auto_mode_trigger_on_regexp_in_page?: string;
  auto_mode_configuration_json?: string;
  azure_openai_api_version?: string;
  azure_openai_deployment_name?: string;
  azure_openai_endpoint?: string;
  azure_openai_key?: string;
  bbox_bottom?: number;
  bbox_left?: number;
  bbox_right?: number;
  bbox_top?: number;
  compact_markdown_table?: boolean;
  disable_ocr?: boolean;
  disable_reconstruction?: boolean;
  disable_image_extraction?: boolean;
  do_not_cache?: boolean;
  do_not_unroll_columns?: boolean;
  extract_charts?: boolean;
  guess_xlsx_sheet_name?: boolean;
  high_res_ocr?: boolean;
  html_make_all_elements_visible?: boolean;
  layout_aware?: boolean;
  specialized_chart_parsing_agentic?: boolean;
  specialized_chart_parsing_plus?: boolean;
  specialized_chart_parsing_efficient?: boolean;
  specialized_image_parsing?: boolean;
  precise_bounding_box?: boolean;
  html_remove_fixed_elements?: boolean;
  html_remove_navigation_elements?: boolean;
  http_proxy?: string;
  input_s3_path?: string;
  input_s3_region?: string;
  input_url?: string;
  invalidate_cache?: boolean;
  language?: Array<ParserLanguages>;
  extract_layout?: boolean;
  max_pages?: number | null;
  merge_tables_across_pages_in_markdown?: boolean;
  outlined_table_extraction?: boolean;
  output_pdf_of_document?: boolean;
  output_s3_path_prefix?: string;
  output_s3_region?: string;
  page_prefix?: string;
  page_separator?: string;
  page_suffix?: string;
  preserve_layout_alignment_across_pages?: boolean;
  preserve_very_small_text?: boolean;
  skip_diagonal_text?: boolean;
  spreadsheet_extract_sub_tables?: boolean;
  spreadsheet_force_formula_computation?: boolean;
  inline_images_in_markdown?: boolean;
  structured_output?: boolean;
  structured_output_json_schema?: string;
  structured_output_json_schema_name?: string;
  take_screenshot?: boolean;
  target_pages?: string;
  vendor_multimodal_api_key?: string;
  vendor_multimodal_model_name?: string;
  model?: string;
  webhook_url?: string;
  webhook_configurations?: string;
  preset?: string;
  parse_mode?: ParsingMode | null;
  page_error_tolerance?: number;
  replace_failed_page_mode?: FailPageMode | null;
  replace_failed_page_with_error_message_prefix?: string;
  replace_failed_page_with_error_message_suffix?: string;
  system_prompt?: string;
  system_prompt_append?: string;
  user_prompt?: string;
  job_timeout_in_seconds?: number;
  job_timeout_extra_time_per_page_in_seconds?: number;
  strict_mode_image_extraction?: boolean;
  strict_mode_image_ocr?: boolean;
  strict_mode_reconstruction?: boolean;
  strict_mode_buggy_font?: boolean;
  save_images?: boolean;
  ignore_document_elements_for_layout_detection?: boolean;
  output_tables_as_HTML?: boolean;
  markdown_table_multiline_header_separator?: string;
  use_vendor_multimodal_model?: boolean;
  bounding_box?: string;
  gpt4o_mode?: boolean;
  gpt4o_api_key?: string;
  complemental_formatting_instruction?: string;
  content_guideline_instruction?: string;
  premium_mode?: boolean;
  is_formatting_instruction?: boolean;
  continuous_mode?: boolean;
  parsing_instruction?: string;
  fast_mode?: boolean;
  formatting_instruction?: string;
  hide_headers?: boolean;
  hide_footers?: boolean;
  page_header_prefix?: string;
  page_header_suffix?: string;
  page_footer_prefix?: string;
  page_footer_suffix?: string;
};

export type BodyUploadFileApiV1FilesPost = {
  upload_file: Blob | File;
};

export type BodyUploadFileApiV1ParsingUploadPost = {
  file?: (Blob | File) | null;
  adaptive_long_table?: boolean;
  annotate_links?: boolean;
  auto_mode?: boolean;
  auto_mode_trigger_on_image_in_page?: boolean;
  auto_mode_trigger_on_table_in_page?: boolean;
  auto_mode_trigger_on_text_in_page?: string;
  auto_mode_trigger_on_regexp_in_page?: string;
  auto_mode_configuration_json?: string;
  azure_openai_api_version?: string;
  azure_openai_deployment_name?: string;
  azure_openai_endpoint?: string;
  azure_openai_key?: string;
  bbox_bottom?: number;
  bbox_left?: number;
  bbox_right?: number;
  bbox_top?: number;
  compact_markdown_table?: boolean;
  disable_ocr?: boolean;
  disable_reconstruction?: boolean;
  disable_image_extraction?: boolean;
  do_not_cache?: boolean;
  do_not_unroll_columns?: boolean;
  extract_charts?: boolean;
  guess_xlsx_sheet_name?: boolean;
  high_res_ocr?: boolean;
  html_make_all_elements_visible?: boolean;
  layout_aware?: boolean;
  specialized_chart_parsing_agentic?: boolean;
  specialized_chart_parsing_plus?: boolean;
  specialized_chart_parsing_efficient?: boolean;
  specialized_image_parsing?: boolean;
  precise_bounding_box?: boolean;
  html_remove_fixed_elements?: boolean;
  html_remove_navigation_elements?: boolean;
  http_proxy?: string;
  input_s3_path?: string;
  input_s3_region?: string;
  input_url?: string;
  invalidate_cache?: boolean;
  language?: Array<ParserLanguages>;
  extract_layout?: boolean;
  max_pages?: number | null;
  merge_tables_across_pages_in_markdown?: boolean;
  outlined_table_extraction?: boolean;
  output_pdf_of_document?: boolean;
  output_s3_path_prefix?: string;
  output_s3_region?: string;
  page_prefix?: string;
  page_separator?: string;
  page_suffix?: string;
  preserve_layout_alignment_across_pages?: boolean;
  preserve_very_small_text?: boolean;
  skip_diagonal_text?: boolean;
  spreadsheet_extract_sub_tables?: boolean;
  spreadsheet_force_formula_computation?: boolean;
  inline_images_in_markdown?: boolean;
  structured_output?: boolean;
  structured_output_json_schema?: string;
  structured_output_json_schema_name?: string;
  take_screenshot?: boolean;
  target_pages?: string;
  vendor_multimodal_api_key?: string;
  vendor_multimodal_model_name?: string;
  model?: string;
  webhook_url?: string;
  webhook_configurations?: string;
  preset?: string;
  parse_mode?: ParsingMode | null;
  page_error_tolerance?: number;
  replace_failed_page_mode?: FailPageMode | null;
  replace_failed_page_with_error_message_prefix?: string;
  replace_failed_page_with_error_message_suffix?: string;
  system_prompt?: string;
  system_prompt_append?: string;
  user_prompt?: string;
  job_timeout_in_seconds?: number;
  job_timeout_extra_time_per_page_in_seconds?: number;
  strict_mode_image_extraction?: boolean;
  strict_mode_image_ocr?: boolean;
  strict_mode_reconstruction?: boolean;
  strict_mode_buggy_font?: boolean;
  save_images?: boolean;
  ignore_document_elements_for_layout_detection?: boolean;
  output_tables_as_HTML?: boolean;
  markdown_table_multiline_header_separator?: string;
  use_vendor_multimodal_model?: boolean;
  bounding_box?: string;
  gpt4o_mode?: boolean;
  gpt4o_api_key?: string;
  complemental_formatting_instruction?: string;
  content_guideline_instruction?: string;
  premium_mode?: boolean;
  is_formatting_instruction?: boolean;
  continuous_mode?: boolean;
  parsing_instruction?: string;
  fast_mode?: boolean;
  formatting_instruction?: string;
  hide_headers?: boolean;
  hide_footers?: boolean;
  page_header_prefix?: string;
  page_header_suffix?: string;
  page_footer_prefix?: string;
  page_footer_suffix?: string;
};

export type BodyUploadFileV2ApiV2Alpha1ParseUploadPost = {
  configuration: string;
  file?: (Blob | File) | null;
};

export type BoxAuthMechanism = "developer_token" | "ccg";

export const BoxAuthMechanism = {
  DEVELOPER_TOKEN: "developer_token",
  CCG: "ccg",
} as const;

export type CharacterChunkingConfig = {
  chunk_size?: number;
  chunk_overlap?: number;
  mode?: "character";
};

/**
 * Schema for a chat app
 */
export type ChatApp = {
  /**
   * Unique identifier
   */
  id: string;
  /**
   * Creation datetime
   */
  created_at?: string | null;
  /**
   * Update datetime
   */
  updated_at?: string | null;
  /**
   * Name of the chat app
   */
  name: string;
  /**
   * ID of the retriever to use for the chat app
   */
  retriever_id: string;
  /**
   * Configuration for the LLM model to use for the chat app
   */
  llm_config: LlmParameters;
  /**
   * Configuration for the retrieval model to use for the chat app
   */
  retrieval_config: PresetCompositeRetrievalParams;
  /**
   * ID of the project the chat app belongs to
   */
  project_id: string;
};

/**
 * Schema for creating a new chat app
 */
export type ChatAppCreate = {
  /**
   * Name of the chat app
   */
  name: string;
  /**
   * ID of the retriever to use for the chat app
   */
  retriever_id: string;
  /**
   * Configuration for the LLM model to use for the chat app
   */
  llm_config: LlmParameters;
  /**
   * Configuration for the retrieval model to use for the chat app
   */
  retrieval_config: PresetCompositeRetrievalParams;
};

export type ChatAppResponse = {
  /**
   * Unique identifier
   */
  id: string;
  /**
   * Creation datetime
   */
  created_at?: string | null;
  /**
   * Update datetime
   */
  updated_at?: string | null;
  /**
   * Name of the chat app
   */
  name: string;
  /**
   * ID of the retriever to use for the chat app
   */
  retriever_id: string;
  /**
   * Configuration for the LLM model to use for the chat app
   */
  llm_config: LlmParameters;
  /**
   * Configuration for the retrieval model to use for the chat app
   */
  retrieval_config: PresetCompositeRetrievalParams;
  /**
   * ID of the project the chat app belongs to
   */
  project_id: string;
  retriever_name: string;
};

/**
 * Schema for updating a chat app
 */
export type ChatAppUpdate = {
  name?: string | null;
  llm_config?: LlmParameters | null;
  retrieval_config?: PresetCompositeRetrievalParams | null;
};

export type ChatData = {
  retrieval_parameters?: PresetRetrievalParams;
  llm_parameters?: LlmParameters | null;
  class_name?: string;
};

export type ChatInputParams = {
  messages?: Array<InputMessage>;
  data?: ChatData;
  class_name?: string;
};

export type ChatMessage = {
  id: string;
  /**
   * The index of the message in the chat.
   */
  index: number;
  /**
   * Retrieval annotations for the message.
   */
  annotations?: Array<MessageAnnotation>;
  /**
   * The role of the message.
   */
  role: MessageRole;
  /**
   * Text content of the generation
   */
  content?: string | null;
  /**
   * Additional arguments passed to the model
   */
  additional_kwargs?: {
    [key: string]: string;
  };
  class_name?: string;
};

export type ChunkMode = "PAGE" | "DOCUMENT" | "SECTION" | "GROUPED_PAGES";

export const ChunkMode = {
  PAGE: "PAGE",
  DOCUMENT: "DOCUMENT",
  SECTION: "SECTION",
  GROUPED_PAGES: "GROUPED_PAGES",
} as const;

/**
 * Result of classifying a single file.
 */
export type ClassificationResult = {
  /**
   * Step-by-step explanation of why this classification was chosen and the confidence score assigned
   */
  reasoning: string;
  /**
   * Confidence score of the classification (0.0-1.0)
   */
  confidence: number;
  /**
   * The document type that best matches, or null if no match.
   */
  type: string | null;
};

/**
 * A rule for classifying documents - v0 simplified version.
 *
 * This represents a single classification rule that will be applied to documents.
 * All rules are content-based and use natural language descriptions.
 */
export type ClassifierRule = {
  /**
   * The document type to assign when this rule matches (e.g., 'invoice', 'receipt', 'contract')
   */
  type: string;
  /**
   * Natural language description of what to classify. Be specific about the content characteristics that identify this document type.
   */
  description: string;
};

/**
 * A classify job.
 */
export type ClassifyJob = {
  /**
   * Unique identifier
   */
  id: string;
  /**
   * Creation datetime
   */
  created_at?: string | null;
  /**
   * Update datetime
   */
  updated_at?: string | null;
  /**
   * The rules to classify the files
   */
  rules: Array<ClassifierRule>;
  /**
   * The ID of the user
   */
  user_id: string;
  /**
   * The ID of the project
   */
  project_id: string;
  /**
   * The status of the classify job
   */
  status: StatusEnum;
  /**
   * The configuration for the parsing job
   */
  parsing_configuration?: ClassifyParsingConfiguration;
};

/**
 * A classify job.
 */
export type ClassifyJobCreate = {
  /**
   * The rules to classify the files
   */
  rules: Array<ClassifierRule>;
  /**
   * The IDs of the files to classify
   */
  file_ids: Array<string>;
  /**
   * The configuration for the parsing job
   */
  parsing_configuration?: ClassifyParsingConfiguration;
};

/**
 * Response model for the classify endpoint following AIP-132 pagination standard.
 */
export type ClassifyJobResults = {
  /**
   * The list of items.
   */
  items: Array<FileClassification>;
  /**
   * A token, which can be sent as page_token to retrieve the next page. If this field is omitted, there are no subsequent pages.
   */
  next_page_token?: string | null;
  /**
   * The total number of items available. This is only populated when specifically requested. The value may be an estimate and can be used for display purposes only.
   */
  total_size?: number | null;
};

/**
 * Parsing configuration for a classify job.
 */
export type ClassifyParsingConfiguration = {
  /**
   * The language to parse the files in
   */
  lang?: ParserLanguages;
  /**
   * The maximum number of pages to parse
   */
  max_pages?: number | null;
  /**
   * The pages to target for parsing (0-indexed, so first page is at 0)
   */
  target_pages?: Array<number> | null;
};

/**
 * Cloud AstraDB Vector Store.
 *
 * This class is used to store the configuration for an AstraDB vector store, so that it can be
 * created and used in LlamaCloud.
 *
 * Args:
 * token (str): The Astra DB Application Token to use.
 * api_endpoint (str): The Astra DB JSON API endpoint for your database.
 * collection_name (str): Collection name to use. If not existing, it will be created.
 * embedding_dimension (int): Length of the embedding vectors in use.
 * keyspace (optional[str]): The keyspace to use. If not provided, 'default_keyspace'
 */
export type CloudAstraDbVectorStoreReadable = {
  supports_nested_metadata_filters?: true;
  /**
   * The Astra DB JSON API endpoint for your database
   */
  api_endpoint: string;
  /**
   * Collection name to use. If not existing, it will be created
   */
  collection_name: string;
  /**
   * Length of the embedding vectors in use
   */
  embedding_dimension: number;
  /**
   * The keyspace to use. If not provided, 'default_keyspace'
   */
  keyspace?: string | null;
  class_name?: string;
};

/**
 * Cloud AstraDB Vector Store.
 *
 * This class is used to store the configuration for an AstraDB vector store, so that it can be
 * created and used in LlamaCloud.
 *
 * Args:
 * token (str): The Astra DB Application Token to use.
 * api_endpoint (str): The Astra DB JSON API endpoint for your database.
 * collection_name (str): Collection name to use. If not existing, it will be created.
 * embedding_dimension (int): Length of the embedding vectors in use.
 * keyspace (optional[str]): The keyspace to use. If not provided, 'default_keyspace'
 */
export type CloudAstraDbVectorStoreWritable = {
  supports_nested_metadata_filters?: true;
  /**
   * The Astra DB Application Token to use
   */
  token: string;
  /**
   * The Astra DB JSON API endpoint for your database
   */
  api_endpoint: string;
  /**
   * Collection name to use. If not existing, it will be created
   */
  collection_name: string;
  /**
   * Length of the embedding vectors in use
   */
  embedding_dimension: number;
  /**
   * The keyspace to use. If not provided, 'default_keyspace'
   */
  keyspace?: string | null;
  class_name?: string;
};

export type CloudAzStorageBlobDataSourceReadable = {
  supports_access_control?: boolean;
  /**
   * The name of the Azure Storage Blob container to read from.
   */
  container_name: string;
  /**
   * The Azure Storage Blob account URL to use for authentication.
   */
  account_url: string;
  /**
   * The blob name to read from.
   */
  blob?: string | null;
  /**
   * The prefix of the Azure Storage Blob objects to read from.
   */
  prefix?: string | null;
  /**
   * The Azure Storage Blob account name to use for authentication.
   */
  account_name?: string | null;
  /**
   * The Azure Storage Blob account key to use for authentication.
   */
  account_key?: string | null;
  /**
   * The Azure AD tenant ID to use for authentication.
   */
  tenant_id?: string | null;
  /**
   * The Azure AD client ID to use for authentication.
   */
  client_id?: string | null;
  /**
   * The Azure AD client secret to use for authentication.
   */
  client_secret?: string | null;
  class_name?: string;
};

export type CloudAzStorageBlobDataSourceWritable = {
  supports_access_control?: boolean;
  /**
   * The name of the Azure Storage Blob container to read from.
   */
  container_name: string;
  /**
   * The Azure Storage Blob account URL to use for authentication.
   */
  account_url: string;
  /**
   * The blob name to read from.
   */
  blob?: string | null;
  /**
   * The prefix of the Azure Storage Blob objects to read from.
   */
  prefix?: string | null;
  /**
   * The Azure Storage Blob account name to use for authentication.
   */
  account_name?: string | null;
  /**
   * The Azure Storage Blob account key to use for authentication.
   */
  account_key?: string | null;
  /**
   * The Azure AD tenant ID to use for authentication.
   */
  tenant_id?: string | null;
  /**
   * The Azure AD client ID to use for authentication.
   */
  client_id?: string | null;
  /**
   * The Azure AD client secret to use for authentication.
   */
  client_secret?: string | null;
  class_name?: string;
};

/**
 * Cloud Azure AI Search Vector Store.
 */
export type CloudAzureAiSearchVectorStoreReadable = {
  supports_nested_metadata_filters?: true;
  search_service_endpoint: string;
  search_service_api_version?: string | null;
  index_name?: string | null;
  filterable_metadata_field_keys?: {
    [key: string]: unknown;
  } | null;
  embedding_dimension?: number | null;
  client_id?: string | null;
  client_secret?: string | null;
  tenant_id?: string | null;
  class_name?: string;
};

/**
 * Cloud Azure AI Search Vector Store.
 */
export type CloudAzureAiSearchVectorStoreWritable = {
  supports_nested_metadata_filters?: true;
  search_service_api_key: string;
  search_service_endpoint: string;
  search_service_api_version?: string | null;
  index_name?: string | null;
  filterable_metadata_field_keys?: {
    [key: string]: unknown;
  } | null;
  embedding_dimension?: number | null;
  client_id?: string | null;
  client_secret?: string | null;
  tenant_id?: string | null;
  class_name?: string;
};

export type CloudBoxDataSourceReadable = {
  supports_access_control?: boolean;
  /**
   * The ID of the Box folder to read from.
   */
  folder_id?: string | null;
  /**
   * The type of authentication to use (Developer Token or CCG)
   */
  authentication_mechanism: BoxAuthMechanism;
  /**
   * Developer token for authentication if authentication_mechanism is 'developer_token'.
   */
  developer_token?: string | null;
  /**
   * Box API key used for identifying the application the user is authenticating with
   */
  client_id?: string | null;
  /**
   * Box API secret used for making auth requests.
   */
  client_secret?: string | null;
  /**
   * Box User ID, if provided authenticates as user.
   */
  user_id?: string | null;
  /**
   * Box Enterprise ID, if provided authenticates as service.
   */
  enterprise_id?: string | null;
  class_name?: string;
};

export type CloudBoxDataSourceWritable = {
  supports_access_control?: boolean;
  /**
   * The ID of the Box folder to read from.
   */
  folder_id?: string | null;
  /**
   * The type of authentication to use (Developer Token or CCG)
   */
  authentication_mechanism: BoxAuthMechanism;
  /**
   * Developer token for authentication if authentication_mechanism is 'developer_token'.
   */
  developer_token?: string | null;
  /**
   * Box API key used for identifying the application the user is authenticating with
   */
  client_id?: string | null;
  /**
   * Box API secret used for making auth requests.
   */
  client_secret?: string | null;
  /**
   * Box User ID, if provided authenticates as user.
   */
  user_id?: string | null;
  /**
   * Box Enterprise ID, if provided authenticates as service.
   */
  enterprise_id?: string | null;
  class_name?: string;
};

export type CloudConfluenceDataSourceReadable = {
  supports_access_control?: boolean;
  /**
   * The server URL of the Confluence instance.
   */
  server_url: string;
  /**
   * Type of Authentication for connecting to Confluence APIs.
   */
  authentication_mechanism: string;
  /**
   * The username to use for authentication.
   */
  user_name?: string | null;
  /**
   * The API token to use for authentication.
   */
  api_token?: string | null;
  /**
   * The space key to read from.
   */
  space_key?: string | null;
  /**
   * The page IDs of the Confluence to read from.
   */
  page_ids?: string | null;
  /**
   * The CQL query to use for fetching pages.
   */
  cql?: string | null;
  /**
   * The label to use for fetching pages.
   */
  label?: string | null;
  /**
   * Whether to index restricted pages.
   */
  index_restricted_pages?: boolean;
  /**
   * Whether to keep the markdown format.
   */
  keep_markdown_format?: boolean;
  /**
   * Configuration for handling failures during processing. Key-value object controlling failure handling behaviors.
   *
   * Example:
   * {
   * "skip_list_failures": true
   * }
   *
   * Currently supports:
   * - skip_list_failures: Skip failed batches/lists and continue processing
   */
  failure_handling?: FailureHandlingConfig;
  class_name?: string;
};

export type CloudConfluenceDataSourceWritable = {
  supports_access_control?: boolean;
  /**
   * The server URL of the Confluence instance.
   */
  server_url: string;
  /**
   * Type of Authentication for connecting to Confluence APIs.
   */
  authentication_mechanism: string;
  /**
   * The username to use for authentication.
   */
  user_name?: string | null;
  /**
   * The API token to use for authentication.
   */
  api_token?: string | null;
  /**
   * The space key to read from.
   */
  space_key?: string | null;
  /**
   * The page IDs of the Confluence to read from.
   */
  page_ids?: string | null;
  /**
   * The CQL query to use for fetching pages.
   */
  cql?: string | null;
  /**
   * The label to use for fetching pages.
   */
  label?: string | null;
  /**
   * Whether to index restricted pages.
   */
  index_restricted_pages?: boolean;
  /**
   * Whether to keep the markdown format.
   */
  keep_markdown_format?: boolean;
  /**
   * Configuration for handling failures during processing. Key-value object controlling failure handling behaviors.
   *
   * Example:
   * {
   * "skip_list_failures": true
   * }
   *
   * Currently supports:
   * - skip_list_failures: Skip failed batches/lists and continue processing
   */
  failure_handling?: FailureHandlingConfig;
  class_name?: string;
};

/**
 * Cloud document stored in S3.
 */
export type CloudDocument = {
  text: string;
  metadata: {
    [key: string]: unknown;
  };
  excluded_embed_metadata_keys?: Array<string>;
  excluded_llm_metadata_keys?: Array<string>;
  /**
   * indices in the CloudDocument.text where a new page begins. e.g. Second page starts at index specified by page_positions[1].
   */
  page_positions?: Array<number> | null;
  id: string;
};

/**
 * Create a new cloud document.
 */
export type CloudDocumentCreate = {
  text: string;
  metadata: {
    [key: string]: unknown;
  };
  excluded_embed_metadata_keys?: Array<string>;
  excluded_llm_metadata_keys?: Array<string>;
  /**
   * indices in the CloudDocument.text where a new page begins. e.g. Second page starts at index specified by page_positions[1].
   */
  page_positions?: Array<number> | null;
  id?: string | null;
};

/**
 * Cloud Jira Data Source integrating JiraReader.
 */
export type CloudJiraDataSourceReadable = {
  supports_access_control?: boolean;
  /**
   * The email address to use for authentication.
   */
  email?: string | null;
  /**
   * The API/ Access Token used for Basic, PAT and OAuth2 authentication.
   */
  api_token?: string | null;
  /**
   * The server url for Jira Cloud.
   */
  server_url?: string | null;
  /**
   * The cloud ID, used in case of OAuth2.
   */
  cloud_id?: string | null;
  /**
   * Type of Authentication for connecting to Jira APIs.
   */
  authentication_mechanism: string;
  /**
   * JQL (Jira Query Language) query to search.
   */
  query: string;
  class_name?: string;
};

/**
 * Cloud Jira Data Source integrating JiraReader.
 */
export type CloudJiraDataSourceWritable = {
  supports_access_control?: boolean;
  /**
   * The email address to use for authentication.
   */
  email?: string | null;
  /**
   * The API/ Access Token used for Basic, PAT and OAuth2 authentication.
   */
  api_token?: string | null;
  /**
   * The server url for Jira Cloud.
   */
  server_url?: string | null;
  /**
   * The cloud ID, used in case of OAuth2.
   */
  cloud_id?: string | null;
  /**
   * Type of Authentication for connecting to Jira APIs.
   */
  authentication_mechanism: string;
  /**
   * JQL (Jira Query Language) query to search.
   */
  query: string;
  class_name?: string;
};

/**
 * Cloud Jira Data Source integrating JiraReaderV2.
 */
export type CloudJiraDataSourceV2Readable = {
  supports_access_control?: boolean;
  /**
   * The email address to use for authentication.
   */
  email?: string | null;
  /**
   * The API Access Token used for Basic, PAT and OAuth2 authentication.
   */
  api_token?: string | null;
  /**
   * The server url for Jira Cloud.
   */
  server_url: string;
  /**
   * The cloud ID, used in case of OAuth2.
   */
  cloud_id?: string | null;
  /**
   * Type of Authentication for connecting to Jira APIs.
   */
  authentication_mechanism: string;
  /**
   * Jira REST API version to use (2 or 3). 3 supports Atlassian Document Format (ADF).
   */
  api_version?: "2" | "3";
  /**
   * JQL (Jira Query Language) query to search.
   */
  query: string;
  /**
   * List of fields to retrieve from Jira. If None, retrieves all fields.
   */
  fields?: Array<string> | null;
  /**
   * Fields to expand in the response.
   */
  expand?: string | null;
  /**
   * Rate limit for Jira API requests per minute.
   */
  requests_per_minute?: number | null;
  /**
   * Whether to fetch project role permissions and issue-level security
   */
  get_permissions?: boolean;
  class_name?: string;
};

/**
 * Cloud Jira Data Source integrating JiraReaderV2.
 */
export type CloudJiraDataSourceV2Writable = {
  supports_access_control?: boolean;
  /**
   * The email address to use for authentication.
   */
  email?: string | null;
  /**
   * The API Access Token used for Basic, PAT and OAuth2 authentication.
   */
  api_token?: string | null;
  /**
   * The server url for Jira Cloud.
   */
  server_url: string;
  /**
   * The cloud ID, used in case of OAuth2.
   */
  cloud_id?: string | null;
  /**
   * Type of Authentication for connecting to Jira APIs.
   */
  authentication_mechanism: string;
  /**
   * Jira REST API version to use (2 or 3). 3 supports Atlassian Document Format (ADF).
   */
  api_version?: "2" | "3";
  /**
   * JQL (Jira Query Language) query to search.
   */
  query: string;
  /**
   * List of fields to retrieve from Jira. If None, retrieves all fields.
   */
  fields?: Array<string> | null;
  /**
   * Fields to expand in the response.
   */
  expand?: string | null;
  /**
   * Rate limit for Jira API requests per minute.
   */
  requests_per_minute?: number | null;
  /**
   * Whether to fetch project role permissions and issue-level security
   */
  get_permissions?: boolean;
  class_name?: string;
};

/**
 * Cloud Milvus Vector Store.
 */
export type CloudMilvusVectorStoreReadable = {
  supports_nested_metadata_filters?: boolean;
  uri: string;
  collection_name?: string | null;
  token?: string | null;
  embedding_dimension?: number | null;
  class_name?: string;
};

/**
 * Cloud Milvus Vector Store.
 */
export type CloudMilvusVectorStoreWritable = {
  supports_nested_metadata_filters?: boolean;
  uri: string;
  collection_name?: string | null;
  token?: string | null;
  embedding_dimension?: number | null;
  class_name?: string;
};

/**
 * Cloud MongoDB Atlas Vector Store.
 *
 * This class is used to store the configuration for a MongoDB Atlas vector store,
 * so that it can be created and used in LlamaCloud.
 *
 * Args:
 * mongodb_uri (str): URI for connecting to MongoDB Atlas
 * db_name (str): name of the MongoDB database
 * collection_name (str): name of the MongoDB collection
 * vector_index_name (str): name of the MongoDB Atlas vector index
 * fulltext_index_name (str): name of the MongoDB Atlas full-text index
 */
export type CloudMongoDbAtlasVectorSearchReadable = {
  supports_nested_metadata_filters?: boolean;
  db_name: string;
  collection_name: string;
  vector_index_name?: string | null;
  fulltext_index_name?: string | null;
  embedding_dimension?: number | null;
  class_name?: string;
};

/**
 * Cloud MongoDB Atlas Vector Store.
 *
 * This class is used to store the configuration for a MongoDB Atlas vector store,
 * so that it can be created and used in LlamaCloud.
 *
 * Args:
 * mongodb_uri (str): URI for connecting to MongoDB Atlas
 * db_name (str): name of the MongoDB database
 * collection_name (str): name of the MongoDB collection
 * vector_index_name (str): name of the MongoDB Atlas vector index
 * fulltext_index_name (str): name of the MongoDB Atlas full-text index
 */
export type CloudMongoDbAtlasVectorSearchWritable = {
  supports_nested_metadata_filters?: boolean;
  mongodb_uri: string;
  db_name: string;
  collection_name: string;
  vector_index_name?: string | null;
  fulltext_index_name?: string | null;
  embedding_dimension?: number | null;
  class_name?: string;
};

export type CloudNotionPageDataSourceReadable = {
  supports_access_control?: boolean;
  /**
   * The Notion Database Id to read content from.
   */
  database_ids?: string | null;
  /**
   * The Page ID's of the Notion to read from.
   */
  page_ids?: string | null;
  class_name?: string;
};

export type CloudNotionPageDataSourceWritable = {
  supports_access_control?: boolean;
  /**
   * The integration token to use for authentication.
   */
  integration_token: string;
  /**
   * The Notion Database Id to read content from.
   */
  database_ids?: string | null;
  /**
   * The Page ID's of the Notion to read from.
   */
  page_ids?: string | null;
  class_name?: string;
};

export type CloudOneDriveDataSourceReadable = {
  supports_access_control?: true;
  /**
   * The user principal name to use for authentication.
   */
  user_principal_name: string;
  /**
   * The path of the OneDrive folder to read from.
   */
  folder_path?: string | null;
  /**
   * The ID of the OneDrive folder to read from.
   */
  folder_id?: string | null;
  /**
   * The client ID to use for authentication.
   */
  client_id: string;
  /**
   * The tenant ID to use for authentication.
   */
  tenant_id: string;
  /**
   * The list of required file extensions.
   */
  required_exts?: Array<string> | null;
  class_name?: string;
};

export type CloudOneDriveDataSourceWritable = {
  supports_access_control?: true;
  /**
   * The user principal name to use for authentication.
   */
  user_principal_name: string;
  /**
   * The path of the OneDrive folder to read from.
   */
  folder_path?: string | null;
  /**
   * The ID of the OneDrive folder to read from.
   */
  folder_id?: string | null;
  /**
   * The client ID to use for authentication.
   */
  client_id: string;
  /**
   * The client secret to use for authentication.
   */
  client_secret: string;
  /**
   * The tenant ID to use for authentication.
   */
  tenant_id: string;
  /**
   * The list of required file extensions.
   */
  required_exts?: Array<string> | null;
  class_name?: string;
};

/**
 * Cloud Pinecone Vector Store.
 *
 * This class is used to store the configuration for a Pinecone vector store, so that it can be
 * created and used in LlamaCloud.
 *
 * Args:
 * api_key (str): API key for authenticating with Pinecone
 * index_name (str): name of the Pinecone index
 * namespace (optional[str]): namespace to use in the Pinecone index
 * insert_kwargs (optional[dict]): additional kwargs to pass during insertion
 */
export type CloudPineconeVectorStoreReadable = {
  supports_nested_metadata_filters?: true;
  index_name: string;
  namespace?: string | null;
  insert_kwargs?: {
    [key: string]: unknown;
  } | null;
  class_name?: string;
};

/**
 * Cloud Pinecone Vector Store.
 *
 * This class is used to store the configuration for a Pinecone vector store, so that it can be
 * created and used in LlamaCloud.
 *
 * Args:
 * api_key (str): API key for authenticating with Pinecone
 * index_name (str): name of the Pinecone index
 * namespace (optional[str]): namespace to use in the Pinecone index
 * insert_kwargs (optional[dict]): additional kwargs to pass during insertion
 */
export type CloudPineconeVectorStoreWritable = {
  supports_nested_metadata_filters?: true;
  /**
   * The API key for authenticating with Pinecone
   */
  api_key: string;
  index_name: string;
  namespace?: string | null;
  insert_kwargs?: {
    [key: string]: unknown;
  } | null;
  class_name?: string;
};

export type CloudPostgresVectorStoreReadable = {
  supports_nested_metadata_filters?: boolean;
  database: string;
  host: string;
  port: number;
  user: string;
  table_name: string;
  schema_name: string;
  embed_dim: number;
  hybrid_search?: boolean | null;
  perform_setup?: boolean;
  /**
   * HNSW settings for PGVector index. Set to null to disable HNSW indexing in favor of a brute force indexing/exact search strategy instead.
   */
  hnsw_settings?: PgVectorHnswSettings | null;
  class_name?: string;
};

export type CloudPostgresVectorStoreWritable = {
  supports_nested_metadata_filters?: boolean;
  database: string;
  host: string;
  password: string;
  port: number;
  user: string;
  table_name: string;
  schema_name: string;
  embed_dim: number;
  hybrid_search?: boolean | null;
  perform_setup?: boolean;
  /**
   * HNSW settings for PGVector index. Set to null to disable HNSW indexing in favor of a brute force indexing/exact search strategy instead.
   */
  hnsw_settings?: PgVectorHnswSettings | null;
  class_name?: string;
};

/**
 * Cloud Qdrant Vector Store.
 *
 * This class is used to store the configuration for a Qdrant vector store, so that it can be
 * created and used in LlamaCloud.
 *
 * Args:
 * collection_name (str): name of the Qdrant collection
 * url (str): url of the Qdrant instance
 * api_key (str): API key for authenticating with Qdrant
 * max_retries (int): maximum number of retries in case of a failure. Defaults to 3
 * client_kwargs (dict): additional kwargs to pass to the Qdrant client
 */
export type CloudQdrantVectorStoreReadable = {
  supports_nested_metadata_filters?: true;
  collection_name: string;
  url: string;
  max_retries?: number;
  client_kwargs?: {
    [key: string]: unknown;
  };
  class_name?: string;
};

/**
 * Cloud Qdrant Vector Store.
 *
 * This class is used to store the configuration for a Qdrant vector store, so that it can be
 * created and used in LlamaCloud.
 *
 * Args:
 * collection_name (str): name of the Qdrant collection
 * url (str): url of the Qdrant instance
 * api_key (str): API key for authenticating with Qdrant
 * max_retries (int): maximum number of retries in case of a failure. Defaults to 3
 * client_kwargs (dict): additional kwargs to pass to the Qdrant client
 */
export type CloudQdrantVectorStoreWritable = {
  supports_nested_metadata_filters?: true;
  collection_name: string;
  url: string;
  api_key: string;
  max_retries?: number;
  client_kwargs?: {
    [key: string]: unknown;
  };
  class_name?: string;
};

export type CloudS3DataSourceReadable = {
  supports_access_control?: boolean;
  /**
   * The name of the S3 bucket to read from.
   */
  bucket: string;
  /**
   * The prefix of the S3 objects to read from.
   */
  prefix?: string | null;
  /**
   * The regex pattern to filter S3 objects. Must be a valid regex pattern.
   */
  regex_pattern?: string | null;
  /**
   * The AWS access ID to use for authentication.
   */
  aws_access_id?: string | null;
  /**
   * The AWS access secret to use for authentication.
   */
  aws_access_secret?: string | null;
  /**
   * The S3 endpoint URL to use for authentication.
   */
  s3_endpoint_url?: string | null;
  class_name?: string;
};

export type CloudS3DataSourceWritable = {
  supports_access_control?: boolean;
  /**
   * The name of the S3 bucket to read from.
   */
  bucket: string;
  /**
   * The prefix of the S3 objects to read from.
   */
  prefix?: string | null;
  /**
   * The regex pattern to filter S3 objects. Must be a valid regex pattern.
   */
  regex_pattern?: string | null;
  /**
   * The AWS access ID to use for authentication.
   */
  aws_access_id?: string | null;
  /**
   * The AWS access secret to use for authentication.
   */
  aws_access_secret?: string | null;
  /**
   * The S3 endpoint URL to use for authentication.
   */
  s3_endpoint_url?: string | null;
  class_name?: string;
};

export type CloudSharepointDataSourceReadable = {
  supports_access_control?: true;
  /**
   * The name of the SharePoint site to download from.
   */
  site_name?: string | null;
  /**
   * The ID of the SharePoint site to download from.
   */
  site_id?: string | null;
  /**
   * The path of the Sharepoint folder to read from.
   */
  folder_path?: string | null;
  /**
   * The ID of the Sharepoint folder to read from.
   */
  folder_id?: string | null;
  /**
   * The name of the Sharepoint drive to read from.
   */
  drive_name?: string | null;
  /**
   * The client ID to use for authentication.
   */
  client_id: string;
  /**
   * The tenant ID to use for authentication.
   */
  tenant_id: string;
  /**
   * The list of required file extensions.
   */
  required_exts?: Array<string> | null;
  /**
   * Whether to get permissions for the sharepoint site.
   */
  get_permissions?: boolean | null;
  class_name?: string;
};

export type CloudSharepointDataSourceWritable = {
  supports_access_control?: true;
  /**
   * The name of the SharePoint site to download from.
   */
  site_name?: string | null;
  /**
   * The ID of the SharePoint site to download from.
   */
  site_id?: string | null;
  /**
   * The path of the Sharepoint folder to read from.
   */
  folder_path?: string | null;
  /**
   * The ID of the Sharepoint folder to read from.
   */
  folder_id?: string | null;
  /**
   * The name of the Sharepoint drive to read from.
   */
  drive_name?: string | null;
  /**
   * The client ID to use for authentication.
   */
  client_id: string;
  /**
   * The client secret to use for authentication.
   */
  client_secret: string;
  /**
   * The tenant ID to use for authentication.
   */
  tenant_id: string;
  /**
   * The list of required file extensions.
   */
  required_exts?: Array<string> | null;
  /**
   * Whether to get permissions for the sharepoint site.
   */
  get_permissions?: boolean | null;
  class_name?: string;
};

export type CloudSlackDataSourceReadable = {
  supports_access_control?: boolean;
  /**
   * Slack Channel.
   */
  channel_ids?: string | null;
  /**
   * Latest date.
   */
  latest_date?: string | null;
  /**
   * Earliest date.
   */
  earliest_date?: string | null;
  /**
   * Earliest date timestamp.
   */
  earliest_date_timestamp?: number | null;
  /**
   * Latest date timestamp.
   */
  latest_date_timestamp?: number | null;
  /**
   * Slack Channel name pattern.
   */
  channel_patterns?: string | null;
  class_name?: string;
};

export type CloudSlackDataSourceWritable = {
  supports_access_control?: boolean;
  /**
   * Slack Bot Token.
   */
  slack_token: string;
  /**
   * Slack Channel.
   */
  channel_ids?: string | null;
  /**
   * Latest date.
   */
  latest_date?: string | null;
  /**
   * Earliest date.
   */
  earliest_date?: string | null;
  /**
   * Earliest date timestamp.
   */
  earliest_date_timestamp?: number | null;
  /**
   * Latest date timestamp.
   */
  latest_date_timestamp?: number | null;
  /**
   * Slack Channel name pattern.
   */
  channel_patterns?: string | null;
  class_name?: string;
};

export type CohereEmbedding = {
  /**
   * The modelId of the Cohere model to use.
   */
  model_name?: string;
  /**
   * The batch size for embedding calls.
   */
  embed_batch_size?: number;
  /**
   * The number of workers to use for async embedding calls.
   */
  num_workers?: number | null;
  /**
   * The Cohere API key.
   */
  api_key: string | null;
  /**
   * Truncation type - START/ END/ NONE
   */
  truncate?: string;
  /**
   * Model Input type. If not provided, search_document and search_query are used when needed.
   */
  input_type?: string | null;
  /**
   * Embedding type. If not provided float embedding_type is used when needed.
   */
  embedding_type?: string;
  class_name?: string;
};

export type CohereEmbeddingConfig = {
  /**
   * Type of the embedding model.
   */
  type?: "COHERE_EMBEDDING";
  /**
   * Configuration for the Cohere embedding model.
   */
  component?: CohereEmbedding;
};

/**
 * Enum for the mode of composite retrieval.
 */
export type CompositeRetrievalMode = "routing" | "full";

/**
 * Enum for the mode of composite retrieval.
 */
export const CompositeRetrievalMode = {
  ROUTING: "routing",
  FULL: "full",
} as const;

export type CompositeRetrievalParams = {
  /**
   * The mode of composite retrieval.
   */
  mode?: CompositeRetrievalMode;
  /**
   * (use rerank_config.top_n instead) The number of nodes to retrieve after reranking over retrieved nodes from all retrieval tools.
   * @deprecated
   */
  rerank_top_n?: number | null;
  /**
   * The rerank configuration for composite retrieval.
   */
  rerank_config?: ReRankConfig;
  /**
   * The query to retrieve against.
   */
  query: string;
};

export type CompositeRetrievalResult = {
  /**
   * The retrieved nodes from the composite retrieval.
   */
  nodes?: Array<CompositeRetrievedTextNodeWithScore>;
  /**
   * The image nodes retrieved by the pipeline for the given query. Deprecated - will soon be replaced with 'page_screenshot_nodes'.
   * @deprecated
   */
  image_nodes?: Array<PageScreenshotNodeWithScore>;
  /**
   * The page figure nodes retrieved by the pipeline for the given query.
   */
  page_figure_nodes?: Array<PageFigureNodeWithScore>;
};

export type CompositeRetrievedTextNode = {
  /**
   * The ID of the retrieved node.
   */
  id: string;
  /**
   * The ID of the retriever this node was retrieved from.
   */
  retriever_id: string;
  /**
   * The name of the retrieval pipeline this node was retrieved from.
   */
  retriever_pipeline_name: string;
  /**
   * The ID of the pipeline this node was retrieved from.
   */
  pipeline_id: string;
  /**
   * Metadata associated with the retrieved node.
   */
  metadata?: {
    [key: string]: unknown;
  };
  /**
   * The text of the retrieved node.
   */
  text: string;
  /**
   * The start character index of the retrieved node in the document
   */
  start_char_idx: number | null;
  /**
   * The end character index of the retrieved node in the document
   */
  end_char_idx: number | null;
};

export type CompositeRetrievedTextNodeWithScore = {
  node: CompositeRetrievedTextNode;
  score?: number | null;
  class_name?: string;
};

export type ConfigurableDataSinkNames =
  | "PINECONE"
  | "POSTGRES"
  | "QDRANT"
  | "AZUREAI_SEARCH"
  | "MONGODB_ATLAS"
  | "MILVUS"
  | "ASTRA_DB";

export const ConfigurableDataSinkNames = {
  PINECONE: "PINECONE",
  POSTGRES: "POSTGRES",
  QDRANT: "QDRANT",
  AZUREAI_SEARCH: "AZUREAI_SEARCH",
  MONGODB_ATLAS: "MONGODB_ATLAS",
  MILVUS: "MILVUS",
  ASTRA_DB: "ASTRA_DB",
} as const;

export type ConfigurableDataSourceNames =
  | "S3"
  | "AZURE_STORAGE_BLOB"
  | "GOOGLE_DRIVE"
  | "MICROSOFT_ONEDRIVE"
  | "MICROSOFT_SHAREPOINT"
  | "SLACK"
  | "NOTION_PAGE"
  | "CONFLUENCE"
  | "JIRA"
  | "JIRA_V2"
  | "BOX";

export const ConfigurableDataSourceNames = {
  S3: "S3",
  AZURE_STORAGE_BLOB: "AZURE_STORAGE_BLOB",
  GOOGLE_DRIVE: "GOOGLE_DRIVE",
  MICROSOFT_ONEDRIVE: "MICROSOFT_ONEDRIVE",
  MICROSOFT_SHAREPOINT: "MICROSOFT_SHAREPOINT",
  SLACK: "SLACK",
  NOTION_PAGE: "NOTION_PAGE",
  CONFLUENCE: "CONFLUENCE",
  JIRA: "JIRA",
  JIRA_V2: "JIRA_V2",
  BOX: "BOX",
} as const;

export type CreateIntentAndCustomerSessionResponse = {
  client_secret: string;
  customer_session_client_secret: string | null;
};

export type CreditType = {
  id: string;
  name: string;
};

/**
 * Custom claims that dictate various limits or allowed behaviors.
 * Currently these claims reside at a per user level. Claims may expand to a per organization level or project in the future.
 */
export type CustomClaims = {
  /**
   * Whether the user is allowed to create organizations.
   */
  allowed_org_creation?: boolean;
  /**
   * The maximum number of jobs the user can have in execution per job type.
   */
  max_jobs_in_execution_per_job_type?: number;
  /**
   * The maximum number of document ingestion jobs the user can have in execution.
   */
  max_document_ingestion_jobs_in_execution?: number;
  /**
   * The maximum number of metadata update jobs the user can have in execution.
   */
  max_metadata_update_jobs_in_execution?: number;
  /**
   * Whether the user is a test user for extraction. This will include additional debug metadata and access to test endpoints.
   */
  extraction_test_user?: boolean;
  /**
   * Whether the user is allowed to access llama-report generation.
   */
  allowed_report?: boolean;
  /**
   * Whether the user is allowed to access the app.
   */
  allowed_app?: boolean;
  /**
   * Whether the user is allowed to access the classifier feature.
   */
  allowed_classify?: boolean;
  /**
   * Whether the user is allowed to access API data sources.
   */
  api_datasource_access?: boolean;
  /**
   * Whether the user is allowed to delete organizations.
   */
  allow_org_deletion?: boolean;
};

export type CustomerPortalSessionCreatePayload = {
  return_url: string;
};

/**
 * Schema for a data sink.
 */
export type DataSinkReadable = {
  /**
   * Unique identifier
   */
  id: string;
  /**
   * Creation datetime
   */
  created_at?: string | null;
  /**
   * Update datetime
   */
  updated_at?: string | null;
  /**
   * The name of the data sink.
   */
  name: string;
  sink_type: ConfigurableDataSinkNames;
  /**
   * Component that implements the data sink
   */
  component:
    | {
        [key: string]: unknown;
      }
    | CloudPineconeVectorStoreReadable
    | CloudPostgresVectorStoreReadable
    | CloudQdrantVectorStoreReadable
    | CloudAzureAiSearchVectorStoreReadable
    | CloudMongoDbAtlasVectorSearchReadable
    | CloudMilvusVectorStoreReadable
    | CloudAstraDbVectorStoreReadable;
  project_id: string;
};

/**
 * Schema for a data sink.
 */
export type DataSinkWritable = {
  /**
   * Unique identifier
   */
  id: string;
  /**
   * Creation datetime
   */
  created_at?: string | null;
  /**
   * Update datetime
   */
  updated_at?: string | null;
  /**
   * The name of the data sink.
   */
  name: string;
  sink_type: ConfigurableDataSinkNames;
  /**
   * Component that implements the data sink
   */
  component:
    | {
        [key: string]: unknown;
      }
    | CloudPineconeVectorStoreWritable
    | CloudPostgresVectorStoreWritable
    | CloudQdrantVectorStoreWritable
    | CloudAzureAiSearchVectorStoreWritable
    | CloudMongoDbAtlasVectorSearchWritable
    | CloudMilvusVectorStoreWritable
    | CloudAstraDbVectorStoreWritable;
  project_id: string;
};

/**
 * Schema for creating a data sink.
 */
export type DataSinkCreateReadable = {
  /**
   * The name of the data sink.
   */
  name: string;
  sink_type: ConfigurableDataSinkNames;
  /**
   * Component that implements the data sink
   */
  component:
    | {
        [key: string]: unknown;
      }
    | CloudPineconeVectorStoreReadable
    | CloudPostgresVectorStoreReadable
    | CloudQdrantVectorStoreReadable
    | CloudAzureAiSearchVectorStoreReadable
    | CloudMongoDbAtlasVectorSearchReadable
    | CloudMilvusVectorStoreReadable
    | CloudAstraDbVectorStoreReadable;
};

/**
 * Schema for creating a data sink.
 */
export type DataSinkCreateWritable = {
  /**
   * The name of the data sink.
   */
  name: string;
  sink_type: ConfigurableDataSinkNames;
  /**
   * Component that implements the data sink
   */
  component:
    | {
        [key: string]: unknown;
      }
    | CloudPineconeVectorStoreWritable
    | CloudPostgresVectorStoreWritable
    | CloudQdrantVectorStoreWritable
    | CloudAzureAiSearchVectorStoreWritable
    | CloudMongoDbAtlasVectorSearchWritable
    | CloudMilvusVectorStoreWritable
    | CloudAstraDbVectorStoreWritable;
};

/**
 * Schema for updating a data sink.
 */
export type DataSinkUpdateReadable = {
  /**
   * The name of the data sink.
   */
  name?: string | null;
  sink_type: ConfigurableDataSinkNames;
  /**
   * Component that implements the data sink
   */
  component?:
    | {
        [key: string]: unknown;
      }
    | CloudPineconeVectorStoreReadable
    | CloudPostgresVectorStoreReadable
    | CloudQdrantVectorStoreReadable
    | CloudAzureAiSearchVectorStoreReadable
    | CloudMongoDbAtlasVectorSearchReadable
    | CloudMilvusVectorStoreReadable
    | CloudAstraDbVectorStoreReadable
    | null;
};

/**
 * Schema for updating a data sink.
 */
export type DataSinkUpdateWritable = {
  /**
   * The name of the data sink.
   */
  name?: string | null;
  sink_type: ConfigurableDataSinkNames;
  /**
   * Component that implements the data sink
   */
  component?:
    | {
        [key: string]: unknown;
      }
    | CloudPineconeVectorStoreWritable
    | CloudPostgresVectorStoreWritable
    | CloudQdrantVectorStoreWritable
    | CloudAzureAiSearchVectorStoreWritable
    | CloudMongoDbAtlasVectorSearchWritable
    | CloudMilvusVectorStoreWritable
    | CloudAstraDbVectorStoreWritable
    | null;
};

/**
 * Schema for a data source.
 */
export type DataSourceReadable = {
  /**
   * Unique identifier
   */
  id: string;
  /**
   * Creation datetime
   */
  created_at?: string | null;
  /**
   * Update datetime
   */
  updated_at?: string | null;
  /**
   * The name of the data source.
   */
  name: string;
  source_type: ConfigurableDataSourceNames;
  /**
   * Custom metadata that will be present on all data loaded from the data source
   */
  custom_metadata?: {
    [key: string]:
      | {
          [key: string]: unknown;
        }
      | Array<unknown>
      | string
      | number
      | number
      | boolean
      | null;
  } | null;
  /**
   * Component that implements the data source
   */
  component:
    | {
        [key: string]: unknown;
      }
    | CloudS3DataSourceReadable
    | CloudAzStorageBlobDataSourceReadable
    | CloudOneDriveDataSourceReadable
    | CloudSharepointDataSourceReadable
    | CloudSlackDataSourceReadable
    | CloudNotionPageDataSourceReadable
    | CloudConfluenceDataSourceReadable
    | CloudJiraDataSourceReadable
    | CloudJiraDataSourceV2Readable
    | CloudBoxDataSourceReadable;
  /**
   * Version metadata for the data source
   */
  version_metadata?: DataSourceReaderVersionMetadata | null;
  project_id: string;
};

/**
 * Schema for a data source.
 */
export type DataSourceWritable = {
  /**
   * Unique identifier
   */
  id: string;
  /**
   * Creation datetime
   */
  created_at?: string | null;
  /**
   * Update datetime
   */
  updated_at?: string | null;
  /**
   * The name of the data source.
   */
  name: string;
  source_type: ConfigurableDataSourceNames;
  /**
   * Custom metadata that will be present on all data loaded from the data source
   */
  custom_metadata?: {
    [key: string]:
      | {
          [key: string]: unknown;
        }
      | Array<unknown>
      | string
      | number
      | number
      | boolean
      | null;
  } | null;
  /**
   * Component that implements the data source
   */
  component:
    | {
        [key: string]: unknown;
      }
    | CloudS3DataSourceWritable
    | CloudAzStorageBlobDataSourceWritable
    | CloudOneDriveDataSourceWritable
    | CloudSharepointDataSourceWritable
    | CloudSlackDataSourceWritable
    | CloudNotionPageDataSourceWritable
    | CloudConfluenceDataSourceWritable
    | CloudJiraDataSourceWritable
    | CloudJiraDataSourceV2Writable
    | CloudBoxDataSourceWritable;
  /**
   * Version metadata for the data source
   */
  version_metadata?: DataSourceReaderVersionMetadata | null;
  project_id: string;
};

/**
 * Schema for creating a data source.
 */
export type DataSourceCreateReadable = {
  /**
   * The name of the data source.
   */
  name: string;
  source_type: ConfigurableDataSourceNames;
  /**
   * Custom metadata that will be present on all data loaded from the data source
   */
  custom_metadata?: {
    [key: string]:
      | {
          [key: string]: unknown;
        }
      | Array<unknown>
      | string
      | number
      | number
      | boolean
      | null;
  } | null;
  /**
   * Component that implements the data source
   */
  component:
    | {
        [key: string]: unknown;
      }
    | CloudS3DataSourceReadable
    | CloudAzStorageBlobDataSourceReadable
    | CloudOneDriveDataSourceReadable
    | CloudSharepointDataSourceReadable
    | CloudSlackDataSourceReadable
    | CloudNotionPageDataSourceReadable
    | CloudConfluenceDataSourceReadable
    | CloudJiraDataSourceReadable
    | CloudJiraDataSourceV2Readable
    | CloudBoxDataSourceReadable;
};

/**
 * Schema for creating a data source.
 */
export type DataSourceCreateWritable = {
  /**
   * The name of the data source.
   */
  name: string;
  source_type: ConfigurableDataSourceNames;
  /**
   * Custom metadata that will be present on all data loaded from the data source
   */
  custom_metadata?: {
    [key: string]:
      | {
          [key: string]: unknown;
        }
      | Array<unknown>
      | string
      | number
      | number
      | boolean
      | null;
  } | null;
  /**
   * Component that implements the data source
   */
  component:
    | {
        [key: string]: unknown;
      }
    | CloudS3DataSourceWritable
    | CloudAzStorageBlobDataSourceWritable
    | CloudOneDriveDataSourceWritable
    | CloudSharepointDataSourceWritable
    | CloudSlackDataSourceWritable
    | CloudNotionPageDataSourceWritable
    | CloudConfluenceDataSourceWritable
    | CloudJiraDataSourceWritable
    | CloudJiraDataSourceV2Writable
    | CloudBoxDataSourceWritable;
};

export type DataSourceReaderVersionMetadata = {
  /**
   * The version of the reader to use for this data source.
   */
  reader_version?: ("1.0" | "2.0" | "2.1") | null;
};

/**
 * Schema for updating a data source.
 */
export type DataSourceUpdateReadable = {
  /**
   * The name of the data source.
   */
  name?: string | null;
  source_type: ConfigurableDataSourceNames;
  /**
   * Custom metadata that will be present on all data loaded from the data source
   */
  custom_metadata?: {
    [key: string]:
      | {
          [key: string]: unknown;
        }
      | Array<unknown>
      | string
      | number
      | number
      | boolean
      | null;
  } | null;
  /**
   * Component that implements the data source
   */
  component?:
    | {
        [key: string]: unknown;
      }
    | CloudS3DataSourceReadable
    | CloudAzStorageBlobDataSourceReadable
    | CloudOneDriveDataSourceReadable
    | CloudSharepointDataSourceReadable
    | CloudSlackDataSourceReadable
    | CloudNotionPageDataSourceReadable
    | CloudConfluenceDataSourceReadable
    | CloudJiraDataSourceReadable
    | CloudJiraDataSourceV2Readable
    | CloudBoxDataSourceReadable
    | null;
};

/**
 * Schema for updating a data source.
 */
export type DataSourceUpdateWritable = {
  /**
   * The name of the data source.
   */
  name?: string | null;
  source_type: ConfigurableDataSourceNames;
  /**
   * Custom metadata that will be present on all data loaded from the data source
   */
  custom_metadata?: {
    [key: string]:
      | {
          [key: string]: unknown;
        }
      | Array<unknown>
      | string
      | number
      | number
      | boolean
      | null;
  } | null;
  /**
   * Component that implements the data source
   */
  component?:
    | {
        [key: string]: unknown;
      }
    | CloudS3DataSourceWritable
    | CloudAzStorageBlobDataSourceWritable
    | CloudOneDriveDataSourceWritable
    | CloudSharepointDataSourceWritable
    | CloudSlackDataSourceWritable
    | CloudNotionPageDataSourceWritable
    | CloudConfluenceDataSourceWritable
    | CloudJiraDataSourceWritable
    | CloudJiraDataSourceV2Writable
    | CloudBoxDataSourceWritable
    | null;
};

/**
 * Schema for the parameters of a data source dispatcher job.
 */
export type DataSourceUpdateDispatcherConfig = {
  type?: "data_source_update_dispatcher";
  /**
   * Whether to delete the data source from the pipeline
   */
  should_delete?: boolean | null;
  /**
   * The custom metadata to attach to the data source.
   */
  custom_metadata?: {
    [key: string]: unknown;
  } | null;
  /**
   * The parameters for the delete job.
   */
  delete_info?: DeleteParams | null;
};

/**
 * Schema for updating the default organization for a user.
 */
export type DefaultOrganizationUpdate = {
  /**
   * The organization's ID.
   */
  organization_id: string;
};

/**
 * Schema for the parameters of a delete job.
 */
export type DeleteParams = {
  /**
   * The IDs for the documents to delete.
   */
  document_ids_to_delete?: Array<string> | null;
  /**
   * The IDs for the files to delete.
   */
  files_ids_to_delete?: Array<string> | null;
  /**
   * The IDs for the data sources to delete.
   */
  data_sources_ids_to_delete?: Array<string> | null;
  /**
   * The collection name to delete.
   */
  embed_collection_name?: string | null;
  /**
   * The ID for the data sink from which to delete data.
   */
  data_sink_id?: string | null;
};

export type DirectRetrievalParams = {
  /**
   * The mode of composite retrieval.
   */
  mode?: CompositeRetrievalMode;
  /**
   * (use rerank_config.top_n instead) The number of nodes to retrieve after reranking over retrieved nodes from all retrieval tools.
   * @deprecated
   */
  rerank_top_n?: number | null;
  /**
   * The rerank configuration for composite retrieval.
   */
  rerank_config?: ReRankConfig;
  /**
   * The query to retrieve against.
   */
  query: string;
  /**
   * The pipelines to use for retrieval.
   */
  pipelines?: Array<RetrieverPipeline>;
};

export type DocumentChunkMode = "PAGE" | "SECTION";

export const DocumentChunkMode = {
  PAGE: "PAGE",
  SECTION: "SECTION",
} as const;

/**
 * Schema for the parameters of a document ingestion job.
 */
export type DocumentIngestionJobParams = {
  /**
   * The custom metadata to attach to the documents.
   */
  custom_metadata?: {
    [key: string]: unknown;
  } | null;
  /**
   * The resource info about the file
   */
  resource_info?: {
    [key: string]: unknown;
  } | null;
  type?: "document_ingestion";
  /**
   * Whether to delete the documents
   */
  should_delete?: boolean | null;
  /**
   * The IDs for the Documents this execution ran against.
   */
  document_ids?: Array<string> | null;
  /**
   * The ID for the File this execution ran against.
   */
  pipeline_file_id?: string | null;
  /**
   * The parameters for the delete job.
   */
  delete_info?: DeleteParams | null;
  /**
   * Whether the file is new
   */
  is_new_file?: boolean;
  /**
   * The number of pages in the file. Only used if used llama-parse
   */
  page_count?: number | null;
};

export type ElementSegmentationConfig = {
  mode?: "element";
};

/**
 * Schema for an embedding model config.
 */
export type EmbeddingModelConfig = {
  /**
   * Unique identifier
   */
  id: string;
  /**
   * Creation datetime
   */
  created_at?: string | null;
  /**
   * Update datetime
   */
  updated_at?: string | null;
  /**
   * The name of the embedding model config.
   */
  name: string;
  /**
   * The embedding configuration for the embedding model config.
   */
  embedding_config:
    | ({
        type: "AZURE_EMBEDDING";
      } & AzureOpenAiEmbeddingConfig)
    | ({
        type: "COHERE_EMBEDDING";
      } & CohereEmbeddingConfig)
    | ({
        type: "GEMINI_EMBEDDING";
      } & GeminiEmbeddingConfig)
    | ({
        type: "HUGGINGFACE_API_EMBEDDING";
      } & HuggingFaceInferenceApiEmbeddingConfig)
    | ({
        type: "OPENAI_EMBEDDING";
      } & OpenAiEmbeddingConfig)
    | ({
        type: "VERTEXAI_EMBEDDING";
      } & VertexAiEmbeddingConfig)
    | ({
        type: "BEDROCK_EMBEDDING";
      } & BedrockEmbeddingConfig);
  project_id: string;
};

export type EmbeddingModelConfigCreate = {
  /**
   * The name of the embedding model config.
   */
  name: string;
  /**
   * The embedding configuration for the embedding model config.
   */
  embedding_config:
    | ({
        type: "AZURE_EMBEDDING";
      } & AzureOpenAiEmbeddingConfig)
    | ({
        type: "COHERE_EMBEDDING";
      } & CohereEmbeddingConfig)
    | ({
        type: "GEMINI_EMBEDDING";
      } & GeminiEmbeddingConfig)
    | ({
        type: "HUGGINGFACE_API_EMBEDDING";
      } & HuggingFaceInferenceApiEmbeddingConfig)
    | ({
        type: "OPENAI_EMBEDDING";
      } & OpenAiEmbeddingConfig)
    | ({
        type: "VERTEXAI_EMBEDDING";
      } & VertexAiEmbeddingConfig)
    | ({
        type: "BEDROCK_EMBEDDING";
      } & BedrockEmbeddingConfig);
};

export type EmbeddingModelConfigUpdate = {
  /**
   * The name of the embedding model config.
   */
  name?: string | null;
  /**
   * The embedding configuration for the embedding model config.
   */
  embedding_config?:
    | (
        | ({
            type: "AZURE_EMBEDDING";
          } & AzureOpenAiEmbeddingConfig)
        | ({
            type: "COHERE_EMBEDDING";
          } & CohereEmbeddingConfig)
        | ({
            type: "GEMINI_EMBEDDING";
          } & GeminiEmbeddingConfig)
        | ({
            type: "HUGGINGFACE_API_EMBEDDING";
          } & HuggingFaceInferenceApiEmbeddingConfig)
        | ({
            type: "OPENAI_EMBEDDING";
          } & OpenAiEmbeddingConfig)
        | ({
            type: "VERTEXAI_EMBEDDING";
          } & VertexAiEmbeddingConfig)
        | ({
            type: "BEDROCK_EMBEDDING";
          } & BedrockEmbeddingConfig)
      )
    | null;
};

/**
 * Schema for the params for an eval execution.
 */
export type EvalExecutionParams = {
  /**
   * The LLM model to use within eval execution.
   */
  llm_model?: SupportedLlmModelNames;
  /**
   * The template to use for the question answering prompt.
   */
  qa_prompt_tmpl?: string;
};

/**
 * Schema and configuration for creating an extraction agent.
 */
export type ExtractAgent = {
  /**
   * The id of the extraction agent.
   */
  id: string;
  /**
   * The name of the extraction agent.
   */
  name: string;
  /**
   * The ID of the project that the extraction agent belongs to.
   */
  project_id: string;
  /**
   * The schema of the data.
   */
  data_schema: {
    [key: string]:
      | {
          [key: string]: unknown;
        }
      | Array<unknown>
      | string
      | number
      | number
      | boolean
      | null;
  };
  /**
   * The configuration parameters for the extraction agent.
   */
  config: ExtractConfig;
  /**
   * Custom configuration type for the extraction agent. Currently supports 'default'.
   */
  custom_configuration?: "default" | null;
  /**
   * The creation time of the extraction agent.
   */
  created_at?: string | null;
  /**
   * The last update time of the extraction agent.
   */
  updated_at?: string | null;
};

/**
 * Settings for creating an extraction agent.
 */
export type ExtractAgentCreate = {
  /**
   * The name of the extraction schema
   */
  name: string;
  /**
   * The schema of the data.
   */
  data_schema:
    | {
        [key: string]:
          | {
              [key: string]: unknown;
            }
          | Array<unknown>
          | string
          | number
          | number
          | boolean
          | null;
      }
    | string;
  /**
   * The configuration parameters for the extraction agent.
   */
  config: ExtractConfig;
};

/**
 * Settings for updating an extraction schema.
 */
export type ExtractAgentUpdate = {
  /**
   * The schema of the data
   */
  data_schema:
    | {
        [key: string]:
          | {
              [key: string]: unknown;
            }
          | Array<unknown>
          | string
          | number
          | number
          | boolean
          | null;
      }
    | string;
  /**
   * The configuration parameters for the extraction agent.
   */
  config: ExtractConfig;
};

/**
 * Additional parameters for the extraction agent.
 */
export type ExtractConfig = {
  /**
   * The priority for the request. This field may be ignored or overwritten depending on the organization tier.
   */
  priority?: ("low" | "medium" | "high" | "critical") | null;
  /**
   * The extraction target specified.
   */
  extraction_target?: ExtractTarget;
  /**
   * The extraction mode specified (FAST, BALANCED, MULTIMODAL, PREMIUM).
   */
  extraction_mode?: ExtractMode;
  /**
   * The parse model to use for document parsing. If not provided, uses the default for the extraction mode.
   */
  parse_model?: PublicModelName | null;
  /**
   * The extract model to use for data extraction. If not provided, uses the default for the extraction mode.
   */
  extract_model?: ExtractModels | null;
  /**
   * DEPRECATED: Whether to use fast mode for multimodal extraction.
   */
  multimodal_fast_mode?: boolean;
  /**
   * The system prompt to use for the extraction.
   */
  system_prompt?: string | null;
  /**
   * Whether to use reasoning for the extraction.
   */
  use_reasoning?: boolean;
  /**
   * Whether to cite sources for the extraction.
   */
  cite_sources?: boolean;
  /**
   * Whether to fetch confidence scores for the extraction.
   */
  confidence_scores?: boolean;
  /**
   * The mode to use for chunking the document.
   */
  chunk_mode?: DocumentChunkMode;
  /**
   * Whether to use high resolution mode for the extraction.
   */
  high_resolution_mode?: boolean;
  /**
   * Whether to invalidate the cache for the extraction.
   */
  invalidate_cache?: boolean;
  /**
   * Comma-separated list of page numbers or ranges to extract from (1-based, e.g., '1,3,5-7,9' or '1-3,8-10').
   */
  page_range?: string | null;
};

export type ExtractJob = {
  /**
   * The id of the extraction job
   */
  id: string;
  /**
   * The agent that the job was run on.
   */
  extraction_agent: ExtractAgent;
  /**
   * The status of the extraction job
   */
  status: StatusEnum;
  /**
   * The error that occurred during extraction
   */
  error?: string | null;
  /**
   * The file that the extract was extracted from
   */
  file: File;
};

/**
 * Schema for creating an extraction job.
 */
export type ExtractJobCreate = {
  /**
   * The priority for the request. This field may be ignored or overwritten depending on the organization tier.
   */
  priority?: ("low" | "medium" | "high" | "critical") | null;
  /**
   * The outbound webhook configurations
   */
  webhook_configurations?: Array<WebhookConfiguration> | null;
  /**
   * The id of the extraction agent
   */
  extraction_agent_id: string;
  /**
   * The id of the file
   */
  file_id: string;
  /**
   * The data schema to override the extraction agent's data schema with
   */
  data_schema_override?:
    | {
        [key: string]:
          | {
              [key: string]: unknown;
            }
          | Array<unknown>
          | string
          | number
          | number
          | boolean
          | null;
      }
    | string
    | null;
  /**
   * The config to override the extraction agent's config with
   */
  config_override?: ExtractConfig | null;
};

/**
 * Schema for creating extraction jobs in batch.
 */
export type ExtractJobCreateBatch = {
  /**
   * The id of the extraction agent
   */
  extraction_agent_id: string;
  /**
   * The ids of the files
   */
  file_ids: Array<string>;
  /**
   * The data schema to override the extraction agent's data schema with
   */
  data_schema_override?:
    | {
        [key: string]:
          | {
              [key: string]: unknown;
            }
          | Array<unknown>
          | string
          | number
          | number
          | boolean
          | null;
      }
    | string
    | null;
  /**
   * The config to override the extraction agent's config with
   */
  config_override?: ExtractConfig | null;
};

export type ExtractMode = "FAST" | "BALANCED" | "PREMIUM" | "MULTIMODAL";

export const ExtractMode = {
  FAST: "FAST",
  BALANCED: "BALANCED",
  PREMIUM: "PREMIUM",
  MULTIMODAL: "MULTIMODAL",
} as const;

export type ExtractModels =
  | "openai-gpt-4-1"
  | "openai-gpt-4-1-mini"
  | "openai-gpt-4-1-nano"
  | "openai-gpt-5"
  | "openai-gpt-5-mini"
  | "gemini-2.0-flash"
  | "gemini-2.5-flash"
  | "gemini-2.5-pro"
  | "openai-gpt-4o"
  | "openai-gpt-4o-mini";

export const ExtractModels = {
  OPENAI_GPT_4_1: "openai-gpt-4-1",
  OPENAI_GPT_4_1_MINI: "openai-gpt-4-1-mini",
  OPENAI_GPT_4_1_NANO: "openai-gpt-4-1-nano",
  OPENAI_GPT_5: "openai-gpt-5",
  OPENAI_GPT_5_MINI: "openai-gpt-5-mini",
  GEMINI_2_0_FLASH: "gemini-2.0-flash",
  GEMINI_2_5_FLASH: "gemini-2.5-flash",
  GEMINI_2_5_PRO: "gemini-2.5-pro",
  OPENAI_GPT_4O: "openai-gpt-4o",
  OPENAI_GPT_4O_MINI: "openai-gpt-4o-mini",
} as const;

/**
 * Schema for an extraction resultset.
 */
export type ExtractResultset = {
  /**
   * The id of the extraction run
   */
  run_id: string;
  /**
   * The id of the extraction agent
   */
  extraction_agent_id: string;
  /**
   * The data extracted from the file
   */
  data:
    | {
        [key: string]:
          | {
              [key: string]: unknown;
            }
          | Array<unknown>
          | string
          | number
          | number
          | boolean
          | null;
      }
    | Array<{
        [key: string]:
          | {
              [key: string]: unknown;
            }
          | Array<unknown>
          | string
          | number
          | number
          | boolean
          | null;
      }>
    | null;
  /**
   * The metadata extracted from the file
   */
  extraction_metadata: {
    [key: string]:
      | {
          [key: string]: unknown;
        }
      | Array<unknown>
      | string
      | number
      | number
      | boolean
      | null;
  };
};

/**
 * Schema for an extraction run.
 */
export type ExtractRun = {
  /**
   * The id of the extraction run
   */
  id: string;
  /**
   * Creation datetime
   */
  created_at?: string | null;
  /**
   * Update datetime
   */
  updated_at?: string | null;
  /**
   * The id of the extraction agent
   */
  extraction_agent_id: string;
  /**
   * The schema used for extraction
   */
  data_schema: {
    [key: string]:
      | {
          [key: string]: unknown;
        }
      | Array<unknown>
      | string
      | number
      | number
      | boolean
      | null;
  };
  /**
   * The config used for extraction
   */
  config: ExtractConfig;
  /**
   * The file that the extract was extracted from
   */
  file: File;
  /**
   * The status of the extraction run
   */
  status: ExtractState;
  /**
   * The error that occurred during extraction
   */
  error?: string | null;
  /**
   * The id of the job that the extraction run belongs to
   */
  job_id?: string | null;
  /**
   * The data extracted from the file
   */
  data?:
    | {
        [key: string]:
          | {
              [key: string]: unknown;
            }
          | Array<unknown>
          | string
          | number
          | number
          | boolean
          | null;
      }
    | Array<{
        [key: string]:
          | {
              [key: string]: unknown;
            }
          | Array<unknown>
          | string
          | number
          | number
          | boolean
          | null;
      }>
    | null;
  /**
   * The metadata extracted from the file
   */
  extraction_metadata?: {
    [key: string]:
      | {
          [key: string]: unknown;
        }
      | Array<unknown>
      | string
      | number
      | number
      | boolean
      | null;
  } | null;
  /**
   * Whether this extraction run was triggered from the UI
   */
  from_ui: boolean;
};

/**
 * Request schema for generating an extraction schema.
 */
export type ExtractSchemaGenerateRequest = {
  /**
   * Natural language description of the data structure to extract
   */
  prompt?: string | null;
  /**
   * Optional file ID to analyze for schema generation
   */
  file_id?: string | null;
};

/**
 * Response schema for schema generation.
 */
export type ExtractSchemaGenerateResponse = {
  /**
   * The generated JSON schema
   */
  data_schema: {
    [key: string]:
      | {
          [key: string]: unknown;
        }
      | Array<unknown>
      | string
      | number
      | number
      | boolean
      | null;
  };
};

export type ExtractSchemaValidateRequest = {
  data_schema:
    | {
        [key: string]:
          | {
              [key: string]: unknown;
            }
          | Array<unknown>
          | string
          | number
          | number
          | boolean
          | null;
      }
    | string;
};

export type ExtractSchemaValidateResponse = {
  data_schema: {
    [key: string]:
      | {
          [key: string]: unknown;
        }
      | Array<unknown>
      | string
      | number
      | number
      | boolean
      | null;
  };
};

export type ExtractState = "CREATED" | "PENDING" | "SUCCESS" | "ERROR";

export const ExtractState = {
  CREATED: "CREATED",
  PENDING: "PENDING",
  SUCCESS: "SUCCESS",
  ERROR: "ERROR",
} as const;

/**
 * Schema for stateless extraction requests.
 */
export type ExtractStatelessRequest = {
  /**
   * The outbound webhook configurations
   */
  webhook_configurations?: Array<WebhookConfiguration> | null;
  /**
   * The schema of the data to extract
   */
  data_schema:
    | {
        [key: string]:
          | {
              [key: string]: unknown;
            }
          | Array<unknown>
          | string
          | number
          | number
          | boolean
          | null;
      }
    | string;
  /**
   * The configuration parameters for the extraction
   */
  config: ExtractConfig;
  /**
   * The ID of the file to extract from
   */
  file_id?: string | null;
  /**
   * The text content to extract from
   */
  text?: string | null;
  /**
   * The file data with base64 content and MIME type
   */
  file?: FileData | null;
};

export type ExtractTarget = "PER_DOC" | "PER_PAGE";

export const ExtractTarget = {
  PER_DOC: "PER_DOC",
  PER_PAGE: "PER_PAGE",
} as const;

/**
 * Enum for representing the different available page error handling modes
 */
export type FailPageMode = "raw_text" | "blank_page" | "error_message";

/**
 * Enum for representing the different available page error handling modes
 */
export const FailPageMode = {
  RAW_TEXT: "raw_text",
  BLANK_PAGE: "blank_page",
  ERROR_MESSAGE: "error_message",
} as const;

/**
 * Configuration for handling different types of failures during data source processing.
 */
export type FailureHandlingConfig = {
  /**
   * Whether to skip failed batches/lists and continue processing
   */
  skip_list_failures?: boolean;
};

/**
 * Schema for a file.
 */
export type File = {
  /**
   * Unique identifier
   */
  id: string;
  /**
   * Creation datetime
   */
  created_at?: string | null;
  /**
   * Update datetime
   */
  updated_at?: string | null;
  name: string;
  /**
   * The ID of the file in the external system
   */
  external_file_id?: string | null;
  /**
   * Size of the file in bytes
   */
  file_size?: number | null;
  /**
   * File type (e.g. pdf, docx, etc.)
   */
  file_type?: string | null;
  /**
   * The ID of the project that the file belongs to
   */
  project_id: string;
  /**
   * The last modified time of the file
   */
  last_modified_at?: string | null;
  /**
   * Resource information for the file
   */
  resource_info?: {
    [key: string]:
      | {
          [key: string]: unknown;
        }
      | Array<unknown>
      | string
      | number
      | number
      | boolean
      | null;
  } | null;
  /**
   * Permission information for the file
   */
  permission_info?: {
    [key: string]:
      | {
          [key: string]: unknown;
        }
      | Array<unknown>
      | string
      | number
      | number
      | boolean
      | null;
  } | null;
  /**
   * The ID of the data source that the file belongs to
   */
  data_source_id?: string | null;
};

/**
 * A file classification.
 */
export type FileClassification = {
  /**
   * Unique identifier
   */
  id: string;
  /**
   * Creation datetime
   */
  created_at?: string | null;
  /**
   * Update datetime
   */
  updated_at?: string | null;
  /**
   * The ID of the classify job
   */
  classify_job_id: string;
  /**
   * The ID of the classified file
   */
  file_id: string;
  /**
   * The classification result
   */
  result?: ClassificationResult | null;
};

export type FileCountByStatusResponse = {
  /**
   * The counts of files by status
   */
  counts: {
    [key: string]: number;
  };
  /**
   * The total number of files
   */
  total_count: number;
  /**
   * The ID of the pipeline that the files belong to
   */
  pipeline_id?: string | null;
  /**
   * The ID of the data source that the files belong to
   */
  data_source_id?: string | null;
  /**
   * Whether to only count manually uploaded files
   */
  only_manually_uploaded?: boolean;
};

export type FileCreate = {
  /**
   * Name that will be used for created file. If possible, always include the file extension in the name.
   */
  name: string;
  /**
   * The ID of the file in the external system
   */
  external_file_id?: string | null;
  /**
   * Size of the file in bytes
   */
  file_size?: number | null;
  /**
   * The last modified time of the file
   */
  last_modified_at?: string | null;
  /**
   * Resource information for the file
   */
  resource_info?: {
    [key: string]:
      | {
          [key: string]: unknown;
        }
      | Array<unknown>
      | string
      | number
      | number
      | boolean
      | null;
  } | null;
  /**
   * Permission information for the file
   */
  permission_info?: {
    [key: string]:
      | {
          [key: string]: unknown;
        }
      | Array<unknown>
      | string
      | number
      | number
      | boolean
      | null;
  } | null;
  /**
   * The ID of the data source that the file belongs to
   */
  data_source_id?: string | null;
};

export type FileCreateFromUrl = {
  /**
   * Name that will be used for created file. If possible, always include the file extension in the name.
   */
  name?: string | null;
  /**
   * URL of the file to download
   */
  url: string;
  /**
   * URL of the proxy server to use for downloading the file
   */
  proxy_url?: string | null;
  /**
   * Headers to include in the request when downloading the file
   */
  request_headers?: {
    [key: string]: string;
  } | null;
  /**
   * Whether to verify the SSL certificate when downloading the file
   */
  verify_ssl?: boolean;
  /**
   * Whether to follow redirects when downloading the file
   */
  follow_redirects?: boolean;
  /**
   * Resource information for the file
   */
  resource_info?: {
    [key: string]:
      | {
          [key: string]: unknown;
        }
      | Array<unknown>
      | string
      | number
      | number
      | boolean
      | null;
  } | null;
};

/**
 * Schema for file data with base64 content and MIME type.
 */
export type FileData = {
  /**
   * The file content as base64-encoded string
   */
  data: string;
  /**
   * The MIME type of the file (e.g., 'application/pdf', 'text/plain')
   */
  mime_type: string;
};

/**
 * Filter parameters for file queries.
 */
export type FileFilter = {
  /**
   * Filter by project ID
   */
  project_id?: string | null;
  /**
   * Filter by specific file IDs
   */
  file_ids?: Array<string> | null;
  /**
   * Filter by file name
   */
  file_name?: string | null;
  /**
   * Filter by data source ID
   */
  data_source_id?: string | null;
  /**
   * Filter by external file ID
   */
  external_file_id?: string | null;
  /**
   * Filter only manually uploaded files (data_source_id is null)
   */
  only_manually_uploaded?: boolean | null;
};

/**
 * Schema for a presigned URL with a file ID.
 */
export type FileIdPresignedUrl = {
  /**
   * A presigned URL for IO operations against a private file
   */
  url: string;
  /**
   * The time at which the presigned URL expires
   */
  expires_at: string;
  /**
   * Form fields for a presigned POST request
   */
  form_fields?: {
    [key: string]: string;
  } | null;
  /**
   * The ID of the file associated with the presigned URL
   */
  file_id: string;
};

export type FileParsePublic = {
  /**
   * The date and time when the file was parsed.
   */
  created_at: string;
  /**
   * The status of the parse task.
   */
  status: string;
  /**
   * The date and time when the file parse started.
   */
  started_at?: string | null;
  /**
   * The date and time when the file parse ended.
   */
  ended_at?: string | null;
  /**
   * The path to the input file.
   */
  input_path: string;
  /**
   * The path to the data file.
   */
  data_path: string;
};

/**
 * Request schema for querying files with pagination and filtering.
 */
export type FileQueryRequest = {
  /**
   * The maximum number of items to return. The service may return fewer than this value. If unspecified, a default page size will be used. The maximum value is typically 1000; values above this will be coerced to the maximum.
   */
  page_size?: number | null;
  /**
   * A page token, received from a previous list call. Provide this to retrieve the subsequent page.
   */
  page_token?: string | null;
  /**
   * A filter object or expression that filters resources listed in the response.
   */
  filter?: FileFilter | null;
  /**
   * A comma-separated list of fields to order by, sorted in ascending order. Use 'field_name desc' to specify descending order.
   */
  order_by?: string | null;
};

/**
 * Response schema for paginated file queries.
 */
export type FileQueryResponse = {
  /**
   * The list of items.
   */
  items: Array<File>;
  /**
   * A token, which can be sent as page_token to retrieve the next page. If this field is omitted, there are no subsequent pages.
   */
  next_page_token?: string | null;
  /**
   * The total number of items available. This is only populated when specifically requested. The value may be an estimate and can be used for display purposes only.
   */
  total_size?: number | null;
};

/**
 * Vector store filter conditions to combine different filters.
 */
export type FilterCondition = "and" | "or" | "not";

/**
 * Vector store filter conditions to combine different filters.
 */
export const FilterCondition = {
  AND: "and",
  OR: "or",
  NOT: "not",
} as const;

/**
 * API request model for a filter comparison operation.
 */
export type FilterOperation = {
  eq?: number | number | string | null;
  gt?: number | number | string | null;
  gte?: number | number | string | null;
  lt?: number | number | string | null;
  lte?: number | number | string | null;
  includes?: Array<number | number | string | null>;
};

/**
 * Vector store filter operator.
 */
export type FilterOperator =
  | "=="
  | ">"
  | "<"
  | "!="
  | ">="
  | "<="
  | "in"
  | "nin"
  | "any"
  | "all"
  | "text_match"
  | "text_match_insensitive"
  | "contains"
  | "is_empty";

/**
 * Vector store filter operator.
 */
export const FilterOperator = {
  "==": "==",
  ">": ">",
  "<": "<",
  "!=": "!=",
  ">=": ">=",
  "<=": "<=",
  IN: "in",
  NIN: "nin",
  ANY: "any",
  ALL: "all",
  TEXT_MATCH: "text_match",
  TEXT_MATCH_INSENSITIVE: "text_match_insensitive",
  CONTAINS: "contains",
  IS_EMPTY: "is_empty",
} as const;

export type FreeCreditsUsage = {
  starting_balance: number;
  remaining_balance: number;
  grant_name: string;
  expires_at: string;
};

export type GeminiEmbedding = {
  /**
   * The modelId of the Gemini model to use.
   */
  model_name?: string;
  /**
   * The batch size for embedding calls.
   */
  embed_batch_size?: number;
  /**
   * The number of workers to use for async embedding calls.
   */
  num_workers?: number | null;
  /**
   * Title is only applicable for retrieval_document tasks, and is used to represent a document title. For other tasks, title is invalid.
   */
  title?: string | null;
  /**
   * The task for embedding model.
   */
  task_type?: string | null;
  /**
   * API key to access the model. Defaults to None.
   */
  api_key?: string | null;
  /**
   * API base to access the model. Defaults to None.
   */
  api_base?: string | null;
  /**
   * Transport to access the model. Defaults to None.
   */
  transport?: string | null;
  class_name?: string;
};

export type GeminiEmbeddingConfig = {
  /**
   * Type of the embedding model.
   */
  type?: "GEMINI_EMBEDDING";
  /**
   * Configuration for the Gemini embedding model.
   */
  component?: GeminiEmbedding;
};

export type HttpValidationError = {
  detail?: Array<ValidationError>;
};

export type HuggingFaceInferenceApiEmbedding = {
  /**
   * Hugging Face model name. If None, the task will be used.
   */
  model_name?: string | null;
  /**
   * The batch size for embedding calls.
   */
  embed_batch_size?: number;
  /**
   * The number of workers to use for async embedding calls.
   */
  num_workers?: number | null;
  /**
   * Pooling strategy. If None, the model's default pooling is used.
   */
  pooling?: Pooling | null;
  /**
   * Instruction to prepend during query embedding.
   */
  query_instruction?: string | null;
  /**
   * Instruction to prepend during text embedding.
   */
  text_instruction?: string | null;
  /**
   * Hugging Face token. Will default to the locally saved token. Pass token=False if you don’t want to send your token to the server.
   */
  token?: string | boolean | null;
  /**
   * The maximum number of seconds to wait for a response from the server. Loading a new model in Inference API can take up to several minutes. Defaults to None, meaning it will loop until the server is available.
   */
  timeout?: number | null;
  /**
   * Additional headers to send to the server. By default only the authorization and user-agent headers are sent. Values in this dictionary will override the default values.
   */
  headers?: {
    [key: string]: string;
  } | null;
  /**
   * Additional cookies to send to the server.
   */
  cookies?: {
    [key: string]: string;
  } | null;
  /**
   * Optional task to pick Hugging Face's recommended model, used when model_name is left as default of None.
   */
  task?: string | null;
  class_name?: string;
};

export type HuggingFaceInferenceApiEmbeddingConfig = {
  /**
   * Type of the embedding model.
   */
  type?: "HUGGINGFACE_API_EMBEDDING";
  /**
   * Configuration for the HuggingFace Inference API embedding model.
   */
  component?: HuggingFaceInferenceApiEmbedding;
};

export type IngestionErrorResponse = {
  /**
   * ID of the job that failed.
   */
  job_id: string;
  /**
   * List of errors that occurred during ingestion.
   */
  message: string;
  /**
   * Name of the job that failed.
   */
  step: JobNameMapping;
};

/**
 * This is distinct from a ChatMessage because this schema is enforced by the AI Chat library used in the frontend
 */
export type InputMessage = {
  /**
   * ID of the message, if any. a UUID.
   */
  id?: string;
  role: MessageRole;
  content: string;
  /**
   * Additional data to be stored with the message.
   */
  data?: {
    [key: string]: unknown;
  } | null;
  class_name?: string;
};

/**
 * Enum for mapping original job names to readable names.
 */
export type JobNameMapping =
  | "MANAGED_INGESTION"
  | "DATA_SOURCE"
  | "FILES_UPDATE"
  | "FILE_UPDATER"
  | "PARSE"
  | "TRANSFORM"
  | "INGESTION"
  | "METADATA_UPDATE";

/**
 * Enum for mapping original job names to readable names.
 */
export const JobNameMapping = {
  MANAGED_INGESTION: "MANAGED_INGESTION",
  DATA_SOURCE: "DATA_SOURCE",
  FILES_UPDATE: "FILES_UPDATE",
  FILE_UPDATER: "FILE_UPDATER",
  PARSE: "PARSE",
  TRANSFORM: "TRANSFORM",
  INGESTION: "INGESTION",
  METADATA_UPDATE: "METADATA_UPDATE",
} as const;

/**
 * Enum for executable pipeline job names.
 */
export type JobNames =
  | "load_documents_job"
  | "load_files_job"
  | "playground_job"
  | "pipeline_managed_ingestion_job"
  | "data_source_update_dispatcher_job"
  | "pipeline_file_update_dispatcher_job"
  | "pipeline_file_updater_job"
  | "file_managed_ingestion_job"
  | "document_ingestion_job"
  | "metadata_update_job"
  | "parse_raw_file_job_cached"
  | "extraction_job"
  | "extract_job"
  | "asyncio_test_job"
  | "parse_raw_file_job"
  | "llama_parse_transform_job";

/**
 * Enum for executable pipeline job names.
 */
export const JobNames = {
  LOAD_DOCUMENTS_JOB: "load_documents_job",
  LOAD_FILES_JOB: "load_files_job",
  PLAYGROUND_JOB: "playground_job",
  PIPELINE_MANAGED_INGESTION_JOB: "pipeline_managed_ingestion_job",
  DATA_SOURCE_UPDATE_DISPATCHER_JOB: "data_source_update_dispatcher_job",
  PIPELINE_FILE_UPDATE_DISPATCHER_JOB: "pipeline_file_update_dispatcher_job",
  PIPELINE_FILE_UPDATER_JOB: "pipeline_file_updater_job",
  FILE_MANAGED_INGESTION_JOB: "file_managed_ingestion_job",
  DOCUMENT_INGESTION_JOB: "document_ingestion_job",
  METADATA_UPDATE_JOB: "metadata_update_job",
  PARSE_RAW_FILE_JOB_CACHED: "parse_raw_file_job_cached",
  EXTRACTION_JOB: "extraction_job",
  EXTRACT_JOB: "extract_job",
  ASYNCIO_TEST_JOB: "asyncio_test_job",
  PARSE_RAW_FILE_JOB: "parse_raw_file_job",
  LLAMA_PARSE_TRANSFORM_JOB: "llama_parse_transform_job",
} as const;

/**
 * Schema for a job's metadata.
 */
export type JobRecord = {
  /**
   * The outbound webhook configurations
   */
  webhook_configurations?: Array<WebhookConfiguration> | null;
  /**
   * The name of the job.
   */
  job_name: JobNames;
  /**
   * The partitions for this execution. Used for determining where to save job output.
   */
  partitions: {
    [key: string]: string;
  };
  /**
   * Additional metadata for the job execution.
   */
  parameters?:
    | (
        | ({
            type: "parse";
          } & ParseJobConfig)
        | ({
            type: "legacy_parse";
          } & LegacyParseJobConfig)
        | ({
            type: "load_files";
          } & LoadFilesJobConfig)
        | ({
            type: "llama_parse_transform";
          } & LLamaParseTransformConfig)
        | ({
            type: "pipeline_managed_ingestion";
          } & PipelineManagedIngestionJobParams)
        | ({
            type: "data_source_update_dispatcher";
          } & DataSourceUpdateDispatcherConfig)
        | ({
            type: "pipeline_file_update_dispatcher";
          } & PipelineFileUpdateDispatcherConfig)
        | ({
            type: "pipeline_file_updater";
          } & PipelineFileUpdaterConfig)
        | ({
            type: "document_ingestion";
          } & DocumentIngestionJobParams)
      )
    | null;
  /**
   * The upstream request ID that created this job. Used for tracking the job across services.
   */
  session_id?: string | null;
  /**
   * The correlation ID for this job. Used for tracking the job across services.
   */
  correlation_id?: string | null;
  /**
   * The ID of the parent job execution.
   */
  parent_job_execution_id?: string | null;
  /**
   * The ID of the user that created this job
   */
  user_id?: string | null;
  /**
   * Creation datetime
   */
  created_at: string;
  /**
   * The ID of the project this job belongs to.
   */
  project_id?: string | null;
  /**
   * Unique identifier
   */
  id?: string;
  status: StatusEnum;
  error_code?: string | null;
  error_message?: string | null;
  /**
   * The number of times this job has been attempted
   */
  attempts?: number | null;
  started_at?: string | null;
  ended_at?: string | null;
  /**
   * Update datetime
   */
  updated_at?: string;
};

export type JobRecordWithUsageMetrics = {
  job_record: JobRecord;
  usage_metrics?: UsageMetricResponse | null;
  user: UserJobRecord;
};

/**
 * Schema for an eval LLM model.
 */
export type LlmModelData = {
  /**
   * The name of the LLM model.
   */
  name: string;
  /**
   * The description of the LLM model.
   */
  description: string;
  /**
   * Whether the model supports multi-modal image input
   */
  multi_modal: boolean;
  model_name?: string;
};

export type LlmParameters = {
  /**
   * The name of the model to use for LLM completions.
   */
  model_name?: SupportedLlmModelNames;
  /**
   * The system prompt to use for the completion.
   */
  system_prompt?: string | null;
  /**
   * The temperature value for the model.
   */
  temperature?: number | null;
  /**
   * Whether to use chain of thought reasoning.
   */
  use_chain_of_thought_reasoning?: boolean | null;
  /**
   * Whether to show citations in the response.
   */
  use_citation?: boolean | null;
  class_name?: string;
};

/**
 * Schema for the parameters of llamaparse transform job.
 */
export type LLamaParseTransformConfig = {
  /**
   * The custom metadata to attach to the documents.
   */
  custom_metadata?: {
    [key: string]: unknown;
  } | null;
  /**
   * The resource info about the file
   */
  resource_info?: {
    [key: string]: unknown;
  } | null;
  type?: "llama_parse_transform";
  /**
   * Whether to delete the files
   */
  file_output: string;
};

/**
 * Configuration for llamaparse job
 */
export type LegacyParseJobConfig = {
  /**
   * The custom metadata to attach to the documents.
   */
  custom_metadata?: {
    [key: string]: unknown;
  } | null;
  /**
   * The resource info about the file
   */
  resource_info?: {
    [key: string]: unknown;
  } | null;
  type?: "legacy_parse";
  /**
   * The user ID.
   */
  userId: string;
  /**
   * The file name.
   */
  fileName: string;
  /**
   * The original file name.
   */
  originalFileName: string;
  /**
   * The file key.
   */
  fileKey: string;
  /**
   * The input URL.
   */
  inputUrl?: string | null;
  /**
   * The HTTP proxy.
   */
  httpProxy?: string | null;
  /**
   * Whether to use fast mode.
   */
  fastMode?: boolean | null;
  /**
   * The language.
   */
  lang: string;
  /**
   * The parsing instruction.
   */
  template?: string;
  /**
   * The pipeline ID.
   */
  pipelineId?: string | null;
  /**
   * The output bucket.
   */
  outputBucket?: string | null;
  /**
   * The file ID.
   */
  fileId?: string | null;
  /**
   * The full file path.
   */
  fullFilePath?: string | null;
  /**
   * Whether the file is from LLama cloud.
   */
  fromLLamaCloud?: boolean;
  /**
   * Whether to skip diagonal text.
   */
  skipDiagonalText?: boolean;
  /**
   * Whether to preserve layout alignment across pages.
   */
  preserveLayoutAlignmentAcrossPages?: boolean;
  /**
   * Whether to preserve very small text lines.
   */
  preserveVerySmallText?: boolean;
  /**
   * Whether to invalidate the cache.
   */
  invalidateCache: boolean;
  /**
   * Whether to output PDF of document
   */
  outputPDFOfDocument?: boolean | null;
  /**
   * Whether to try to extract outlined tables
   */
  outlinedTableExtraction?: boolean | null;
  /**
   * Whether to merge tables across pages in markdown
   */
  mergeTablesAcrossPagesInMarkdown?: boolean | null;
  /**
   * Whether to output images contained in the document
   */
  saveImages?: boolean | null;
  /**
   * Whether to use GPT4o.
   */
  gpt4o?: boolean;
  /**
   * The OpenAI API key.
   */
  openAIAPIKey: string;
  /**
   * Whether to unroll columns.
   */
  doNotUnrollColumns?: boolean;
  /**
   * Whether to extract subTables from spreadsheet.
   */
  spreadSheetExtractSubTables?: boolean | null;
  /**
   * Whether to force re-computation of spreadsheet cells containing formulas.
   */
  spreadSheetForceFormulaComputation?: boolean | null;
  /**
   * Whether to perform layout extraction.
   */
  extractLayout?: boolean | null;
  /**
   * Whether to use high resolution OCR (Slow).
   */
  highResOcr?: boolean | null;
  /**
   * Whether to make all elements visible.
   */
  htmlMakeAllElementsVisible?: boolean | null;
  /**
   * Whether to remove fixed elements.
   */
  htmlRemoveFixedElements?: boolean | null;
  /**
   * Whether to remove navigation elements.
   */
  htmlRemoveNavigationElements?: boolean | null;
  /**
   * Whether to guess the XLSX sheet name when generation output xlsx.
   */
  guessXLSXSheetName?: boolean;
  /**
   * Whether to cache.
   */
  doNotCache?: boolean;
  /**
   * The page separator.
   */
  pageSeparator?: string | null;
  /**
   * A string describing a bounding box to use to parse the document. Contain 4 value between 0 to 1 representing in clock wise order the margin top, right, bottom, left of the selection bounding box in ratio of the document.
   */
  boundingBox?: string | null;
  /**
   * The top side of the bounding box.
   */
  bboxTop?: number | null;
  /**
   * The right side of the bounding box.
   */
  bboxRight?: number | null;
  /**
   * The bottom side of the bounding box.
   */
  bboxBottom?: number | null;
  /**
   * The left side of the bounding box.
   */
  bboxLeft?: number | null;
  /**
   * Whether to disable markdown reconstruction.
   */
  disableReconstruction?: boolean | null;
  /**
   * A string containing a list of comma separated containing the page number to extract. If not specified all pages are extracted from the document. The first page is the page 0.
   */
  targetPages?: string | null;
  /**
   * True if parsing happen in multimodal mode.
   */
  multimodalPipeline?: boolean | null;
  /**
   * The multimodal model to use.
   */
  multimodalModel?: string | null;
  /**
   * The model to use.
   */
  model?: string | null;
  /**
   * The multimodal vendor API key.
   */
  vendorAPIKey?: string | null;
  /**
   * A page prefix to add before each page.
   */
  pagePrefix?: string | null;
  /**
   * A page suffix to add after each page.
   */
  pageSuffix?: string | null;
  /**
   * The URL that needs to be called at the end of the parsing job.
   */
  webhookUrl?: string | null;
  /**
   * The preset of options to be used.
   */
  preset?: string | null;
  /**
   * Force to capture an image of each pages
   */
  takeScreenshot?: boolean;
  /**
   * Allow the parsing instruction to also format the output.
   */
  isFormattingInstruction?: boolean;
  /**
   * Whether to use premiumMode pipeline.
   */
  premiumMode?: boolean;
  /**
   * Whether to use continuousMode pipeline.
   */
  continuousMode?: boolean;
  /**
   * Disable the OCR on the document. LlamaParse will only extract the copyable text from the document
   */
  disableOcr?: boolean;
  /**
   * Disable the image extraction from the document. LlamaParse will not extract any image from the document.
   */
  disableImageExtraction?: boolean;
  /**
   * Annotate links in markdown. LlamaParse will try to add links from document into the markdown.
   */
  annotateLinks?: boolean;
  /**
   * Adaptive long table. LlamaParse will try to detect long table and adapt the output.
   */
  adaptiveLongTable?: boolean;
  /**
   * Compact markdown table. LlamaParse will compact the markdown table to not include too many spaces.
   */
  compactMarkdownTable?: boolean;
  /**
   * If specified, llamaParse will take the specified file. should be a valid s3:// url
   */
  inputS3Path?: string | null;
  /**
   * The region for the input S3 bucket.
   */
  inputS3Region?: string | null;
  /**
   * If specified, llamaParse will save the output to the specified path. All output file will use this 'prefix' should be a valid s3:// url
   */
  outputS3PathPrefix?: string | null;
  /**
   * The region for the output S3 bucket.
   */
  outputS3Region?: string | null;
  /**
   * The project ID.
   */
  projectId?: string | null;
  /**
   * Custom azure deployment name.
   */
  azureOpenAiDeploymentName?: string | null;
  /**
   * Custom azure endpoint.
   */
  azureOpenAiEndpoint?: string | null;
  /**
   * Custom azure API version.
   */
  azureOpenAiApiVersion?: string | null;
  /**
   * Custom azure API key.
   */
  azureOpenAiKey?: string | null;
  /**
   * Whether to use auto mode.
   */
  autoMode?: boolean;
  /**
   * Whether to trigger on table in page.
   */
  autoModeTriggerOnTableInPage?: boolean;
  /**
   * Whether to trigger on image in page.
   */
  autoModeTriggerOnImageInPage?: boolean;
  /**
   * The regexp to trigger on.
   */
  autoModeTriggerOnRegexpInPage?: string | null;
  /**
   * The text to trigger on.
   */
  autoModeTriggerOnTextInPage?: string | null;
  /**
   * The auto mode configuration JSON. This is a JSON string that contains the configuration for the auto mode.
   */
  autoModeConfigurationJSON?: string | null;
  /**
   * Whether to use structured output.
   */
  structuredOutput?: boolean;
  /**
   * The structured output JSON schema.
   */
  structuredOutputJSONSchema?: string | null;
  /**
   * The structured output JSON schema name.
   */
  structuredOutputJSONSchemaName?: string | null;
  /**
   * The maximum number of pages to parse.
   */
  maxPages?: number | null;
  /**
   * Extract charts from the document.
   */
  extractCharts?: boolean;
  /**
   * A natural language instruction on how to format the result. Override LlamaParse default instruction.
   */
  formattingInstruction?: string | null;
  /**
   * A natural language instruction on how to format the result that complement LlamaParse default instruction.
   */
  complementalFormattingInstruction?: string | null;
  /**
   * A natural language instruction on how to transform the content of the result (not the format).
   */
  contentGuidelineInstruction?: string | null;
  /**
   * Manually set a timeout in second for a job. Minimum is 120
   */
  jobTimeoutInSeconds?: number | null;
  /**
   * Manually set additional time per page for timeout in second for a job.
   */
  jobTimeoutExtraTimePerPageInSeconds?: number | null;
  /**
   * If true, the job will fail when we are not able to extract an image from a document.
   */
  strictModeImageExtraction?: boolean;
  /**
   * If true, the job will fail when we are not able to OCR an image from a document.
   */
  strictModeImageOCR?: boolean;
  /**
   * If true, the job will fail when we are not able to transform a page to Markdown in a document.
   */
  strictModeReconstruction?: boolean;
  /**
   * If true, the job will fail when we are not able to extract a glyph from the document due to buggy font.
   */
  strictModeBuggyFont?: boolean;
  /**
   * If true, the job will ignore document element for layout detection, and instead just rely on a visual model, only apply to layout detection.
   */
  ignoreDocumentElementsForLayoutDetection?: boolean;
  /**
   * If true, the job will output tables as HTML in the markdown output, useful for merged cells.
   */
  outputTablesAsHTML?: boolean;
  /**
   * The parsing mode.
   */
  parseMode?: string | null;
  /**
   * The system prompt.
   */
  systemPrompt?: string | null;
  /**
   * The append to system prompt.
   */
  systemPromptAppend?: string | null;
  /**
   * The user prompt.
   */
  userPrompt?: string | null;
  /**
   * The page header prefix.
   */
  pageHeaderPrefix?: string | null;
  /**
   * The page header suffix.
   */
  pageHeaderSuffix?: string | null;
  /**
   * The page footer prefix.
   */
  pageFooterPrefix?: string | null;
  /**
   * The page footer suffix.
   */
  pageFooterSuffix?: string | null;
  /**
   * Whether to hide headers in the output.
   */
  hideHeaders?: boolean;
  /**
   * Whether to hide footers in the output.
   */
  hideFooters?: boolean;
};

/**
 * All settings for the extraction agent. Only the settings in ExtractConfig
 * are exposed to the user.
 */
export type LlamaExtractSettings = {
  /**
   * The maximum file size (in bytes) allowed for the document.
   */
  max_file_size?: number;
  /**
   * The maximum file size (in bytes) allowed for the document.
   */
  max_file_size_ui?: number;
  /**
   * The maximum number of pages allowed for the document.
   */
  max_pages?: number;
  /**
   * The mode to use for chunking the document.
   */
  chunk_mode?: ChunkMode;
  /**
   * The maximum size of the chunks (in tokens) to use for chunking the document.
   */
  max_chunk_size?: number;
  /**
   * The configuration for the extraction agent.
   */
  extraction_agent_config?: {
    [key: string]: StructParseConf;
  };
  /**
   * Whether to use experimental multimodal parsing.
   */
  use_multimodal_parsing?: boolean;
  /**
   * DEPRECATED: Whether to use extraction over pixels for multimodal mode.
   */
  use_pixel_extraction?: boolean;
  /**
   * LlamaParse related settings.
   */
  llama_parse_params?: LlamaParseParameters;
  /**
   * The resolution to use for multimodal parsing.
   */
  multimodal_parse_resolution?: MultimodalParseResolution;
};

/**
 * Settings that can be configured for how to use LlamaParse to parse files within a LlamaCloud pipeline.
 */
export type LlamaParseParameters = {
  /**
   * The outbound webhook configurations
   */
  webhook_configurations?: Array<WebhookConfiguration> | null;
  /**
   * The priority for the request. This field may be ignored or overwritten depending on the organization tier.
   */
  priority?: ("low" | "medium" | "high" | "critical") | null;
  languages?: Array<ParserLanguages>;
  parsing_instruction?: string | null;
  disable_ocr?: boolean | null;
  annotate_links?: boolean | null;
  adaptive_long_table?: boolean | null;
  compact_markdown_table?: boolean | null;
  disable_reconstruction?: boolean | null;
  disable_image_extraction?: boolean | null;
  invalidate_cache?: boolean | null;
  outlined_table_extraction?: boolean | null;
  merge_tables_across_pages_in_markdown?: boolean | null;
  output_pdf_of_document?: boolean | null;
  do_not_cache?: boolean | null;
  fast_mode?: boolean | null;
  skip_diagonal_text?: boolean | null;
  preserve_layout_alignment_across_pages?: boolean | null;
  preserve_very_small_text?: boolean | null;
  gpt4o_mode?: boolean | null;
  gpt4o_api_key?: string | null;
  do_not_unroll_columns?: boolean | null;
  extract_layout?: boolean | null;
  high_res_ocr?: boolean | null;
  html_make_all_elements_visible?: boolean | null;
  layout_aware?: boolean | null;
  specialized_chart_parsing_agentic?: boolean | null;
  specialized_chart_parsing_plus?: boolean | null;
  specialized_chart_parsing_efficient?: boolean | null;
  specialized_image_parsing?: boolean | null;
  precise_bounding_box?: boolean | null;
  html_remove_navigation_elements?: boolean | null;
  html_remove_fixed_elements?: boolean | null;
  guess_xlsx_sheet_name?: boolean | null;
  page_separator?: string | null;
  bounding_box?: string | null;
  bbox_top?: number | null;
  bbox_right?: number | null;
  bbox_bottom?: number | null;
  bbox_left?: number | null;
  target_pages?: string | null;
  use_vendor_multimodal_model?: boolean | null;
  vendor_multimodal_model_name?: string | null;
  model?: string | null;
  vendor_multimodal_api_key?: string | null;
  page_prefix?: string | null;
  page_suffix?: string | null;
  webhook_url?: string | null;
  preset?: string | null;
  take_screenshot?: boolean | null;
  is_formatting_instruction?: boolean | null;
  premium_mode?: boolean | null;
  continuous_mode?: boolean | null;
  input_s3_path?: string | null;
  input_s3_region?: string | null;
  output_s3_path_prefix?: string | null;
  output_s3_region?: string | null;
  project_id?: string | null;
  azure_openai_deployment_name?: string | null;
  azure_openai_endpoint?: string | null;
  azure_openai_api_version?: string | null;
  azure_openai_key?: string | null;
  input_url?: string | null;
  http_proxy?: string | null;
  auto_mode?: boolean | null;
  auto_mode_trigger_on_regexp_in_page?: string | null;
  auto_mode_trigger_on_text_in_page?: string | null;
  auto_mode_trigger_on_table_in_page?: boolean | null;
  auto_mode_trigger_on_image_in_page?: boolean | null;
  auto_mode_configuration_json?: string | null;
  structured_output?: boolean | null;
  structured_output_json_schema?: string | null;
  structured_output_json_schema_name?: string | null;
  max_pages?: number | null;
  max_pages_enforced?: number | null;
  extract_charts?: boolean | null;
  formatting_instruction?: string | null;
  complemental_formatting_instruction?: string | null;
  content_guideline_instruction?: string | null;
  spreadsheet_extract_sub_tables?: boolean | null;
  spreadsheet_force_formula_computation?: boolean | null;
  inline_images_in_markdown?: boolean | null;
  job_timeout_in_seconds?: number | null;
  job_timeout_extra_time_per_page_in_seconds?: number | null;
  strict_mode_image_extraction?: boolean | null;
  strict_mode_image_ocr?: boolean | null;
  strict_mode_reconstruction?: boolean | null;
  strict_mode_buggy_font?: boolean | null;
  save_images?: boolean | null;
  hide_headers?: boolean | null;
  hide_footers?: boolean | null;
  page_header_prefix?: string | null;
  page_header_suffix?: string | null;
  page_footer_prefix?: string | null;
  page_footer_suffix?: string | null;
  ignore_document_elements_for_layout_detection?: boolean | null;
  output_tables_as_HTML?: boolean | null;
  internal_is_screenshot_job?: boolean | null;
  parse_mode?: ParsingMode | null;
  system_prompt?: string | null;
  system_prompt_append?: string | null;
  user_prompt?: string | null;
  page_error_tolerance?: number | null;
  replace_failed_page_mode?: FailPageMode | null;
  replace_failed_page_with_error_message_prefix?: string | null;
  replace_failed_page_with_error_message_suffix?: string | null;
  markdown_table_multiline_header_separator?: string | null;
};

export type LlamaParseSupportedFileExtensions =
  | ".pdf"
  | ".doc"
  | ".docx"
  | ".docm"
  | ".dot"
  | ".dotx"
  | ".dotm"
  | ".rtf"
  | ".wps"
  | ".wpd"
  | ".sxw"
  | ".stw"
  | ".sxg"
  | ".pages"
  | ".mw"
  | ".mcw"
  | ".uot"
  | ".uof"
  | ".uos"
  | ".uop"
  | ".ppt"
  | ".pptx"
  | ".pot"
  | ".pptm"
  | ".potx"
  | ".potm"
  | ".key"
  | ".odp"
  | ".odg"
  | ".otp"
  | ".fopd"
  | ".sxi"
  | ".sti"
  | ".epub"
  | ".jpg"
  | ".jpeg"
  | ".png"
  | ".gif"
  | ".bmp"
  | ".svg"
  | ".tiff"
  | ".webp"
  | ".html"
  | ".htm"
  | ".xls"
  | ".xlsx"
  | ".xlsm"
  | ".xlsb"
  | ".xlw"
  | ".csv"
  | ".dif"
  | ".sylk"
  | ".slk"
  | ".prn"
  | ".numbers"
  | ".et"
  | ".ods"
  | ".fods"
  | ".uos1"
  | ".uos2"
  | ".dbf"
  | ".wk1"
  | ".wk2"
  | ".wk3"
  | ".wk4"
  | ".wks"
  | ".wq1"
  | ".wq2"
  | ".wb1"
  | ".wb2"
  | ".wb3"
  | ".qpw"
  | ".xlr"
  | ".eth"
  | ".tsv";

export const LlamaParseSupportedFileExtensions = {
  ".PDF": ".pdf",
  ".DOC": ".doc",
  ".DOCX": ".docx",
  ".DOCM": ".docm",
  ".DOT": ".dot",
  ".DOTX": ".dotx",
  ".DOTM": ".dotm",
  ".RTF": ".rtf",
  ".WPS": ".wps",
  ".WPD": ".wpd",
  ".SXW": ".sxw",
  ".STW": ".stw",
  ".SXG": ".sxg",
  ".PAGES": ".pages",
  ".MW": ".mw",
  ".MCW": ".mcw",
  ".UOT": ".uot",
  ".UOF": ".uof",
  ".UOS": ".uos",
  ".UOP": ".uop",
  ".PPT": ".ppt",
  ".PPTX": ".pptx",
  ".POT": ".pot",
  ".PPTM": ".pptm",
  ".POTX": ".potx",
  ".POTM": ".potm",
  ".KEY": ".key",
  ".ODP": ".odp",
  ".ODG": ".odg",
  ".OTP": ".otp",
  ".FOPD": ".fopd",
  ".SXI": ".sxi",
  ".STI": ".sti",
  ".EPUB": ".epub",
  ".JPG": ".jpg",
  ".JPEG": ".jpeg",
  ".PNG": ".png",
  ".GIF": ".gif",
  ".BMP": ".bmp",
  ".SVG": ".svg",
  ".TIFF": ".tiff",
  ".WEBP": ".webp",
  ".HTML": ".html",
  ".HTM": ".htm",
  ".XLS": ".xls",
  ".XLSX": ".xlsx",
  ".XLSM": ".xlsm",
  ".XLSB": ".xlsb",
  ".XLW": ".xlw",
  ".CSV": ".csv",
  ".DIF": ".dif",
  ".SYLK": ".sylk",
  ".SLK": ".slk",
  ".PRN": ".prn",
  ".NUMBERS": ".numbers",
  ".ET": ".et",
  ".ODS": ".ods",
  ".FODS": ".fods",
  ".UOS1": ".uos1",
  ".UOS2": ".uos2",
  ".DBF": ".dbf",
  ".WK1": ".wk1",
  ".WK2": ".wk2",
  ".WK3": ".wk3",
  ".WK4": ".wk4",
  ".WKS": ".wks",
  ".WQ1": ".wq1",
  ".WQ2": ".wq2",
  ".WB1": ".wb1",
  ".WB2": ".wb2",
  ".WB3": ".wb3",
  ".QPW": ".qpw",
  ".XLR": ".xlr",
  ".ETH": ".eth",
  ".TSV": ".tsv",
} as const;

/**
 * Schema for the parameters of a load files job.
 */
export type LoadFilesJobConfig = {
  type?: "load_files";
  /**
   * The names of the files this execution should run against.
   */
  file_ids?: Array<string> | null;
};

/**
 * Status of managed ingestion with partial Updates.
 */
export type ManagedIngestionStatus =
  | "NOT_STARTED"
  | "IN_PROGRESS"
  | "SUCCESS"
  | "ERROR"
  | "PARTIAL_SUCCESS"
  | "CANCELLED";

/**
 * Status of managed ingestion with partial Updates.
 */
export const ManagedIngestionStatus = {
  NOT_STARTED: "NOT_STARTED",
  IN_PROGRESS: "IN_PROGRESS",
  SUCCESS: "SUCCESS",
  ERROR: "ERROR",
  PARTIAL_SUCCESS: "PARTIAL_SUCCESS",
  CANCELLED: "CANCELLED",
} as const;

export type ManagedIngestionStatusResponse = {
  /**
   * ID of the latest job.
   */
  job_id?: string | null;
  /**
   * Date of the deployment.
   */
  deployment_date?: string | null;
  /**
   * Status of the ingestion.
   */
  status: ManagedIngestionStatus;
  /**
   * List of errors that occurred during ingestion.
   */
  error?: Array<IngestionErrorResponse> | null;
  /**
   * When the status is effective
   */
  effective_at?: string | null;
};

export type ManagedOpenAiEmbedding = {
  /**
   * The name of the OpenAI embedding model.
   */
  model_name?: "openai-text-embedding-3-small";
  /**
   * The batch size for embedding calls.
   */
  embed_batch_size?: number;
  /**
   * The number of workers to use for async embedding calls.
   */
  num_workers?: number | null;
  class_name?: string;
};

export type ManagedOpenAiEmbeddingConfig = {
  /**
   * Type of the embedding model.
   */
  type?: "MANAGED_OPENAI_EMBEDDING";
  /**
   * Configuration for the Managed OpenAI embedding model.
   */
  component?: ManagedOpenAiEmbedding;
};

export type MessageAnnotation = {
  type: string;
  data: string;
  class_name?: string;
};

/**
 * Message role.
 */
export type MessageRole =
  | "system"
  | "developer"
  | "user"
  | "assistant"
  | "function"
  | "tool"
  | "chatbot"
  | "model";

/**
 * Message role.
 */
export const MessageRole = {
  SYSTEM: "system",
  DEVELOPER: "developer",
  USER: "user",
  ASSISTANT: "assistant",
  FUNCTION: "function",
  TOOL: "tool",
  CHATBOT: "chatbot",
  MODEL: "model",
} as const;

/**
 * Comprehensive metadata filter for vector stores to support more operators.
 *
 * Value uses Strict types, as int, float and str are compatible types and were all
 * converted to string before.
 *
 * See: https://docs.pydantic.dev/latest/usage/types/#strict-types
 */
export type MetadataFilter = {
  key: string;
  value:
    | number
    | number
    | string
    | Array<string>
    | Array<number>
    | Array<number>
    | null;
  operator?: FilterOperator;
};

/**
 * Metadata filters for vector stores.
 */
export type MetadataFilters = {
  filters: Array<MetadataFilter | MetadataFilters>;
  condition?: FilterCondition | null;
};

export type MetronomeDashboardResponse = {
  url: string;
};

export type MetronomeDashboardType = "invoices" | "usage";

export const MetronomeDashboardType = {
  INVOICES: "invoices",
  USAGE: "usage",
} as const;

export type MultimodalParseResolution = "medium" | "high";

export const MultimodalParseResolution = {
  MEDIUM: "medium",
  HIGH: "high",
} as const;

/**
 * Node relationships used in `BaseNode` class.
 *
 * Attributes:
 * SOURCE: The node is the source document.
 * PREVIOUS: The node is the previous node in the document.
 * NEXT: The node is the next node in the document.
 * PARENT: The node is the parent node in the document.
 * CHILD: The node is a child node in the document.
 */
export type NodeRelationship = "1" | "2" | "3" | "4" | "5";

/**
 * Node relationships used in `BaseNode` class.
 *
 * Attributes:
 * SOURCE: The node is the source document.
 * PREVIOUS: The node is the previous node in the document.
 * NEXT: The node is the next node in the document.
 * PARENT: The node is the parent node in the document.
 * CHILD: The node is a child node in the document.
 */
export const NodeRelationship = {
  1: "1",
  2: "2",
  3: "3",
  4: "4",
  5: "5",
} as const;

export type NoneChunkingConfig = {
  mode?: "none";
};

export type NoneSegmentationConfig = {
  mode?: "none";
};

export type ObjectType = "1" | "2" | "3" | "4" | "5";

export const ObjectType = {
  1: "1",
  2: "2",
  3: "3",
  4: "4",
  5: "5",
} as const;

export type OpenAiEmbedding = {
  /**
   * The name of the OpenAI embedding model.
   */
  model_name?: string;
  /**
   * The batch size for embedding calls.
   */
  embed_batch_size?: number;
  /**
   * The number of workers to use for async embedding calls.
   */
  num_workers?: number | null;
  /**
   * Additional kwargs for the OpenAI API.
   */
  additional_kwargs?: {
    [key: string]: unknown;
  };
  /**
   * The OpenAI API key.
   */
  api_key?: string | null;
  /**
   * The base URL for OpenAI API.
   */
  api_base?: string | null;
  /**
   * The version for OpenAI API.
   */
  api_version?: string | null;
  /**
   * Maximum number of retries.
   */
  max_retries?: number;
  /**
   * Timeout for each request.
   */
  timeout?: number;
  /**
   * The default headers for API requests.
   */
  default_headers?: {
    [key: string]: string;
  } | null;
  /**
   * Reuse the OpenAI client between requests. When doing anything with large volumes of async API calls, setting this to false can improve stability.
   */
  reuse_client?: boolean;
  /**
   * The number of dimensions on the output embedding vectors. Works only with v3 embedding models.
   */
  dimensions?: number | null;
  class_name?: string;
};

export type OpenAiEmbeddingConfig = {
  /**
   * Type of the embedding model.
   */
  type?: "OPENAI_EMBEDDING";
  /**
   * Configuration for the OpenAI embedding model.
   */
  component?: OpenAiEmbedding;
};

/**
 * Schema for an organization.
 */
export type Organization = {
  /**
   * Unique identifier
   */
  id: string;
  /**
   * Creation datetime
   */
  created_at?: string | null;
  /**
   * Update datetime
   */
  updated_at?: string | null;
  /**
   * A name for the organization.
   */
  name: string;
  /**
   * The Stripe customer ID for the organization.
   */
  stripe_customer_id?: string | null;
  /**
   * Whether the organization is a Parse Premium customer.
   */
  parse_plan_level?: ParsePlanLevel;
  /**
   * Feature flags for the organization.
   */
  feature_flags?: {
    [key: string]: unknown;
  } | null;
};

/**
 * Schema for creating an organization.
 */
export type OrganizationCreate = {
  /**
   * A name for the organization.
   */
  name: string;
};

/**
 * Schema for updating an organization.
 */
export type OrganizationUpdate = {
  /**
   * A name for the organization.
   */
  name: string;
  /**
   * Feature flags for the organization.
   */
  feature_flags?: {
    [key: string]: unknown;
  } | null;
};

/**
 * Distance methods for PGVector.
 * Docs:
 * https://github.com/pgvector/pgvector?tab=readme-ov-file#query-options
 */
export type PgVectorDistanceMethod =
  | "l2"
  | "ip"
  | "cosine"
  | "l1"
  | "hamming"
  | "jaccard";

/**
 * Distance methods for PGVector.
 * Docs:
 * https://github.com/pgvector/pgvector?tab=readme-ov-file#query-options
 */
export const PgVectorDistanceMethod = {
  L2: "l2",
  IP: "ip",
  COSINE: "cosine",
  L1: "l1",
  HAMMING: "hamming",
  JACCARD: "jaccard",
} as const;

/**
 * HNSW settings for PGVector.
 */
export type PgVectorHnswSettings = {
  /**
   * The number of edges to use during the construction phase.
   */
  ef_construction?: number;
  /**
   * The number of edges to use during the search phase.
   */
  ef_search?: number;
  /**
   * The number of bi-directional links created for each new element.
   */
  m?: number;
  /**
   * The type of vector to use.
   */
  vector_type?: PgVectorVectorType;
  /**
   * The distance method to use.
   */
  distance_method?: PgVectorDistanceMethod;
};

/**
 * Vector storage formats for PGVector.
 * Docs:
 * https://github.com/pgvector/pgvector?tab=readme-ov-file#query-options
 */
export type PgVectorVectorType = "vector" | "half_vec" | "bit" | "sparse_vec";

/**
 * Vector storage formats for PGVector.
 * Docs:
 * https://github.com/pgvector/pgvector?tab=readme-ov-file#query-options
 */
export const PgVectorVectorType = {
  VECTOR: "vector",
  HALF_VEC: "half_vec",
  BIT: "bit",
  SPARSE_VEC: "sparse_vec",
} as const;

export type PageFigureMetadata = {
  /**
   * The name of the figure
   */
  figure_name: string;
  /**
   * The ID of the file that the figure was taken from
   */
  file_id: string;
  /**
   * The index of the page for which the figure is taken (0-indexed)
   */
  page_index: number;
  /**
   * The size of the figure in bytes
   */
  figure_size: number;
  /**
   * Whether the figure is likely to be noise
   */
  is_likely_noise?: boolean;
  /**
   * The confidence of the figure
   */
  confidence: number;
  /**
   * Metadata for the figure
   */
  metadata?: {
    [key: string]: unknown;
  } | null;
};

/**
 * Page figure metadata with score
 */
export type PageFigureNodeWithScore = {
  node: PageFigureMetadata;
  /**
   * The score of the figure node
   */
  score: number;
  class_name?: string;
};

export type PageScreenshotMetadata = {
  /**
   * The index of the page for which the screenshot is taken (0-indexed)
   */
  page_index: number;
  /**
   * The ID of the file that the page screenshot was taken from
   */
  file_id: string;
  /**
   * The size of the image in bytes
   */
  image_size: number;
  /**
   * Metadata for the screenshot
   */
  metadata?: {
    [key: string]: unknown;
  } | null;
};

/**
 * Page screenshot metadata with score
 */
export type PageScreenshotNodeWithScore = {
  node: PageScreenshotMetadata;
  /**
   * The score of the screenshot node
   */
  score: number;
  class_name?: string;
};

export type PageSegmentationConfig = {
  mode?: "page";
  page_separator?: string;
};

/**
 * Schema for paginated extraction runs response.
 */
export type PaginatedExtractRunsResponse = {
  /**
   * The list of extraction runs
   */
  items: Array<ExtractRun>;
  /**
   * The total number of extraction runs
   */
  total: number;
  /**
   * The number of extraction runs skipped
   */
  skip: number;
  /**
   * The maximum number of extraction runs returned
   */
  limit: number;
};

export type PaginatedJobsHistoryWithMetrics = {
  jobs: Array<JobRecordWithUsageMetrics>;
  total_count: number;
  limit: number;
  offset: number;
};

export type PaginatedListCloudDocumentsResponse = {
  /**
   * The documents to list
   */
  documents: Array<CloudDocument>;
  /**
   * The limit of the documents
   */
  limit: number;
  /**
   * The offset of the documents
   */
  offset: number;
  /**
   * The total number of documents
   */
  total_count: number;
};

export type PaginatedListPipelineFilesResponse = {
  /**
   * The files to list
   */
  files: Array<PipelineFile>;
  /**
   * The limit of the files
   */
  limit: number;
  /**
   * The offset of the files
   */
  offset: number;
  /**
   * The total number of files
   */
  total_count: number;
};

export type PaginatedResponseAgentData = {
  /**
   * The list of items.
   */
  items: Array<AgentData>;
  /**
   * A token, which can be sent as page_token to retrieve the next page. If this field is omitted, there are no subsequent pages.
   */
  next_page_token?: string | null;
  /**
   * The total number of items available. This is only populated when specifically requested. The value may be an estimate and can be used for display purposes only.
   */
  total_size?: number | null;
};

export type PaginatedResponseAggregateGroup = {
  /**
   * The list of items.
   */
  items: Array<AggregateGroup>;
  /**
   * A token, which can be sent as page_token to retrieve the next page. If this field is omitted, there are no subsequent pages.
   */
  next_page_token?: string | null;
  /**
   * The total number of items available. This is only populated when specifically requested. The value may be an estimate and can be used for display purposes only.
   */
  total_size?: number | null;
};

export type PaginatedResponseClassifyJob = {
  /**
   * The list of items.
   */
  items: Array<ClassifyJob>;
  /**
   * A token, which can be sent as page_token to retrieve the next page. If this field is omitted, there are no subsequent pages.
   */
  next_page_token?: string | null;
  /**
   * The total number of items available. This is only populated when specifically requested. The value may be an estimate and can be used for display purposes only.
   */
  total_size?: number | null;
};

export type PaginatedResponseQuotaConfiguration = {
  total: number;
  page: number;
  size: number;
  pages: number;
  items: Array<QuotaConfiguration>;
};

/**
 * Parse configuration schema.
 */
export type ParseConfiguration = {
  /**
   * Unique identifier for the parse configuration
   */
  id: string;
  /**
   * Name of the parse configuration
   */
  name: string;
  /**
   * Type of the source (e.g., 'project')
   */
  source_type: string;
  /**
   * ID of the source
   */
  source_id: string;
  /**
   * Creator of the configuration
   */
  creator?: string | null;
  /**
   * Version of the configuration
   */
  version: string;
  /**
   * LlamaParseParameters configuration
   */
  parameters: LlamaParseParameters;
  /**
   * Creation timestamp
   */
  created_at: string;
  /**
   * Last update timestamp
   */
  updated_at: string;
};

/**
 * Schema for creating a new parse configuration (API boundary).
 */
export type ParseConfigurationCreate = {
  /**
   * Name of the parse configuration
   */
  name: string;
  /**
   * Type of the source (e.g., 'project')
   */
  source_type?: string | null;
  /**
   * ID of the source
   */
  source_id?: string | null;
  /**
   * Creator of the configuration
   */
  creator?: string | null;
  /**
   * Version of the configuration
   */
  version: string;
  /**
   * LlamaParseParameters configuration
   */
  parameters: LlamaParseParameters;
};

/**
 * Filter parameters for parse configuration queries.
 */
export type ParseConfigurationFilter = {
  /**
   * Filter by name
   */
  name?: string | null;
  /**
   * Filter by source type
   */
  source_type?: string | null;
  /**
   * Filter by source ID
   */
  source_id?: string | null;
  /**
   * Filter by creator
   */
  creator?: string | null;
  /**
   * Filter by version
   */
  version?: string | null;
  /**
   * Filter by specific parse configuration IDs
   */
  parse_config_ids?: Array<string> | null;
};

/**
 * Request schema for querying parse configurations with pagination and filtering.
 */
export type ParseConfigurationQueryRequest = {
  /**
   * The maximum number of items to return. The service may return fewer than this value. If unspecified, a default page size will be used. The maximum value is typically 1000; values above this will be coerced to the maximum.
   */
  page_size?: number | null;
  /**
   * A page token, received from a previous list call. Provide this to retrieve the subsequent page.
   */
  page_token?: string | null;
  /**
   * A filter object or expression that filters resources listed in the response.
   */
  filter?: ParseConfigurationFilter | null;
  /**
   * A comma-separated list of fields to order by, sorted in ascending order. Use 'field_name desc' to specify descending order.
   */
  order_by?: string | null;
};

/**
 * Response schema for paginated parse configuration queries.
 */
export type ParseConfigurationQueryResponse = {
  /**
   * The list of items.
   */
  items: Array<ParseConfiguration>;
  /**
   * A token, which can be sent as page_token to retrieve the next page. If this field is omitted, there are no subsequent pages.
   */
  next_page_token?: string | null;
  /**
   * The total number of items available. This is only populated when specifically requested. The value may be an estimate and can be used for display purposes only.
   */
  total_size?: number | null;
};

/**
 * Schema for updating an existing parse configuration.
 */
export type ParseConfigurationUpdate = {
  /**
   * Updated LlamaParseParameters configuration
   */
  parameters?: LlamaParseParameters | null;
};

/**
 * Configuration for llamaparse job
 */
export type ParseJobConfig = {
  /**
   * The outbound webhook configurations
   */
  webhook_configurations?: Array<WebhookConfiguration> | null;
  /**
   * The priority for the request. This field may be ignored or overwritten depending on the organization tier.
   */
  priority?: ("low" | "medium" | "high" | "critical") | null;
  /**
   * The custom metadata to attach to the documents.
   */
  custom_metadata?: {
    [key: string]: unknown;
  } | null;
  /**
   * The resource info about the file
   */
  resource_info?: {
    [key: string]: unknown;
  } | null;
  languages?: Array<ParserLanguages>;
  parsing_instruction?: string | null;
  disable_ocr?: boolean | null;
  annotate_links?: boolean | null;
  adaptive_long_table?: boolean | null;
  compact_markdown_table?: boolean | null;
  disable_reconstruction?: boolean | null;
  disable_image_extraction?: boolean | null;
  invalidate_cache?: boolean | null;
  outlined_table_extraction?: boolean | null;
  merge_tables_across_pages_in_markdown?: boolean | null;
  output_pdf_of_document?: boolean | null;
  do_not_cache?: boolean | null;
  fast_mode?: boolean | null;
  skip_diagonal_text?: boolean | null;
  preserve_layout_alignment_across_pages?: boolean | null;
  preserve_very_small_text?: boolean | null;
  gpt4o_mode?: boolean | null;
  gpt4o_api_key?: string | null;
  do_not_unroll_columns?: boolean | null;
  extract_layout?: boolean | null;
  high_res_ocr?: boolean | null;
  html_make_all_elements_visible?: boolean | null;
  layout_aware?: boolean | null;
  specialized_chart_parsing_agentic?: boolean | null;
  specialized_chart_parsing_plus?: boolean | null;
  specialized_chart_parsing_efficient?: boolean | null;
  specialized_image_parsing?: boolean | null;
  precise_bounding_box?: boolean | null;
  html_remove_navigation_elements?: boolean | null;
  html_remove_fixed_elements?: boolean | null;
  guess_xlsx_sheet_name?: boolean | null;
  page_separator?: string | null;
  bounding_box?: string | null;
  bbox_top?: number | null;
  bbox_right?: number | null;
  bbox_bottom?: number | null;
  bbox_left?: number | null;
  target_pages?: string | null;
  use_vendor_multimodal_model?: boolean | null;
  vendor_multimodal_model_name?: string | null;
  model?: string | null;
  vendor_multimodal_api_key?: string | null;
  page_prefix?: string | null;
  page_suffix?: string | null;
  webhook_url?: string | null;
  preset?: string | null;
  take_screenshot?: boolean | null;
  is_formatting_instruction?: boolean | null;
  premium_mode?: boolean | null;
  continuous_mode?: boolean | null;
  /**
   * If specified, llamaParse will take the specified file. should be a valid s3:// url
   */
  input_s3_path?: string | null;
  /**
   * The region for the input S3 bucket.
   */
  input_s3_region?: string | null;
  /**
   * If specified, llamaParse will save the output to the specified path. All output file will use this 'prefix' should be a valid s3:// url
   */
  output_s3_path_prefix?: string | null;
  /**
   * The region for the output S3 bucket.
   */
  output_s3_region?: string | null;
  project_id?: string | null;
  azure_openai_deployment_name?: string | null;
  azure_openai_endpoint?: string | null;
  azure_openai_api_version?: string | null;
  azure_openai_key?: string | null;
  input_url?: string | null;
  http_proxy?: string | null;
  auto_mode?: boolean | null;
  auto_mode_trigger_on_regexp_in_page?: string | null;
  auto_mode_trigger_on_text_in_page?: string | null;
  auto_mode_trigger_on_table_in_page?: boolean | null;
  auto_mode_trigger_on_image_in_page?: boolean | null;
  auto_mode_configuration_json?: string | null;
  structured_output?: boolean | null;
  structured_output_json_schema?: string | null;
  structured_output_json_schema_name?: string | null;
  max_pages?: number | null;
  max_pages_enforced?: number | null;
  extract_charts?: boolean | null;
  formatting_instruction?: string | null;
  complemental_formatting_instruction?: string | null;
  content_guideline_instruction?: string | null;
  spreadsheet_extract_sub_tables?: boolean | null;
  spreadsheet_force_formula_computation?: boolean | null;
  inline_images_in_markdown?: boolean | null;
  job_timeout_in_seconds?: number | null;
  job_timeout_extra_time_per_page_in_seconds?: number | null;
  strict_mode_image_extraction?: boolean | null;
  strict_mode_image_ocr?: boolean | null;
  strict_mode_reconstruction?: boolean | null;
  strict_mode_buggy_font?: boolean | null;
  save_images?: boolean | null;
  hide_headers?: boolean | null;
  hide_footers?: boolean | null;
  page_header_prefix?: string | null;
  page_header_suffix?: string | null;
  page_footer_prefix?: string | null;
  page_footer_suffix?: string | null;
  ignore_document_elements_for_layout_detection?: boolean | null;
  output_tables_as_HTML?: boolean | null;
  internal_is_screenshot_job?: boolean | null;
  parse_mode?: ParsingMode | null;
  system_prompt?: string | null;
  system_prompt_append?: string | null;
  user_prompt?: string | null;
  page_error_tolerance?: number | null;
  replace_failed_page_mode?: FailPageMode | null;
  replace_failed_page_with_error_message_prefix?: string | null;
  replace_failed_page_with_error_message_suffix?: string | null;
  markdown_table_multiline_header_separator?: string | null;
  type?: "parse";
  /**
   * The file name.
   */
  file_name: string;
  /**
   * The original file name.
   */
  original_file_name: string;
  /**
   * The file key.
   */
  file_key: string;
  /**
   * The language.
   */
  lang: string;
  /**
   * The output bucket.
   */
  outputBucket?: string | null;
  /**
   * The file ID.
   */
  file_id?: string | null;
  /**
   * The pipeline ID.
   */
  pipeline_id?: string | null;
};

/**
 * Enum for the Parse plan level.
 */
export type ParsePlanLevel = "DEFAULT" | "PREMIUM";

/**
 * Enum for the Parse plan level.
 */
export const ParsePlanLevel = {
  DEFAULT: "DEFAULT",
  PREMIUM: "PREMIUM",
} as const;

/**
 * Enum for representing the languages supported by the parser
 */
export type ParserLanguages =
  | "af"
  | "az"
  | "bs"
  | "cs"
  | "cy"
  | "da"
  | "de"
  | "en"
  | "es"
  | "et"
  | "fr"
  | "ga"
  | "hr"
  | "hu"
  | "id"
  | "is"
  | "it"
  | "ku"
  | "la"
  | "lt"
  | "lv"
  | "mi"
  | "ms"
  | "mt"
  | "nl"
  | "no"
  | "oc"
  | "pi"
  | "pl"
  | "pt"
  | "ro"
  | "rs_latin"
  | "sk"
  | "sl"
  | "sq"
  | "sv"
  | "sw"
  | "tl"
  | "tr"
  | "uz"
  | "vi"
  | "ar"
  | "fa"
  | "ug"
  | "ur"
  | "bn"
  | "as"
  | "mni"
  | "ru"
  | "rs_cyrillic"
  | "be"
  | "bg"
  | "uk"
  | "mn"
  | "abq"
  | "ady"
  | "kbd"
  | "ava"
  | "dar"
  | "inh"
  | "che"
  | "lbe"
  | "lez"
  | "tab"
  | "tjk"
  | "hi"
  | "mr"
  | "ne"
  | "bh"
  | "mai"
  | "ang"
  | "bho"
  | "mah"
  | "sck"
  | "new"
  | "gom"
  | "sa"
  | "bgc"
  | "th"
  | "ch_sim"
  | "ch_tra"
  | "ja"
  | "ko"
  | "ta"
  | "te"
  | "kn";

/**
 * Enum for representing the languages supported by the parser
 */
export const ParserLanguages = {
  AF: "af",
  AZ: "az",
  BS: "bs",
  CS: "cs",
  CY: "cy",
  DA: "da",
  DE: "de",
  EN: "en",
  ES: "es",
  ET: "et",
  FR: "fr",
  GA: "ga",
  HR: "hr",
  HU: "hu",
  ID: "id",
  IS: "is",
  IT: "it",
  KU: "ku",
  LA: "la",
  LT: "lt",
  LV: "lv",
  MI: "mi",
  MS: "ms",
  MT: "mt",
  NL: "nl",
  NO: "no",
  OC: "oc",
  PI: "pi",
  PL: "pl",
  PT: "pt",
  RO: "ro",
  RS_LATIN: "rs_latin",
  SK: "sk",
  SL: "sl",
  SQ: "sq",
  SV: "sv",
  SW: "sw",
  TL: "tl",
  TR: "tr",
  UZ: "uz",
  VI: "vi",
  AR: "ar",
  FA: "fa",
  UG: "ug",
  UR: "ur",
  BN: "bn",
  AS: "as",
  MNI: "mni",
  RU: "ru",
  RS_CYRILLIC: "rs_cyrillic",
  BE: "be",
  BG: "bg",
  UK: "uk",
  MN: "mn",
  ABQ: "abq",
  ADY: "ady",
  KBD: "kbd",
  AVA: "ava",
  DAR: "dar",
  INH: "inh",
  CHE: "che",
  LBE: "lbe",
  LEZ: "lez",
  TAB: "tab",
  TJK: "tjk",
  HI: "hi",
  MR: "mr",
  NE: "ne",
  BH: "bh",
  MAI: "mai",
  ANG: "ang",
  BHO: "bho",
  MAH: "mah",
  SCK: "sck",
  NEW: "new",
  GOM: "gom",
  SA: "sa",
  BGC: "bgc",
  TH: "th",
  CH_SIM: "ch_sim",
  CH_TRA: "ch_tra",
  JA: "ja",
  KO: "ko",
  TA: "ta",
  TE: "te",
  KN: "kn",
} as const;

export type ParsingHistoryItem = {
  user_id: string;
  day: string;
  job_id: string;
  file_name: string;
  original_file_name: string;
  expired?: boolean;
  pages?: number | null;
  images?: number | null;
  time?: number | null;
};

export type ParsingJob = {
  id: string;
  status: StatusEnum;
  error_code?: string | null;
  error_message?: string | null;
};

export type ParsingJobJsonResult = {
  /**
   * The json result of the parsing job
   */
  pages: unknown;
  /**
   * Parsing job metadata , including usage
   */
  job_metadata: unknown;
};

export type ParsingJobMarkdownResult = {
  /**
   * The markdown result of the parsing job
   */
  markdown: string;
  /**
   * Parsing job metadata , including usage
   */
  job_metadata: unknown;
};

export type ParsingJobStructuredResult = {
  /**
   * The json result of the structured parsing job
   */
  structured: unknown;
  /**
   * Parsing job metadata , including usage
   */
  job_metadata: unknown;
};

export type ParsingJobTextResult = {
  /**
   * The text result of the parsing job
   */
  text: string;
  /**
   * Parsing job metadata , including usage
   */
  job_metadata: unknown;
};

/**
 * Enum for representing the mode of parsing to be used
 */
export type ParsingMode =
  | "parse_page_without_llm"
  | "parse_page_with_llm"
  | "parse_page_with_lvm"
  | "parse_page_with_agent"
  | "parse_page_with_layout_agent"
  | "parse_document_with_llm"
  | "parse_document_with_lvm"
  | "parse_document_with_agent";

/**
 * Enum for representing the mode of parsing to be used
 */
export const ParsingMode = {
  PARSE_PAGE_WITHOUT_LLM: "parse_page_without_llm",
  PARSE_PAGE_WITH_LLM: "parse_page_with_llm",
  PARSE_PAGE_WITH_LVM: "parse_page_with_lvm",
  PARSE_PAGE_WITH_AGENT: "parse_page_with_agent",
  PARSE_PAGE_WITH_LAYOUT_AGENT: "parse_page_with_layout_agent",
  PARSE_DOCUMENT_WITH_LLM: "parse_document_with_llm",
  PARSE_DOCUMENT_WITH_LVM: "parse_document_with_lvm",
  PARSE_DOCUMENT_WITH_AGENT: "parse_document_with_agent",
} as const;

/**
 * Enum for dataset partition names.
 */
export type PartitionNames =
  | "data_source_id_partition"
  | "pipeline_id_partition"
  | "eval_dataset_id_partition"
  | "file_id_partition"
  | "pipeline_file_id_partition"
  | "file_parsing_id_partition"
  | "extraction_schema_id_partition";

/**
 * Enum for dataset partition names.
 */
export const PartitionNames = {
  DATA_SOURCE_ID_PARTITION: "data_source_id_partition",
  PIPELINE_ID_PARTITION: "pipeline_id_partition",
  EVAL_DATASET_ID_PARTITION: "eval_dataset_id_partition",
  FILE_ID_PARTITION: "file_id_partition",
  PIPELINE_FILE_ID_PARTITION: "pipeline_file_id_partition",
  FILE_PARSING_ID_PARTITION: "file_parsing_id_partition",
  EXTRACTION_SCHEMA_ID_PARTITION: "extraction_schema_id_partition",
} as const;

/**
 * Schema for a permission.
 */
export type Permission = {
  /**
   * Unique identifier
   */
  id: string;
  /**
   * Creation datetime
   */
  created_at?: string | null;
  /**
   * Update datetime
   */
  updated_at?: string | null;
  /**
   * A name for the permission.
   */
  name: string;
  /**
   * A description for the permission.
   */
  description: string | null;
  /**
   * Whether the permission is granted or not.
   */
  access: boolean;
};

/**
 * Schema for a pipeline.
 */
export type PipelineReadable = {
  /**
   * Unique identifier
   */
  id: string;
  /**
   * Creation datetime
   */
  created_at?: string | null;
  /**
   * Update datetime
   */
  updated_at?: string | null;
  name: string;
  project_id: string;
  /**
   * The ID of the EmbeddingModelConfig this pipeline is using.
   */
  embedding_model_config_id?: string | null;
  /**
   * The embedding model configuration for this pipeline.
   */
  embedding_model_config?: EmbeddingModelConfig | null;
  /**
   * Type of pipeline. Either PLAYGROUND or MANAGED.
   */
  pipeline_type?: PipelineType;
  /**
   * The ID of the ManagedPipeline this playground pipeline is linked to.
   */
  managed_pipeline_id?: string | null;
  embedding_config:
    | ({
        type: "MANAGED_OPENAI_EMBEDDING";
      } & ManagedOpenAiEmbeddingConfig)
    | ({
        type: "AZURE_EMBEDDING";
      } & AzureOpenAiEmbeddingConfig)
    | ({
        type: "COHERE_EMBEDDING";
      } & CohereEmbeddingConfig)
    | ({
        type: "GEMINI_EMBEDDING";
      } & GeminiEmbeddingConfig)
    | ({
        type: "HUGGINGFACE_API_EMBEDDING";
      } & HuggingFaceInferenceApiEmbeddingConfig)
    | ({
        type: "OPENAI_EMBEDDING";
      } & OpenAiEmbeddingConfig)
    | ({
        type: "VERTEXAI_EMBEDDING";
      } & VertexAiEmbeddingConfig)
    | ({
        type: "BEDROCK_EMBEDDING";
      } & BedrockEmbeddingConfig);
  /**
   * Configuration for the sparse model used in hybrid search.
   */
  sparse_model_config?: SparseModelConfig | null;
  /**
   * Hashes for the configuration of the pipeline.
   */
  config_hash?: PipelineConfigurationHashes | null;
  /**
   * Configuration for the transformation.
   */
  transform_config?: AutoTransformConfig | AdvancedModeTransformConfig;
  /**
   * Preset retrieval parameters for the pipeline.
   */
  preset_retrieval_parameters?: PresetRetrievalParams;
  /**
   * Eval parameters for the pipeline.
   */
  eval_parameters?: EvalExecutionParams;
  /**
   * Settings that can be configured for how to use LlamaParse to parse files within a LlamaCloud pipeline.
   */
  llama_parse_parameters?: LlamaParseParameters | null;
  /**
   * The data sink for the pipeline. If None, the pipeline will use the fully managed data sink.
   */
  data_sink?: DataSinkReadable | null;
  /**
   * Status of the pipeline.
   */
  status?: ("CREATED" | "DELETING") | null;
  /**
   * Metadata configuration for the pipeline.
   */
  metadata_config?: PipelineMetadataConfig | null;
};

/**
 * Schema for a pipeline.
 */
export type PipelineWritable = {
  /**
   * Unique identifier
   */
  id: string;
  /**
   * Creation datetime
   */
  created_at?: string | null;
  /**
   * Update datetime
   */
  updated_at?: string | null;
  name: string;
  project_id: string;
  /**
   * The ID of the EmbeddingModelConfig this pipeline is using.
   */
  embedding_model_config_id?: string | null;
  /**
   * The embedding model configuration for this pipeline.
   */
  embedding_model_config?: EmbeddingModelConfig | null;
  /**
   * Type of pipeline. Either PLAYGROUND or MANAGED.
   */
  pipeline_type?: PipelineType;
  /**
   * The ID of the ManagedPipeline this playground pipeline is linked to.
   */
  managed_pipeline_id?: string | null;
  embedding_config:
    | ({
        type: "MANAGED_OPENAI_EMBEDDING";
      } & ManagedOpenAiEmbeddingConfig)
    | ({
        type: "AZURE_EMBEDDING";
      } & AzureOpenAiEmbeddingConfig)
    | ({
        type: "COHERE_EMBEDDING";
      } & CohereEmbeddingConfig)
    | ({
        type: "GEMINI_EMBEDDING";
      } & GeminiEmbeddingConfig)
    | ({
        type: "HUGGINGFACE_API_EMBEDDING";
      } & HuggingFaceInferenceApiEmbeddingConfig)
    | ({
        type: "OPENAI_EMBEDDING";
      } & OpenAiEmbeddingConfig)
    | ({
        type: "VERTEXAI_EMBEDDING";
      } & VertexAiEmbeddingConfig)
    | ({
        type: "BEDROCK_EMBEDDING";
      } & BedrockEmbeddingConfig);
  /**
   * Configuration for the sparse model used in hybrid search.
   */
  sparse_model_config?: SparseModelConfig | null;
  /**
   * Hashes for the configuration of the pipeline.
   */
  config_hash?: PipelineConfigurationHashes | null;
  /**
   * Configuration for the transformation.
   */
  transform_config?: AutoTransformConfig | AdvancedModeTransformConfig;
  /**
   * Preset retrieval parameters for the pipeline.
   */
  preset_retrieval_parameters?: PresetRetrievalParams;
  /**
   * Eval parameters for the pipeline.
   */
  eval_parameters?: EvalExecutionParams;
  /**
   * Settings that can be configured for how to use LlamaParse to parse files within a LlamaCloud pipeline.
   */
  llama_parse_parameters?: LlamaParseParameters | null;
  /**
   * The data sink for the pipeline. If None, the pipeline will use the fully managed data sink.
   */
  data_sink?: DataSinkWritable | null;
  /**
   * Status of the pipeline.
   */
  status?: ("CREATED" | "DELETING") | null;
  /**
   * Metadata configuration for the pipeline.
   */
  metadata_config?: PipelineMetadataConfig | null;
};

/**
 * Hashes for the configuration of a pipeline.
 */
export type PipelineConfigurationHashes = {
  /**
   * Hash of the embedding config.
   */
  embedding_config_hash?: string | null;
  /**
   * Hash of the llama parse parameters.
   */
  parsing_config_hash?: string | null;
  /**
   * Hash of the transform config.
   */
  transform_config_hash?: string | null;
};

/**
 * Schema for creating a pipeline.
 */
export type PipelineCreateReadable = {
  embedding_config?:
    | (
        | ({
            type: "AZURE_EMBEDDING";
          } & AzureOpenAiEmbeddingConfig)
        | ({
            type: "COHERE_EMBEDDING";
          } & CohereEmbeddingConfig)
        | ({
            type: "GEMINI_EMBEDDING";
          } & GeminiEmbeddingConfig)
        | ({
            type: "HUGGINGFACE_API_EMBEDDING";
          } & HuggingFaceInferenceApiEmbeddingConfig)
        | ({
            type: "OPENAI_EMBEDDING";
          } & OpenAiEmbeddingConfig)
        | ({
            type: "VERTEXAI_EMBEDDING";
          } & VertexAiEmbeddingConfig)
        | ({
            type: "BEDROCK_EMBEDDING";
          } & BedrockEmbeddingConfig)
      )
    | null;
  /**
   * Configuration for the transformation.
   */
  transform_config?: AutoTransformConfig | AdvancedModeTransformConfig | null;
  /**
   * Configuration for the sparse model used in hybrid search.
   */
  sparse_model_config?: SparseModelConfig | null;
  /**
   * Data sink ID. When provided instead of data_sink, the data sink will be looked up by ID.
   */
  data_sink_id?: string | null;
  /**
   * Embedding model config ID. When provided instead of embedding_config, the embedding model config will be looked up by ID.
   */
  embedding_model_config_id?: string | null;
  /**
   * Data sink. When provided instead of data_sink_id, the data sink will be created.
   */
  data_sink?: DataSinkCreateReadable | null;
  /**
   * Preset retrieval parameters for the pipeline.
   */
  preset_retrieval_parameters?: PresetRetrievalParams;
  /**
   * Eval parameters for the pipeline.
   */
  eval_parameters?: EvalExecutionParams;
  llama_parse_parameters?: LlamaParseParameters;
  /**
   * Status of the pipeline deployment.
   */
  status?: string | null;
  /**
   * Metadata configuration for the pipeline.
   */
  metadata_config?: PipelineMetadataConfig | null;
  name: string;
  /**
   * Type of pipeline. Either PLAYGROUND or MANAGED.
   */
  pipeline_type?: PipelineType;
  /**
   * The ID of the ManagedPipeline this playground pipeline is linked to.
   */
  managed_pipeline_id?: string | null;
};

/**
 * Schema for creating a pipeline.
 */
export type PipelineCreateWritable = {
  embedding_config?:
    | (
        | ({
            type: "AZURE_EMBEDDING";
          } & AzureOpenAiEmbeddingConfig)
        | ({
            type: "COHERE_EMBEDDING";
          } & CohereEmbeddingConfig)
        | ({
            type: "GEMINI_EMBEDDING";
          } & GeminiEmbeddingConfig)
        | ({
            type: "HUGGINGFACE_API_EMBEDDING";
          } & HuggingFaceInferenceApiEmbeddingConfig)
        | ({
            type: "OPENAI_EMBEDDING";
          } & OpenAiEmbeddingConfig)
        | ({
            type: "VERTEXAI_EMBEDDING";
          } & VertexAiEmbeddingConfig)
        | ({
            type: "BEDROCK_EMBEDDING";
          } & BedrockEmbeddingConfig)
      )
    | null;
  /**
   * Configuration for the transformation.
   */
  transform_config?: AutoTransformConfig | AdvancedModeTransformConfig | null;
  /**
   * Configuration for the sparse model used in hybrid search.
   */
  sparse_model_config?: SparseModelConfig | null;
  /**
   * Data sink ID. When provided instead of data_sink, the data sink will be looked up by ID.
   */
  data_sink_id?: string | null;
  /**
   * Embedding model config ID. When provided instead of embedding_config, the embedding model config will be looked up by ID.
   */
  embedding_model_config_id?: string | null;
  /**
   * Data sink. When provided instead of data_sink_id, the data sink will be created.
   */
  data_sink?: DataSinkCreateWritable | null;
  /**
   * Preset retrieval parameters for the pipeline.
   */
  preset_retrieval_parameters?: PresetRetrievalParams;
  /**
   * Eval parameters for the pipeline.
   */
  eval_parameters?: EvalExecutionParams;
  llama_parse_parameters?: LlamaParseParameters;
  /**
   * Status of the pipeline deployment.
   */
  status?: string | null;
  /**
   * Metadata configuration for the pipeline.
   */
  metadata_config?: PipelineMetadataConfig | null;
  name: string;
  /**
   * Type of pipeline. Either PLAYGROUND or MANAGED.
   */
  pipeline_type?: PipelineType;
  /**
   * The ID of the ManagedPipeline this playground pipeline is linked to.
   */
  managed_pipeline_id?: string | null;
};

/**
 * Schema for a data source in a pipeline.
 */
export type PipelineDataSourceReadable = {
  /**
   * Unique identifier
   */
  id: string;
  /**
   * Creation datetime
   */
  created_at?: string | null;
  /**
   * Update datetime
   */
  updated_at?: string | null;
  /**
   * The name of the data source.
   */
  name: string;
  source_type: ConfigurableDataSourceNames;
  /**
   * Custom metadata that will be present on all data loaded from the data source
   */
  custom_metadata?: {
    [key: string]:
      | {
          [key: string]: unknown;
        }
      | Array<unknown>
      | string
      | number
      | number
      | boolean
      | null;
  } | null;
  /**
   * Component that implements the data source
   */
  component:
    | {
        [key: string]: unknown;
      }
    | CloudS3DataSourceReadable
    | CloudAzStorageBlobDataSourceReadable
    | CloudOneDriveDataSourceReadable
    | CloudSharepointDataSourceReadable
    | CloudSlackDataSourceReadable
    | CloudNotionPageDataSourceReadable
    | CloudConfluenceDataSourceReadable
    | CloudJiraDataSourceReadable
    | CloudJiraDataSourceV2Readable
    | CloudBoxDataSourceReadable;
  /**
   * Version metadata for the data source
   */
  version_metadata?: DataSourceReaderVersionMetadata | null;
  project_id: string;
  /**
   * The ID of the data source.
   */
  data_source_id: string;
  /**
   * The ID of the pipeline.
   */
  pipeline_id: string;
  /**
   * The last time the data source was automatically synced.
   */
  last_synced_at: string;
  /**
   * The interval at which the data source should be synced.
   */
  sync_interval?: number | null;
  /**
   * The id of the user who set the sync schedule.
   */
  sync_schedule_set_by?: string | null;
  /**
   * The status of the data source in the pipeline.
   */
  status?:
    | ("NOT_STARTED" | "IN_PROGRESS" | "SUCCESS" | "ERROR" | "CANCELLED")
    | null;
  /**
   * The last time the status was updated.
   */
  status_updated_at?: string | null;
};

/**
 * Schema for a data source in a pipeline.
 */
export type PipelineDataSourceWritable = {
  /**
   * Unique identifier
   */
  id: string;
  /**
   * Creation datetime
   */
  created_at?: string | null;
  /**
   * Update datetime
   */
  updated_at?: string | null;
  /**
   * The name of the data source.
   */
  name: string;
  source_type: ConfigurableDataSourceNames;
  /**
   * Custom metadata that will be present on all data loaded from the data source
   */
  custom_metadata?: {
    [key: string]:
      | {
          [key: string]: unknown;
        }
      | Array<unknown>
      | string
      | number
      | number
      | boolean
      | null;
  } | null;
  /**
   * Component that implements the data source
   */
  component:
    | {
        [key: string]: unknown;
      }
    | CloudS3DataSourceWritable
    | CloudAzStorageBlobDataSourceWritable
    | CloudOneDriveDataSourceWritable
    | CloudSharepointDataSourceWritable
    | CloudSlackDataSourceWritable
    | CloudNotionPageDataSourceWritable
    | CloudConfluenceDataSourceWritable
    | CloudJiraDataSourceWritable
    | CloudJiraDataSourceV2Writable
    | CloudBoxDataSourceWritable;
  /**
   * Version metadata for the data source
   */
  version_metadata?: DataSourceReaderVersionMetadata | null;
  project_id: string;
  /**
   * The ID of the data source.
   */
  data_source_id: string;
  /**
   * The ID of the pipeline.
   */
  pipeline_id: string;
  /**
   * The last time the data source was automatically synced.
   */
  last_synced_at: string;
  /**
   * The interval at which the data source should be synced.
   */
  sync_interval?: number | null;
  /**
   * The id of the user who set the sync schedule.
   */
  sync_schedule_set_by?: string | null;
  /**
   * The status of the data source in the pipeline.
   */
  status?:
    | ("NOT_STARTED" | "IN_PROGRESS" | "SUCCESS" | "ERROR" | "CANCELLED")
    | null;
  /**
   * The last time the status was updated.
   */
  status_updated_at?: string | null;
};

/**
 * Schema for creating an association between a data source and a pipeline.
 */
export type PipelineDataSourceCreate = {
  /**
   * The ID of the data source.
   */
  data_source_id: string;
  /**
   * The interval at which the data source should be synced. Valid values are: 21600, 43200, 86400
   */
  sync_interval?: number | null;
};

/**
 * Schema for updating an association between a data source and a pipeline.
 */
export type PipelineDataSourceUpdate = {
  /**
   * The interval at which the data source should be synced.
   */
  sync_interval?: number | null;
};

export type PipelineDeployment = {
  /**
   * Unique identifier
   */
  id: string;
  /**
   * Creation datetime
   */
  created_at?: string | null;
  /**
   * Update datetime
   */
  updated_at?: string | null;
  /**
   * Status of the pipeline deployment.
   */
  status: ManagedIngestionStatus;
  /**
   * Time the pipeline deployment started.
   */
  started_at?: string | null;
  /**
   * Time the pipeline deployment finished.
   */
  ended_at?: string | null;
};

/**
 * Schema for a file that is associated with a pipeline.
 */
export type PipelineFile = {
  /**
   * Unique identifier
   */
  id: string;
  /**
   * Creation datetime
   */
  created_at?: string | null;
  /**
   * Update datetime
   */
  updated_at?: string | null;
  /**
   * Name of the file
   */
  name?: string | null;
  /**
   * The ID of the file in the external system
   */
  external_file_id?: string | null;
  /**
   * Size of the file in bytes
   */
  file_size?: number | null;
  /**
   * File type (e.g. pdf, docx, etc.)
   */
  file_type?: string | null;
  /**
   * The ID of the project that the file belongs to
   */
  project_id?: string | null;
  /**
   * The last modified time of the file
   */
  last_modified_at?: string | null;
  /**
   * The ID of the file
   */
  file_id?: string | null;
  /**
   * The ID of the pipeline that the file is associated with
   */
  pipeline_id: string;
  /**
   * Resource information for the file
   */
  resource_info?: {
    [key: string]:
      | {
          [key: string]: unknown;
        }
      | Array<unknown>
      | string
      | number
      | number
      | boolean
      | null;
  } | null;
  /**
   * Permission information for the file
   */
  permission_info?: {
    [key: string]:
      | {
          [key: string]: unknown;
        }
      | Array<unknown>
      | string
      | number
      | number
      | boolean
      | null;
  } | null;
  /**
   * Custom metadata for the file
   */
  custom_metadata?: {
    [key: string]:
      | {
          [key: string]: unknown;
        }
      | Array<unknown>
      | string
      | number
      | number
      | boolean
      | null;
  } | null;
  /**
   * The ID of the data source that the file belongs to
   */
  data_source_id?: string | null;
  /**
   * Hashes for the configuration of the pipeline.
   */
  config_hash?: {
    [key: string]:
      | {
          [key: string]: unknown;
        }
      | Array<unknown>
      | string
      | number
      | number
      | boolean
      | null;
  } | null;
  /**
   * The number of pages that have been indexed for this file
   */
  indexed_page_count?: number | null;
  /**
   * Status of the pipeline file
   */
  status?:
    | ("NOT_STARTED" | "IN_PROGRESS" | "SUCCESS" | "ERROR" | "CANCELLED")
    | null;
  /**
   * The last time the status was updated
   */
  status_updated_at?: string | null;
};

/**
 * Schema for creating a file that is associated with a pipeline.
 */
export type PipelineFileCreate = {
  /**
   * The ID of the file
   */
  file_id: string;
  /**
   * Custom metadata for the file
   */
  custom_metadata?: {
    [key: string]:
      | {
          [key: string]: unknown;
        }
      | Array<unknown>
      | string
      | number
      | number
      | boolean
      | null;
  } | null;
};

/**
 * Schema for updating a file that is associated with a pipeline.
 */
export type PipelineFileUpdate = {
  /**
   * Custom metadata for the file
   */
  custom_metadata?: {
    [key: string]:
      | {
          [key: string]: unknown;
        }
      | Array<unknown>
      | string
      | number
      | number
      | boolean
      | null;
  } | null;
};

/**
 * Schema for the parameters of a load files job.
 */
export type PipelineFileUpdateDispatcherConfig = {
  type?: "pipeline_file_update_dispatcher";
  /**
   * The IDs for the files this execution ran against.
   */
  pipeline_file_ids?: Array<string> | null;
  /**
   * Whether to delete the files
   */
  should_delete?: boolean | null;
  /**
   * The parameters for the delete job.
   */
  delete_info?: DeleteParams | null;
};

/**
 * Schema for the parameters of a load files job.
 */
export type PipelineFileUpdaterConfig = {
  /**
   * The custom metadata to attach to the documents.
   */
  custom_metadata?: {
    [key: string]: unknown;
  } | null;
  /**
   * The resource info about the file
   */
  resource_info?: {
    [key: string]: unknown;
  } | null;
  type?: "pipeline_file_updater";
  /**
   * Whether to delete the files
   */
  should_delete?: boolean | null;
  /**
   * Whether to parse the files
   */
  should_parse?: boolean | null;
  /**
   * The parameters for the delete job.
   */
  delete_info?: DeleteParams | null;
  /**
   * Whether the file is new
   */
  is_new_file?: boolean;
  /**
   * Whether the data source project file has changed
   */
  data_source_project_file_changed?: boolean;
};

/**
 * Schema for the parameters of a managed pipeline ingestion job.
 */
export type PipelineManagedIngestionJobParams = {
  type?: "pipeline_managed_ingestion";
  /**
   * Whether to delete the data sources from the pipeline
   */
  should_delete?: boolean | null;
  /**
   * The parameters for the delete job.
   */
  delete_info?: DeleteParams | null;
};

export type PipelineMetadataConfig = {
  /**
   * List of metadata keys to exclude from embeddings
   */
  excluded_embed_metadata_keys?: Array<string>;
  /**
   * List of metadata keys to exclude from LLM during retrieval
   */
  excluded_llm_metadata_keys?: Array<string>;
};

/**
 * Enum for representing the type of a pipeline
 */
export type PipelineType = "PLAYGROUND" | "MANAGED";

/**
 * Enum for representing the type of a pipeline
 */
export const PipelineType = {
  PLAYGROUND: "PLAYGROUND",
  MANAGED: "MANAGED",
} as const;

/**
 * Schema for updating a pipeline.
 */
export type PipelineUpdateReadable = {
  embedding_config?:
    | (
        | ({
            type: "AZURE_EMBEDDING";
          } & AzureOpenAiEmbeddingConfig)
        | ({
            type: "COHERE_EMBEDDING";
          } & CohereEmbeddingConfig)
        | ({
            type: "GEMINI_EMBEDDING";
          } & GeminiEmbeddingConfig)
        | ({
            type: "HUGGINGFACE_API_EMBEDDING";
          } & HuggingFaceInferenceApiEmbeddingConfig)
        | ({
            type: "OPENAI_EMBEDDING";
          } & OpenAiEmbeddingConfig)
        | ({
            type: "VERTEXAI_EMBEDDING";
          } & VertexAiEmbeddingConfig)
        | ({
            type: "BEDROCK_EMBEDDING";
          } & BedrockEmbeddingConfig)
      )
    | null;
  /**
   * Configuration for the transformation.
   */
  transform_config?: AutoTransformConfig | AdvancedModeTransformConfig | null;
  /**
   * Configuration for the sparse model used in hybrid search.
   */
  sparse_model_config?: SparseModelConfig | null;
  /**
   * Data sink ID. When provided instead of data_sink, the data sink will be looked up by ID.
   */
  data_sink_id?: string | null;
  /**
   * Embedding model config ID. When provided instead of embedding_config, the embedding model config will be looked up by ID.
   */
  embedding_model_config_id?: string | null;
  /**
   * Data sink. When provided instead of data_sink_id, the data sink will be created.
   */
  data_sink?: DataSinkCreateReadable | null;
  /**
   * Preset retrieval parameters for the pipeline.
   */
  preset_retrieval_parameters?: PresetRetrievalParams | null;
  /**
   * Eval parameters for the pipeline.
   */
  eval_parameters?: EvalExecutionParams | null;
  /**
   * Settings that can be configured for how to use LlamaParse to parse files within a LlamaCloud pipeline.
   * @deprecated
   */
  llama_parse_parameters?: LlamaParseParameters | null;
  /**
   * Status of the pipeline deployment.
   */
  status?: string | null;
  /**
   * Metadata configuration for the pipeline.
   */
  metadata_config?: PipelineMetadataConfig | null;
  name?: string | null;
  /**
   * The ID of the ManagedPipeline this playground pipeline is linked to.
   */
  managed_pipeline_id?: string | null;
};

/**
 * Schema for updating a pipeline.
 */
export type PipelineUpdateWritable = {
  embedding_config?:
    | (
        | ({
            type: "AZURE_EMBEDDING";
          } & AzureOpenAiEmbeddingConfig)
        | ({
            type: "COHERE_EMBEDDING";
          } & CohereEmbeddingConfig)
        | ({
            type: "GEMINI_EMBEDDING";
          } & GeminiEmbeddingConfig)
        | ({
            type: "HUGGINGFACE_API_EMBEDDING";
          } & HuggingFaceInferenceApiEmbeddingConfig)
        | ({
            type: "OPENAI_EMBEDDING";
          } & OpenAiEmbeddingConfig)
        | ({
            type: "VERTEXAI_EMBEDDING";
          } & VertexAiEmbeddingConfig)
        | ({
            type: "BEDROCK_EMBEDDING";
          } & BedrockEmbeddingConfig)
      )
    | null;
  /**
   * Configuration for the transformation.
   */
  transform_config?: AutoTransformConfig | AdvancedModeTransformConfig | null;
  /**
   * Configuration for the sparse model used in hybrid search.
   */
  sparse_model_config?: SparseModelConfig | null;
  /**
   * Data sink ID. When provided instead of data_sink, the data sink will be looked up by ID.
   */
  data_sink_id?: string | null;
  /**
   * Embedding model config ID. When provided instead of embedding_config, the embedding model config will be looked up by ID.
   */
  embedding_model_config_id?: string | null;
  /**
   * Data sink. When provided instead of data_sink_id, the data sink will be created.
   */
  data_sink?: DataSinkCreateWritable | null;
  /**
   * Preset retrieval parameters for the pipeline.
   */
  preset_retrieval_parameters?: PresetRetrievalParams | null;
  /**
   * Eval parameters for the pipeline.
   */
  eval_parameters?: EvalExecutionParams | null;
  /**
   * Settings that can be configured for how to use LlamaParse to parse files within a LlamaCloud pipeline.
   * @deprecated
   */
  llama_parse_parameters?: LlamaParseParameters | null;
  /**
   * Status of the pipeline deployment.
   */
  status?: string | null;
  /**
   * Metadata configuration for the pipeline.
   */
  metadata_config?: PipelineMetadataConfig | null;
  name?: string | null;
  /**
   * The ID of the ManagedPipeline this playground pipeline is linked to.
   */
  managed_pipeline_id?: string | null;
};

export type PlanLimits = {
  /**
   * Whether usage is allowed after credit grants are exhausted
   */
  allow_pay_as_you_go: boolean;
  subscription_cost_usd: number;
  max_monthly_invoice_total_usd: number | null;
  /**
   * The amount of USD cents at which a soft alert should be triggered
   */
  spending_soft_alerts_usd_cents?: Array<number> | null;
  max_concurrent_parse_jobs_premium: number | null;
  max_concurrent_parse_jobs_other: number | null;
  max_extraction_agents: number | null;
  max_extraction_runs: number | null;
  max_extraction_jobs: number | null;
  max_pages_per_index: number | null;
  max_files_per_index: number | null;
  max_indexes: number | null;
  max_concurrent_index_jobs: number | null;
  max_data_sources: number | null;
  max_embedding_models: number | null;
  max_data_sinks: number | null;
  max_published_agents: number | null;
  max_report_agent_sessions: number | null;
  max_users: number | null;
  max_organizations: number | null;
  max_projects: number | null;
  mfa_enabled: boolean;
  sso_enabled: boolean;
};

/**
 * A playground session for a user.
 */
export type PlaygroundSession = {
  /**
   * Unique identifier
   */
  id: string;
  /**
   * Creation datetime
   */
  created_at?: string | null;
  /**
   * Update datetime
   */
  updated_at?: string | null;
  pipeline_id: string;
  user_id: string;
  llm_params_id: string;
  /**
   * LLM parameters last used in this session.
   */
  llm_params?: LlmParameters;
  retrieval_params_id: string;
  /**
   * Preset retrieval parameters last used in this session.
   */
  retrieval_params?: PresetRetrievalParams;
  /**
   * Chat message history for this session.
   */
  chat_messages?: Array<ChatMessage>;
};

/**
 * Enum of possible pooling choices with pooling behaviors.
 */
export type Pooling = "cls" | "mean" | "last";

/**
 * Enum of possible pooling choices with pooling behaviors.
 */
export const Pooling = {
  CLS: "cls",
  MEAN: "mean",
  LAST: "last",
} as const;

export type PresetCompositeRetrievalParams = {
  /**
   * The mode of composite retrieval.
   */
  mode?: CompositeRetrievalMode;
  /**
   * (use rerank_config.top_n instead) The number of nodes to retrieve after reranking over retrieved nodes from all retrieval tools.
   * @deprecated
   */
  rerank_top_n?: number | null;
  /**
   * The rerank configuration for composite retrieval.
   */
  rerank_config?: ReRankConfig;
};

/**
 * Schema for the search params for an retrieval execution that can be preset for a pipeline.
 */
export type PresetRetrievalParams = {
  /**
   * Number of nodes for dense retrieval.
   */
  dense_similarity_top_k?: number | null;
  /**
   * Minimum similarity score wrt query for retrieval
   */
  dense_similarity_cutoff?: number | null;
  /**
   * Number of nodes for sparse retrieval.
   */
  sparse_similarity_top_k?: number | null;
  /**
   * Enable reranking for retrieval
   */
  enable_reranking?: boolean | null;
  /**
   * Number of reranked nodes for returning.
   */
  rerank_top_n?: number | null;
  /**
   * Alpha value for hybrid retrieval to determine the weights between dense and sparse retrieval. 0 is sparse retrieval and 1 is dense retrieval.
   */
  alpha?: number | null;
  /**
   * Search filters for retrieval.
   */
  search_filters?: MetadataFilters | null;
  /**
   * JSON Schema that will be used to infer search_filters. Omit or leave as null to skip inference.
   */
  search_filters_inference_schema?: {
    [key: string]:
      | {
          [key: string]: unknown;
        }
      | Array<unknown>
      | string
      | number
      | number
      | boolean
      | null;
  } | null;
  /**
   * Number of files to retrieve (only for retrieval mode files_via_metadata and files_via_content).
   */
  files_top_k?: number | null;
  /**
   * The retrieval mode for the query.
   */
  retrieval_mode?: RetrievalMode;
  /**
   * Whether to retrieve image nodes.
   * @deprecated
   */
  retrieve_image_nodes?: boolean;
  /**
   * Whether to retrieve page screenshot nodes.
   */
  retrieve_page_screenshot_nodes?: boolean;
  /**
   * Whether to retrieve page figure nodes.
   */
  retrieve_page_figure_nodes?: boolean;
  class_name?: string;
};

/**
 * Schema for a presigned URL.
 */
export type PresignedUrl = {
  /**
   * A presigned URL for IO operations against a private file
   */
  url: string;
  /**
   * The time at which the presigned URL expires
   */
  expires_at: string;
  /**
   * Form fields for a presigned POST request
   */
  form_fields?: {
    [key: string]: string;
  } | null;
};

/**
 * Schema for a project.
 */
export type Project = {
  name: string;
  /**
   * Unique identifier
   */
  id: string;
  /**
   * Creation datetime
   */
  created_at?: string | null;
  /**
   * Update datetime
   */
  updated_at?: string | null;
  ad_hoc_eval_dataset_id?: string | null;
  /**
   * The Organization ID the project is under.
   */
  organization_id: string;
  /**
   * Whether this project is the default project for the user.
   */
  is_default?: boolean;
};

/**
 * Schema for creating a project.
 */
export type ProjectCreate = {
  name: string;
};

/**
 * Schema for updating a project.
 */
export type ProjectUpdate = {
  name: string;
};

export type PromptConf = {
  /**
   * The system prompt to use for the extraction.
   */
  system_prompt?: string;
  /**
   * The prompt to use for the extraction.
   */
  extraction_prompt?: string;
  /**
   * The prompt to use for error handling.
   */
  error_handling_prompt?: string;
  /**
   * The prompt to use for reasoning.
   */
  reasoning_prompt?: string;
  /**
   * The prompt to use for citing sources.
   */
  cite_sources_prompt?: {
    [key: string]: string;
  };
  /**
   * The prompt to use for scratchpad.
   */
  scratchpad_prompt?: string;
};

export type PublicModelName =
  | "openai-gpt-4o"
  | "openai-gpt-4o-mini"
  | "openai-gpt-4-1"
  | "openai-gpt-4-1-mini"
  | "openai-gpt-4-1-nano"
  | "openai-gpt-5"
  | "openai-gpt-5-mini"
  | "openai-gpt-5-nano"
  | "openai-text-embedding-3-small"
  | "openai-text-embedding-3-large"
  | "openai-whisper-1"
  | "anthropic-sonnet-3.5"
  | "anthropic-sonnet-3.5-v2"
  | "anthropic-sonnet-3.7"
  | "anthropic-sonnet-4.0"
  | "gemini-2.5-flash"
  | "gemini-2.5-pro"
  | "gemini-2.0-flash"
  | "gemini-2.0-flash-lite"
  | "gemini-1.5-flash"
  | "gemini-1.5-pro";

export const PublicModelName = {
  OPENAI_GPT_4O: "openai-gpt-4o",
  OPENAI_GPT_4O_MINI: "openai-gpt-4o-mini",
  OPENAI_GPT_4_1: "openai-gpt-4-1",
  OPENAI_GPT_4_1_MINI: "openai-gpt-4-1-mini",
  OPENAI_GPT_4_1_NANO: "openai-gpt-4-1-nano",
  OPENAI_GPT_5: "openai-gpt-5",
  OPENAI_GPT_5_MINI: "openai-gpt-5-mini",
  OPENAI_GPT_5_NANO: "openai-gpt-5-nano",
  OPENAI_TEXT_EMBEDDING_3_SMALL: "openai-text-embedding-3-small",
  OPENAI_TEXT_EMBEDDING_3_LARGE: "openai-text-embedding-3-large",
  OPENAI_WHISPER_1: "openai-whisper-1",
  ANTHROPIC_SONNET_3_5: "anthropic-sonnet-3.5",
  ANTHROPIC_SONNET_3_5_V2: "anthropic-sonnet-3.5-v2",
  ANTHROPIC_SONNET_3_7: "anthropic-sonnet-3.7",
  ANTHROPIC_SONNET_4_0: "anthropic-sonnet-4.0",
  GEMINI_2_5_FLASH: "gemini-2.5-flash",
  GEMINI_2_5_PRO: "gemini-2.5-pro",
  GEMINI_2_0_FLASH: "gemini-2.0-flash",
  GEMINI_2_0_FLASH_LITE: "gemini-2.0-flash-lite",
  GEMINI_1_5_FLASH: "gemini-1.5-flash",
  GEMINI_1_5_PRO: "gemini-1.5-pro",
} as const;

/**
 * Full quota configuration model.
 */
export type QuotaConfiguration = {
  /**
   * The source type, e.g. 'organization'
   */
  source_type: "organization";
  /**
   * The source ID, e.g. the organization ID
   */
  source_id: string;
  /**
   * The quota configuration type
   */
  configuration_type:
    | "rate_limit_parse_concurrent_premium"
    | "rate_limit_parse_concurrent_default"
    | "rate_limit_concurrent_jobs_in_execution_default"
    | "rate_limit_concurrent_jobs_in_execution_doc_ingest"
    | "limit_embedding_character";
  /**
   * The quota configuration value
   */
  configuration_value: QuotaRateLimitConfigurationValue;
  /**
   * The configuration metadata
   */
  configuration_metadata: {
    [key: string]: unknown;
  } | null;
  /**
   * The start date of the quota
   */
  started_at?: string;
  /**
   * The end date of the quota
   */
  ended_at?: string | null;
  /**
   * The idempotency key
   */
  idempotency_key?: string | null;
  /**
   * The status of the quota, i.e. 'ACTIVE' or 'INACTIVE'
   */
  status: "ACTIVE" | "INACTIVE";
  /**
   * The system-generated UUID for the quota
   */
  id?: string | null;
  /**
   * The creation date of the quota configuration in the database
   */
  created_at?: string | null;
  /**
   * The last updated date of the quota configuration in the database
   */
  updated_at?: string | null;
};

/**
 * Quota-specific wrapper for default rate limit configuration.
 */
export type QuotaRateLimitConfigurationValue = {
  /**
   * The rate numerator
   */
  numerator: number;
  /**
   * The rate limit denominator
   */
  denominator?: number | null;
  /**
   * The default rate limit denominator units
   */
  denominator_units?: ("second" | "minute" | "hour" | "day") | null;
};

export type ReRankConfig = {
  /**
   * The number of nodes to retrieve after reranking over retrieved nodes from all retrieval tools.
   */
  top_n?: number;
  /**
   * The type of reranker to use.
   */
  type?: ReRankerType;
};

/**
 * Enum for the reranker type.
 */
export type ReRankerType =
  | "system_default"
  | "llm"
  | "cohere"
  | "bedrock"
  | "score"
  | "disabled";

/**
 * Enum for the reranker type.
 */
export const ReRankerType = {
  SYSTEM_DEFAULT: "system_default",
  LLM: "llm",
  COHERE: "cohere",
  BEDROCK: "bedrock",
  SCORE: "score",
  DISABLED: "disabled",
} as const;

export type RecurringCreditGrant = {
  name: string;
  credit_amount: number;
  credit_type: CreditType;
  /**
   * The ID of the product in Metronome used to represent the credit grant
   */
  product_id: string;
  priority: number;
  /**
   * The fraction of the credit that will roll over to the next period, between 0 and 1
   */
  rollover_fraction: number;
  /**
   * How many billing periods the credit grant will last for
   */
  periods_duration?: number;
};

export type RelatedNodeInfo = {
  node_id: string;
  node_type?: ObjectType | string | null;
  metadata?: {
    [key: string]: unknown;
  };
  hash?: string | null;
  class_name?: string;
};

export type Restrict = {
  /**
   * The project ID to restrict the user to.
   */
  project_id: string | null;
};

export type RetrievalMode =
  | "chunks"
  | "files_via_metadata"
  | "files_via_content"
  | "auto_routed";

export const RetrievalMode = {
  CHUNKS: "chunks",
  FILES_VIA_METADATA: "files_via_metadata",
  FILES_VIA_CONTENT: "files_via_content",
  AUTO_ROUTED: "auto_routed",
} as const;

/**
 * Schema for the search params for an retrieval execution.
 */
export type RetrievalParams = {
  /**
   * Number of nodes for dense retrieval.
   */
  dense_similarity_top_k?: number | null;
  /**
   * Minimum similarity score wrt query for retrieval
   */
  dense_similarity_cutoff?: number | null;
  /**
   * Number of nodes for sparse retrieval.
   */
  sparse_similarity_top_k?: number | null;
  /**
   * Enable reranking for retrieval
   */
  enable_reranking?: boolean | null;
  /**
   * Number of reranked nodes for returning.
   */
  rerank_top_n?: number | null;
  /**
   * Alpha value for hybrid retrieval to determine the weights between dense and sparse retrieval. 0 is sparse retrieval and 1 is dense retrieval.
   */
  alpha?: number | null;
  /**
   * Search filters for retrieval.
   */
  search_filters?: MetadataFilters | null;
  /**
   * JSON Schema that will be used to infer search_filters. Omit or leave as null to skip inference.
   */
  search_filters_inference_schema?: {
    [key: string]:
      | {
          [key: string]: unknown;
        }
      | Array<unknown>
      | string
      | number
      | number
      | boolean
      | null;
  } | null;
  /**
   * Number of files to retrieve (only for retrieval mode files_via_metadata and files_via_content).
   */
  files_top_k?: number | null;
  /**
   * The retrieval mode for the query.
   */
  retrieval_mode?: RetrievalMode;
  /**
   * Whether to retrieve image nodes.
   * @deprecated
   */
  retrieve_image_nodes?: boolean;
  /**
   * Whether to retrieve page screenshot nodes.
   */
  retrieve_page_screenshot_nodes?: boolean;
  /**
   * Whether to retrieve page figure nodes.
   */
  retrieve_page_figure_nodes?: boolean;
  /**
   * The query to retrieve against.
   */
  query: string;
  class_name?: string;
};

/**
 * Schema for the result of an retrieval execution.
 */
export type RetrieveResults = {
  /**
   * The ID of the pipeline that the query was retrieved against.
   */
  pipeline_id: string;
  /**
   * The nodes retrieved by the pipeline for the given query.
   */
  retrieval_nodes: Array<TextNodeWithScore>;
  /**
   * The image nodes retrieved by the pipeline for the given query. Deprecated - will soon be replaced with 'page_screenshot_nodes'.
   * @deprecated
   */
  image_nodes?: Array<PageScreenshotNodeWithScore>;
  /**
   * The page figure nodes retrieved by the pipeline for the given query.
   */
  page_figure_nodes?: Array<PageFigureNodeWithScore>;
  /**
   * The end-to-end latency for retrieval and reranking.
   */
  retrieval_latency?: {
    [key: string]: number;
  };
  /**
   * Metadata associated with the retrieval execution
   */
  metadata?: {
    [key: string]: string;
  };
  /**
   * The inferred search filters for the query.
   */
  inferred_search_filters?: MetadataFilters | null;
  class_name?: string;
};

/**
 * An entity that retrieves context nodes from several sub RetrieverTools.
 */
export type Retriever = {
  /**
   * A name for the retriever tool. Will default to the pipeline name if not provided.
   */
  name: string;
  /**
   * The pipelines this retriever uses.
   */
  pipelines?: Array<RetrieverPipeline>;
  /**
   * Unique identifier
   */
  id: string;
  /**
   * Creation datetime
   */
  created_at?: string | null;
  /**
   * Update datetime
   */
  updated_at?: string | null;
  /**
   * The ID of the project this retriever resides in.
   */
  project_id: string;
};

export type RetrieverCreate = {
  /**
   * A name for the retriever tool. Will default to the pipeline name if not provided.
   */
  name: string;
  /**
   * The pipelines this retriever uses.
   */
  pipelines?: Array<RetrieverPipeline>;
};

export type RetrieverPipeline = {
  /**
   * A name for the retriever tool. Will default to the pipeline name if not provided.
   */
  name: string | null;
  /**
   * A description of the retriever tool.
   */
  description: string | null;
  /**
   * The ID of the pipeline this tool uses.
   */
  pipeline_id: string;
  /**
   * Parameters for retrieval configuration.
   */
  preset_retrieval_parameters?: PresetRetrievalParams;
};

export type RetrieverUpdate = {
  /**
   * A name for the retriever.
   */
  name?: string | null;
  /**
   * The pipelines this retriever uses.
   */
  pipelines: Array<RetrieverPipeline> | null;
};

/**
 * Schema for a role.
 */
export type Role = {
  /**
   * Unique identifier
   */
  id: string;
  /**
   * Creation datetime
   */
  created_at?: string | null;
  /**
   * Update datetime
   */
  updated_at?: string | null;
  /**
   * A name for the role.
   */
  name: string;
  /**
   * The actual permissions of the role.
   */
  permissions: Array<Permission>;
};

export type SchemaRelaxMode = "FULL" | "TOP_LEVEL" | "LEAF";

export const SchemaRelaxMode = {
  FULL: "FULL",
  TOP_LEVEL: "TOP_LEVEL",
  LEAF: "LEAF",
} as const;

/**
 * API request body for searching agent data
 */
export type SearchRequest = {
  /**
   * The maximum number of items to return. The service may return fewer than this value. If unspecified, a default page size will be used. The maximum value is typically 1000; values above this will be coerced to the maximum.
   */
  page_size?: number | null;
  /**
   * A page token, received from a previous list call. Provide this to retrieve the subsequent page.
   */
  page_token?: string | null;
  /**
   * A filter object or expression that filters resources listed in the response.
   */
  filter?: {
    [key: string]: FilterOperation;
  } | null;
  /**
   * A comma-separated list of fields to order by, sorted in ascending order. Use 'field_name desc' to specify descending order.
   */
  order_by?: string | null;
  /**
   * The agent deployment's name to search within
   */
  deployment_name: string;
  /**
   * The logical agent data collection to search within
   */
  collection?: string;
  /**
   * Whether to include the total number of items in the response
   */
  include_total?: boolean;
  /**
   * The offset to start from. If not provided, the first page is returned
   */
  offset?: number | null;
};

export type SemanticChunkingConfig = {
  mode?: "semantic";
  buffer_size?: number;
  breakpoint_percentile_threshold?: number;
};

export type SentenceChunkingConfig = {
  chunk_size?: number;
  chunk_overlap?: number;
  mode?: "sentence";
  separator?: string;
  paragraph_separator?: string;
};

/**
 * Configuration for sparse embedding models used in hybrid search.
 *
 * This allows users to choose between Splade and BM25 models for
 * sparse retrieval in managed data sinks.
 */
export type SparseModelConfig = {
  /**
   * The sparse model type to use. 'auto' selects based on deployment mode (BYOC uses term frequency, Cloud uses Splade), 'splade' uses HuggingFace Splade model, 'bm25' uses Qdrant's FastEmbed BM25 model.
   */
  model_type?: SparseModelType;
  class_name?: string;
};

/**
 * Enum for sparse model types supported in LlamaCloud.
 *
 * SPLADE: Uses HuggingFace Splade model for sparse embeddings
 * BM25: Uses Qdrant's FastEmbed BM25 model for sparse embeddings
 * AUTO: Automatically selects based on deployment mode (BYOC uses term frequency, Cloud uses Splade)
 */
export type SparseModelType = "splade" | "bm25" | "auto";

/**
 * Enum for sparse model types supported in LlamaCloud.
 *
 * SPLADE: Uses HuggingFace Splade model for sparse embeddings
 * BM25: Uses Qdrant's FastEmbed BM25 model for sparse embeddings
 * AUTO: Automatically selects based on deployment mode (BYOC uses term frequency, Cloud uses Splade)
 */
export const SparseModelType = {
  SPLADE: "splade",
  BM25: "bm25",
  AUTO: "auto",
} as const;

/**
 * Enum for representing the status of a job
 */
export type StatusEnum =
  | "PENDING"
  | "SUCCESS"
  | "ERROR"
  | "PARTIAL_SUCCESS"
  | "CANCELLED";

/**
 * Enum for representing the status of a job
 */
export const StatusEnum = {
  PENDING: "PENDING",
  SUCCESS: "SUCCESS",
  ERROR: "ERROR",
  PARTIAL_SUCCESS: "PARTIAL_SUCCESS",
  CANCELLED: "CANCELLED",
} as const;

export type StructMode =
  | "STRUCT_PARSE"
  | "JSON_MODE"
  | "FUNC_CALL"
  | "STRUCT_RELAXED"
  | "UNSTRUCTURED";

export const StructMode = {
  STRUCT_PARSE: "STRUCT_PARSE",
  JSON_MODE: "JSON_MODE",
  FUNC_CALL: "FUNC_CALL",
  STRUCT_RELAXED: "STRUCT_RELAXED",
  UNSTRUCTURED: "UNSTRUCTURED",
} as const;

/**
 * Configuration for the structured parsing agent.
 */
export type StructParseConf = {
  /**
   * The model to use for the structured parsing.
   */
  model?: ExtractModels;
  /**
   * The temperature to use for the structured parsing.
   */
  temperature?: number;
  /**
   * The relaxation mode to use for the structured parsing.
   */
  relaxation_mode?: SchemaRelaxMode;
  /**
   * The struct mode to use for the structured parsing.
   */
  struct_mode?: StructMode;
  /**
   * Whether to fetch logprobs for the structured parsing.
   */
  fetch_logprobs?: boolean;
  /**
   * Whether to handle missing fields in the schema.
   */
  handle_missing?: boolean;
  /**
   * Whether to use reasoning for the structured extraction.
   */
  use_reasoning?: boolean;
  /**
   * Whether to cite sources for the structured extraction.
   */
  cite_sources?: boolean;
  /**
   * The prompt configuration for the structured parsing.
   */
  prompt_conf?: PromptConf;
};

/**
 * Response Schema for a supported eval LLM model.
 */
export type SupportedLlmModel = {
  /**
   * The name of the supported LLM model.
   */
  name: string;
  /**
   * Whether the LLM model is enabled for use in LlamaCloud.
   */
  enabled?: boolean;
  /**
   * The details of the supported LLM model.
   */
  details: LlmModelData;
};

export type SupportedLlmModelNames =
  | "GPT_4O"
  | "GPT_4O_MINI"
  | "GPT_4_1"
  | "GPT_4_1_NANO"
  | "GPT_4_1_MINI"
  | "AZURE_OPENAI_GPT_4O"
  | "AZURE_OPENAI_GPT_4O_MINI"
  | "AZURE_OPENAI_GPT_4_1"
  | "AZURE_OPENAI_GPT_4_1_MINI"
  | "AZURE_OPENAI_GPT_4_1_NANO"
  | "CLAUDE_3_5_SONNET"
  | "BEDROCK_CLAUDE_3_5_SONNET_V1"
  | "BEDROCK_CLAUDE_3_5_SONNET_V2"
  | "VERTEX_AI_CLAUDE_3_5_SONNET_V2";

export const SupportedLlmModelNames = {
  GPT_4O: "GPT_4O",
  GPT_4O_MINI: "GPT_4O_MINI",
  GPT_4_1: "GPT_4_1",
  GPT_4_1_NANO: "GPT_4_1_NANO",
  GPT_4_1_MINI: "GPT_4_1_MINI",
  AZURE_OPENAI_GPT_4O: "AZURE_OPENAI_GPT_4O",
  AZURE_OPENAI_GPT_4O_MINI: "AZURE_OPENAI_GPT_4O_MINI",
  AZURE_OPENAI_GPT_4_1: "AZURE_OPENAI_GPT_4_1",
  AZURE_OPENAI_GPT_4_1_MINI: "AZURE_OPENAI_GPT_4_1_MINI",
  AZURE_OPENAI_GPT_4_1_NANO: "AZURE_OPENAI_GPT_4_1_NANO",
  CLAUDE_3_5_SONNET: "CLAUDE_3_5_SONNET",
  BEDROCK_CLAUDE_3_5_SONNET_V1: "BEDROCK_CLAUDE_3_5_SONNET_V1",
  BEDROCK_CLAUDE_3_5_SONNET_V2: "BEDROCK_CLAUDE_3_5_SONNET_V2",
  VERTEX_AI_CLAUDE_3_5_SONNET_V2: "VERTEX_AI_CLAUDE_3_5_SONNET_V2",
} as const;

/**
 * Provided for backward compatibility.
 *
 * Note: we keep the field with the typo "seperator" to maintain backward compatibility for
 * serialized objects.
 */
export type TextNode = {
  /**
   * Unique ID of the node.
   */
  id_?: string;
  /**
   * Embedding of the node.
   */
  embedding?: Array<number> | null;
  /**
   * A flat dictionary of metadata fields
   */
  extra_info?: {
    [key: string]: unknown;
  };
  /**
   * Metadata keys that are excluded from text for the embed model.
   */
  excluded_embed_metadata_keys?: Array<string>;
  /**
   * Metadata keys that are excluded from text for the LLM.
   */
  excluded_llm_metadata_keys?: Array<string>;
  /**
   * A mapping of relationships to other node information.
   */
  relationships?: {
    [key: string]: RelatedNodeInfo | Array<RelatedNodeInfo>;
  };
  /**
   * Template for how metadata is formatted, with {key} and {value} placeholders.
   */
  metadata_template?: string;
  /**
   * Separator between metadata fields when converting to string.
   */
  metadata_seperator?: string;
  /**
   * Text content of the node.
   */
  text?: string;
  /**
   * MIME type of the node content.
   */
  mimetype?: string;
  /**
   * Start char index of the node.
   */
  start_char_idx?: number | null;
  /**
   * End char index of the node.
   */
  end_char_idx?: number | null;
  /**
   * Template for how text is formatted, with {content} and {metadata_str} placeholders.
   */
  text_template?: string;
  class_name?: string;
};

/**
 * Same as NodeWithScore but type for node is a TextNode instead of BaseNode.
 * FastAPI doesn't accept abstract classes like BaseNode.
 */
export type TextNodeWithScore = {
  node: TextNode;
  score?: number | null;
  class_name?: string;
};

export type TokenChunkingConfig = {
  chunk_size?: number;
  chunk_overlap?: number;
  mode?: "token";
  separator?: string;
};

export type UsageAndPlan = {
  plan: BasePlan;
  usage: UsageResponse;
};

export type UsageMetricResponse = {
  feature_usage: {
    [key: string]: unknown;
  };
  day: string;
  source: string;
  job_id: string;
};

/**
 * Response model
 */
export type UsageResponse = {
  active_free_credits_usage?: Array<FreeCreditsUsage>;
  total_users?: number;
  total_indexes?: number;
  total_indexed_pages?: number;
  active_alerts?: Array<
    | "plan_spend_limit_exceeded"
    | "plan_spend_limit_soft_alert"
    | "configured_spend_limit_exceeded"
    | "free_credits_exhausted"
    | "internal_spending_alert"
    | "has_spending_alert"
  >;
  current_invoice_total_usd_cents?: number | null;
  total_extraction_agents?: number;
};

export type User = {
  id: string;
  email: string;
  /**
   * The last login provider.
   */
  last_login_provider?: "oidc" | "basic" | "no_auth";
  /**
   * The user's name.
   */
  name?: string | null;
  /**
   * The user's first name.
   */
  first_name?: string | null;
  /**
   * The user's last name.
   */
  last_name?: string | null;
  /**
   * The user's custom claims.
   */
  claims?: CustomClaims;
  /**
   * The restrictions on the user.
   */
  restrict?: Restrict | null;
  /**
   * The user's creation date.
   */
  created_at?: string | null;
};

export type UserJobRecord = {
  /**
   * The user id from who triggered the job
   */
  id: string;
  /**
   * The name of the user
   */
  name: string;
};

/**
 * Schema for a user's membership to an organization.
 */
export type UserOrganization = {
  /**
   * Unique identifier
   */
  id: string;
  /**
   * Creation datetime
   */
  created_at?: string | null;
  /**
   * Update datetime
   */
  updated_at?: string | null;
  /**
   * The user's email address.
   */
  email?: string | null;
  /**
   * The user's ID.
   */
  user_id?: string | null;
  /**
   * The organization's ID.
   */
  organization_id: string;
  /**
   * Whether the user's membership is pending account signup.
   */
  pending?: boolean;
  /**
   * The user ID of the user who added the user to the organization.
   */
  invited_by_user_id?: string | null;
  /**
   * The email address of the user who added the user to the organization.
   */
  invited_by_user_email?: string | null;
  /**
   * The roles of the user in the organization.
   */
  roles: Array<UserOrganizationRole>;
};

/**
 * Schema for creating a user's membership to an organization.
 */
export type UserOrganizationCreate = {
  /**
   * The user's ID.
   */
  user_id?: string | null;
  /**
   * The user's email address.
   */
  email?: string | null;
  /**
   * The project IDs to add the user to.
   */
  project_ids: Array<string> | null;
  /**
   * The role ID to assign to the user.
   */
  role_id?: string | null;
};

/**
 * Schema for deleting a user's membership to an organization.
 */
export type UserOrganizationDelete = {
  /**
   * The user's ID.
   */
  user_id?: string | null;
  /**
   * The user's email address.
   */
  email?: string | null;
  /**
   * The project ids
   */
  project_id_list?: Array<string> | null;
};

/**
 * Schema for a user's role in an organization.
 */
export type UserOrganizationRole = {
  /**
   * Unique identifier
   */
  id: string;
  /**
   * Creation datetime
   */
  created_at?: string | null;
  /**
   * Update datetime
   */
  updated_at?: string | null;
  /**
   * The user's ID.
   */
  user_id: string;
  /**
   * The organization's ID.
   */
  organization_id: string;
  /**
   * The project ID scope.
   */
  project_ids?: Array<string> | null;
  /**
   * The role.
   */
  role: Role;
};

/**
 * Schema for creating a user's role in an organization.
 */
export type UserOrganizationRoleCreate = {
  /**
   * The user's ID.
   */
  user_id: string;
  /**
   * The organization's ID.
   */
  organization_id: string;
  /**
   * The role's ID.
   */
  role_id: string;
};

export type ValidationError = {
  loc: Array<string | number>;
  msg: string;
  type: string;
};

export type VertexAiEmbeddingConfig = {
  /**
   * Type of the embedding model.
   */
  type?: "VERTEXAI_EMBEDDING";
  /**
   * Configuration for the VertexAI embedding model.
   */
  component?: VertexTextEmbedding;
};

/**
 * Copied from llama_index.embeddings.vertex.base.VertexEmbeddingMode
 * since importing llama_index.embeddings.vertex.base incurs a lot of memory usage.
 */
export type VertexEmbeddingMode =
  | "default"
  | "classification"
  | "clustering"
  | "similarity"
  | "retrieval";

/**
 * Copied from llama_index.embeddings.vertex.base.VertexEmbeddingMode
 * since importing llama_index.embeddings.vertex.base incurs a lot of memory usage.
 */
export const VertexEmbeddingMode = {
  DEFAULT: "default",
  CLASSIFICATION: "classification",
  CLUSTERING: "clustering",
  SIMILARITY: "similarity",
  RETRIEVAL: "retrieval",
} as const;

export type VertexTextEmbedding = {
  /**
   * The modelId of the VertexAI model to use.
   */
  model_name?: string;
  /**
   * The batch size for embedding calls.
   */
  embed_batch_size?: number;
  /**
   * The number of workers to use for async embedding calls.
   */
  num_workers?: number | null;
  /**
   * The default location to use when making API calls.
   */
  location: string;
  /**
   * The default GCP project to use when making Vertex API calls.
   */
  project: string;
  /**
   * The embedding mode to use.
   */
  embed_mode?: VertexEmbeddingMode;
  /**
   * Additional kwargs for the Vertex.
   */
  additional_kwargs?: {
    [key: string]: unknown;
  };
  /**
   * The client email for the VertexAI credentials.
   */
  client_email: string | null;
  /**
   * The token URI for the VertexAI credentials.
   */
  token_uri: string | null;
  /**
   * The private key ID for the VertexAI credentials.
   */
  private_key_id: string | null;
  /**
   * The private key for the VertexAI credentials.
   */
  private_key: string | null;
  class_name?: string;
};

/**
 * Allows the user to configure webhook options for notifications and callbacks.
 */
export type WebhookConfiguration = {
  /**
   * The URL to send webhook notifications to.
   */
  webhook_url?: string | null;
  /**
   * Custom HTTP headers to include with webhook requests.
   */
  webhook_headers?: {
    [key: string]: string;
  } | null;
  /**
   * List of event names to subscribe to
   */
  webhook_events?: Array<
    | "extract.pending"
    | "extract.success"
    | "extract.error"
    | "extract.partial_success"
    | "extract.cancelled"
    | "parse.pending"
    | "parse.success"
    | "parse.error"
    | "parse.partial_success"
    | "parse.cancelled"
    | "unmapped_event"
  > | null;
  /**
   * The output format to use for the webhook. Defaults to string if none supplied. Currently supported values: string, json
   */
  webhook_output_format?: string | null;
};

export type ListDeploymentsApiV1ProjectsProjectIdAgentsGetData = {
  body?: never;
  path: {
    project_id: string;
  };
  query?: never;
  url: "/api/v1/projects/{project_id}/agents";
};

export type ListDeploymentsApiV1ProjectsProjectIdAgentsGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type ListDeploymentsApiV1ProjectsProjectIdAgentsGetError =
  ListDeploymentsApiV1ProjectsProjectIdAgentsGetErrors[keyof ListDeploymentsApiV1ProjectsProjectIdAgentsGetErrors];

export type ListDeploymentsApiV1ProjectsProjectIdAgentsGetResponses = {
  /**
   * Successful Response
   */
  200: AgentDeploymentList;
};

export type ListDeploymentsApiV1ProjectsProjectIdAgentsGetResponse =
  ListDeploymentsApiV1ProjectsProjectIdAgentsGetResponses[keyof ListDeploymentsApiV1ProjectsProjectIdAgentsGetResponses];

export type SyncDeploymentsApiV1ProjectsProjectIdAgentsSyncPostData = {
  body?: never;
  path: {
    project_id: string;
  };
  query?: never;
  url: "/api/v1/projects/{project_id}/agents:sync";
};

export type SyncDeploymentsApiV1ProjectsProjectIdAgentsSyncPostErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type SyncDeploymentsApiV1ProjectsProjectIdAgentsSyncPostError =
  SyncDeploymentsApiV1ProjectsProjectIdAgentsSyncPostErrors[keyof SyncDeploymentsApiV1ProjectsProjectIdAgentsSyncPostErrors];

export type SyncDeploymentsApiV1ProjectsProjectIdAgentsSyncPostResponses = {
  /**
   * Successful Response
   */
  200: AgentDeploymentList;
};

export type SyncDeploymentsApiV1ProjectsProjectIdAgentsSyncPostResponse =
  SyncDeploymentsApiV1ProjectsProjectIdAgentsSyncPostResponses[keyof SyncDeploymentsApiV1ProjectsProjectIdAgentsSyncPostResponses];

export type ListKeysApiV1ApiKeysGetData = {
  body?: never;
  path?: never;
  query?: {
    project_id?: string | null;
    key_type?: ApiKeyType;
  };
  url: "/api/v1/api-keys";
};

export type ListKeysApiV1ApiKeysGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type ListKeysApiV1ApiKeysGetError =
  ListKeysApiV1ApiKeysGetErrors[keyof ListKeysApiV1ApiKeysGetErrors];

export type ListKeysApiV1ApiKeysGetResponses = {
  /**
   * Successful Response
   */
  200: Array<ApiKey>;
};

export type ListKeysApiV1ApiKeysGetResponse =
  ListKeysApiV1ApiKeysGetResponses[keyof ListKeysApiV1ApiKeysGetResponses];

export type GenerateKeyApiV1ApiKeysPostData = {
  body: ApiKeyCreate;
  path?: never;
  query?: never;
  url: "/api/v1/api-keys";
};

export type GenerateKeyApiV1ApiKeysPostErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type GenerateKeyApiV1ApiKeysPostError =
  GenerateKeyApiV1ApiKeysPostErrors[keyof GenerateKeyApiV1ApiKeysPostErrors];

export type GenerateKeyApiV1ApiKeysPostResponses = {
  /**
   * Successful Response
   */
  200: ApiKey;
};

export type GenerateKeyApiV1ApiKeysPostResponse =
  GenerateKeyApiV1ApiKeysPostResponses[keyof GenerateKeyApiV1ApiKeysPostResponses];

export type DeleteApiKeyApiV1ApiKeysApiKeyIdDeleteData = {
  body?: never;
  path: {
    api_key_id: string;
  };
  query?: never;
  url: "/api/v1/api-keys/{api_key_id}";
};

export type DeleteApiKeyApiV1ApiKeysApiKeyIdDeleteErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type DeleteApiKeyApiV1ApiKeysApiKeyIdDeleteError =
  DeleteApiKeyApiV1ApiKeysApiKeyIdDeleteErrors[keyof DeleteApiKeyApiV1ApiKeysApiKeyIdDeleteErrors];

export type DeleteApiKeyApiV1ApiKeysApiKeyIdDeleteResponses = {
  /**
   * Successful Response
   */
  204: void;
};

export type DeleteApiKeyApiV1ApiKeysApiKeyIdDeleteResponse =
  DeleteApiKeyApiV1ApiKeysApiKeyIdDeleteResponses[keyof DeleteApiKeyApiV1ApiKeysApiKeyIdDeleteResponses];

export type ValidateEmbeddingConnectionApiV1ValidateIntegrationsValidateEmbeddingConnectionPostData =
  {
    body:
      | ({
          type: "AZURE_EMBEDDING";
        } & AzureOpenAiEmbeddingConfig)
      | ({
          type: "COHERE_EMBEDDING";
        } & CohereEmbeddingConfig)
      | ({
          type: "GEMINI_EMBEDDING";
        } & GeminiEmbeddingConfig)
      | ({
          type: "HUGGINGFACE_API_EMBEDDING";
        } & HuggingFaceInferenceApiEmbeddingConfig)
      | ({
          type: "OPENAI_EMBEDDING";
        } & OpenAiEmbeddingConfig)
      | ({
          type: "VERTEXAI_EMBEDDING";
        } & VertexAiEmbeddingConfig)
      | ({
          type: "BEDROCK_EMBEDDING";
        } & BedrockEmbeddingConfig);
    path?: never;
    query?: {
      pipeline_id?: string | null;
    };
    url: "/api/v1/validate-integrations/validate-embedding-connection";
  };

export type ValidateEmbeddingConnectionApiV1ValidateIntegrationsValidateEmbeddingConnectionPostErrors =
  {
    /**
     * Validation Error
     */
    422: HttpValidationError;
  };

export type ValidateEmbeddingConnectionApiV1ValidateIntegrationsValidateEmbeddingConnectionPostError =
  ValidateEmbeddingConnectionApiV1ValidateIntegrationsValidateEmbeddingConnectionPostErrors[keyof ValidateEmbeddingConnectionApiV1ValidateIntegrationsValidateEmbeddingConnectionPostErrors];

export type ValidateEmbeddingConnectionApiV1ValidateIntegrationsValidateEmbeddingConnectionPostResponses =
  {
    /**
     * Successful Response
     */
    200: BaseConnectionValidation;
  };

export type ValidateEmbeddingConnectionApiV1ValidateIntegrationsValidateEmbeddingConnectionPostResponse =
  ValidateEmbeddingConnectionApiV1ValidateIntegrationsValidateEmbeddingConnectionPostResponses[keyof ValidateEmbeddingConnectionApiV1ValidateIntegrationsValidateEmbeddingConnectionPostResponses];

export type ValidateDataSourceConnectionApiV1ValidateIntegrationsValidateDataSourceConnectionPostData =
  {
    body: DataSourceCreateWritable;
    path?: never;
    query?: {
      existing_data_source_id?: string | null;
    };
    url: "/api/v1/validate-integrations/validate-data-source-connection";
  };

export type ValidateDataSourceConnectionApiV1ValidateIntegrationsValidateDataSourceConnectionPostErrors =
  {
    /**
     * Validation Error
     */
    422: HttpValidationError;
  };

export type ValidateDataSourceConnectionApiV1ValidateIntegrationsValidateDataSourceConnectionPostError =
  ValidateDataSourceConnectionApiV1ValidateIntegrationsValidateDataSourceConnectionPostErrors[keyof ValidateDataSourceConnectionApiV1ValidateIntegrationsValidateDataSourceConnectionPostErrors];

export type ValidateDataSourceConnectionApiV1ValidateIntegrationsValidateDataSourceConnectionPostResponses =
  {
    /**
     * Successful Response
     */
    200: BaseConnectionValidation;
  };

export type ValidateDataSourceConnectionApiV1ValidateIntegrationsValidateDataSourceConnectionPostResponse =
  ValidateDataSourceConnectionApiV1ValidateIntegrationsValidateDataSourceConnectionPostResponses[keyof ValidateDataSourceConnectionApiV1ValidateIntegrationsValidateDataSourceConnectionPostResponses];

export type ValidateDataSinkConnectionApiV1ValidateIntegrationsValidateDataSinkConnectionPostData =
  {
    body: DataSinkCreateWritable;
    path?: never;
    query?: never;
    url: "/api/v1/validate-integrations/validate-data-sink-connection";
  };

export type ValidateDataSinkConnectionApiV1ValidateIntegrationsValidateDataSinkConnectionPostErrors =
  {
    /**
     * Validation Error
     */
    422: HttpValidationError;
  };

export type ValidateDataSinkConnectionApiV1ValidateIntegrationsValidateDataSinkConnectionPostError =
  ValidateDataSinkConnectionApiV1ValidateIntegrationsValidateDataSinkConnectionPostErrors[keyof ValidateDataSinkConnectionApiV1ValidateIntegrationsValidateDataSinkConnectionPostErrors];

export type ValidateDataSinkConnectionApiV1ValidateIntegrationsValidateDataSinkConnectionPostResponses =
  {
    /**
     * Successful Response
     */
    200: BaseConnectionValidation;
  };

export type ValidateDataSinkConnectionApiV1ValidateIntegrationsValidateDataSinkConnectionPostResponse =
  ValidateDataSinkConnectionApiV1ValidateIntegrationsValidateDataSinkConnectionPostResponses[keyof ValidateDataSinkConnectionApiV1ValidateIntegrationsValidateDataSinkConnectionPostResponses];

export type ListDataSinksApiV1DataSinksGetData = {
  body?: never;
  path?: never;
  query?: {
    project_id?: string | null;
    organization_id?: string | null;
  };
  url: "/api/v1/data-sinks";
};

export type ListDataSinksApiV1DataSinksGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type ListDataSinksApiV1DataSinksGetError =
  ListDataSinksApiV1DataSinksGetErrors[keyof ListDataSinksApiV1DataSinksGetErrors];

export type ListDataSinksApiV1DataSinksGetResponses = {
  /**
   * Successful Response
   */
  200: Array<DataSinkReadable>;
};

export type ListDataSinksApiV1DataSinksGetResponse =
  ListDataSinksApiV1DataSinksGetResponses[keyof ListDataSinksApiV1DataSinksGetResponses];

export type CreateDataSinkApiV1DataSinksPostData = {
  body: DataSinkCreateWritable;
  path?: never;
  query?: {
    project_id?: string | null;
    organization_id?: string | null;
  };
  url: "/api/v1/data-sinks";
};

export type CreateDataSinkApiV1DataSinksPostErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type CreateDataSinkApiV1DataSinksPostError =
  CreateDataSinkApiV1DataSinksPostErrors[keyof CreateDataSinkApiV1DataSinksPostErrors];

export type CreateDataSinkApiV1DataSinksPostResponses = {
  /**
   * Successful Response
   */
  200: DataSinkReadable;
};

export type CreateDataSinkApiV1DataSinksPostResponse =
  CreateDataSinkApiV1DataSinksPostResponses[keyof CreateDataSinkApiV1DataSinksPostResponses];

export type UpsertDataSinkApiV1DataSinksPutData = {
  body: DataSinkCreateWritable;
  path?: never;
  query?: {
    project_id?: string | null;
    organization_id?: string | null;
  };
  url: "/api/v1/data-sinks";
};

export type UpsertDataSinkApiV1DataSinksPutErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type UpsertDataSinkApiV1DataSinksPutError =
  UpsertDataSinkApiV1DataSinksPutErrors[keyof UpsertDataSinkApiV1DataSinksPutErrors];

export type UpsertDataSinkApiV1DataSinksPutResponses = {
  /**
   * Successful Response
   */
  200: DataSinkReadable;
};

export type UpsertDataSinkApiV1DataSinksPutResponse =
  UpsertDataSinkApiV1DataSinksPutResponses[keyof UpsertDataSinkApiV1DataSinksPutResponses];

export type DeleteDataSinkApiV1DataSinksDataSinkIdDeleteData = {
  body?: never;
  path: {
    data_sink_id: string;
  };
  query?: never;
  url: "/api/v1/data-sinks/{data_sink_id}";
};

export type DeleteDataSinkApiV1DataSinksDataSinkIdDeleteErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type DeleteDataSinkApiV1DataSinksDataSinkIdDeleteError =
  DeleteDataSinkApiV1DataSinksDataSinkIdDeleteErrors[keyof DeleteDataSinkApiV1DataSinksDataSinkIdDeleteErrors];

export type DeleteDataSinkApiV1DataSinksDataSinkIdDeleteResponses = {
  /**
   * Successful Response
   */
  204: void;
};

export type DeleteDataSinkApiV1DataSinksDataSinkIdDeleteResponse =
  DeleteDataSinkApiV1DataSinksDataSinkIdDeleteResponses[keyof DeleteDataSinkApiV1DataSinksDataSinkIdDeleteResponses];

export type GetDataSinkApiV1DataSinksDataSinkIdGetData = {
  body?: never;
  path: {
    data_sink_id: string;
  };
  query?: never;
  url: "/api/v1/data-sinks/{data_sink_id}";
};

export type GetDataSinkApiV1DataSinksDataSinkIdGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type GetDataSinkApiV1DataSinksDataSinkIdGetError =
  GetDataSinkApiV1DataSinksDataSinkIdGetErrors[keyof GetDataSinkApiV1DataSinksDataSinkIdGetErrors];

export type GetDataSinkApiV1DataSinksDataSinkIdGetResponses = {
  /**
   * Successful Response
   */
  200: DataSinkReadable;
};

export type GetDataSinkApiV1DataSinksDataSinkIdGetResponse =
  GetDataSinkApiV1DataSinksDataSinkIdGetResponses[keyof GetDataSinkApiV1DataSinksDataSinkIdGetResponses];

export type UpdateDataSinkApiV1DataSinksDataSinkIdPutData = {
  body: DataSinkUpdateWritable;
  path: {
    data_sink_id: string;
  };
  query?: never;
  url: "/api/v1/data-sinks/{data_sink_id}";
};

export type UpdateDataSinkApiV1DataSinksDataSinkIdPutErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type UpdateDataSinkApiV1DataSinksDataSinkIdPutError =
  UpdateDataSinkApiV1DataSinksDataSinkIdPutErrors[keyof UpdateDataSinkApiV1DataSinksDataSinkIdPutErrors];

export type UpdateDataSinkApiV1DataSinksDataSinkIdPutResponses = {
  /**
   * Successful Response
   */
  200: DataSinkReadable;
};

export type UpdateDataSinkApiV1DataSinksDataSinkIdPutResponse =
  UpdateDataSinkApiV1DataSinksDataSinkIdPutResponses[keyof UpdateDataSinkApiV1DataSinksDataSinkIdPutResponses];

export type ListDataSourcesApiV1DataSourcesGetData = {
  body?: never;
  path?: never;
  query?: {
    project_id?: string | null;
    organization_id?: string | null;
  };
  url: "/api/v1/data-sources";
};

export type ListDataSourcesApiV1DataSourcesGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type ListDataSourcesApiV1DataSourcesGetError =
  ListDataSourcesApiV1DataSourcesGetErrors[keyof ListDataSourcesApiV1DataSourcesGetErrors];

export type ListDataSourcesApiV1DataSourcesGetResponses = {
  /**
   * Successful Response
   */
  200: Array<DataSourceReadable>;
};

export type ListDataSourcesApiV1DataSourcesGetResponse =
  ListDataSourcesApiV1DataSourcesGetResponses[keyof ListDataSourcesApiV1DataSourcesGetResponses];

export type CreateDataSourceApiV1DataSourcesPostData = {
  body: DataSourceCreateWritable;
  path?: never;
  query?: {
    project_id?: string | null;
    organization_id?: string | null;
  };
  url: "/api/v1/data-sources";
};

export type CreateDataSourceApiV1DataSourcesPostErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type CreateDataSourceApiV1DataSourcesPostError =
  CreateDataSourceApiV1DataSourcesPostErrors[keyof CreateDataSourceApiV1DataSourcesPostErrors];

export type CreateDataSourceApiV1DataSourcesPostResponses = {
  /**
   * Successful Response
   */
  200: DataSourceReadable;
};

export type CreateDataSourceApiV1DataSourcesPostResponse =
  CreateDataSourceApiV1DataSourcesPostResponses[keyof CreateDataSourceApiV1DataSourcesPostResponses];

export type UpsertDataSourceApiV1DataSourcesPutData = {
  body: DataSourceCreateWritable;
  path?: never;
  query?: {
    project_id?: string | null;
    organization_id?: string | null;
  };
  url: "/api/v1/data-sources";
};

export type UpsertDataSourceApiV1DataSourcesPutErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type UpsertDataSourceApiV1DataSourcesPutError =
  UpsertDataSourceApiV1DataSourcesPutErrors[keyof UpsertDataSourceApiV1DataSourcesPutErrors];

export type UpsertDataSourceApiV1DataSourcesPutResponses = {
  /**
   * Successful Response
   */
  200: DataSourceReadable;
};

export type UpsertDataSourceApiV1DataSourcesPutResponse =
  UpsertDataSourceApiV1DataSourcesPutResponses[keyof UpsertDataSourceApiV1DataSourcesPutResponses];

export type DeleteDataSourceApiV1DataSourcesDataSourceIdDeleteData = {
  body?: never;
  path: {
    data_source_id: string;
  };
  query?: never;
  url: "/api/v1/data-sources/{data_source_id}";
};

export type DeleteDataSourceApiV1DataSourcesDataSourceIdDeleteErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type DeleteDataSourceApiV1DataSourcesDataSourceIdDeleteError =
  DeleteDataSourceApiV1DataSourcesDataSourceIdDeleteErrors[keyof DeleteDataSourceApiV1DataSourcesDataSourceIdDeleteErrors];

export type DeleteDataSourceApiV1DataSourcesDataSourceIdDeleteResponses = {
  /**
   * Successful Response
   */
  204: void;
};

export type DeleteDataSourceApiV1DataSourcesDataSourceIdDeleteResponse =
  DeleteDataSourceApiV1DataSourcesDataSourceIdDeleteResponses[keyof DeleteDataSourceApiV1DataSourcesDataSourceIdDeleteResponses];

export type GetDataSourceApiV1DataSourcesDataSourceIdGetData = {
  body?: never;
  path: {
    data_source_id: string;
  };
  query?: never;
  url: "/api/v1/data-sources/{data_source_id}";
};

export type GetDataSourceApiV1DataSourcesDataSourceIdGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type GetDataSourceApiV1DataSourcesDataSourceIdGetError =
  GetDataSourceApiV1DataSourcesDataSourceIdGetErrors[keyof GetDataSourceApiV1DataSourcesDataSourceIdGetErrors];

export type GetDataSourceApiV1DataSourcesDataSourceIdGetResponses = {
  /**
   * Successful Response
   */
  200: DataSourceReadable;
};

export type GetDataSourceApiV1DataSourcesDataSourceIdGetResponse =
  GetDataSourceApiV1DataSourcesDataSourceIdGetResponses[keyof GetDataSourceApiV1DataSourcesDataSourceIdGetResponses];

export type UpdateDataSourceApiV1DataSourcesDataSourceIdPutData = {
  body: DataSourceUpdateWritable;
  path: {
    data_source_id: string;
  };
  query?: never;
  url: "/api/v1/data-sources/{data_source_id}";
};

export type UpdateDataSourceApiV1DataSourcesDataSourceIdPutErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type UpdateDataSourceApiV1DataSourcesDataSourceIdPutError =
  UpdateDataSourceApiV1DataSourcesDataSourceIdPutErrors[keyof UpdateDataSourceApiV1DataSourcesDataSourceIdPutErrors];

export type UpdateDataSourceApiV1DataSourcesDataSourceIdPutResponses = {
  /**
   * Successful Response
   */
  200: DataSourceReadable;
};

export type UpdateDataSourceApiV1DataSourcesDataSourceIdPutResponse =
  UpdateDataSourceApiV1DataSourcesDataSourceIdPutResponses[keyof UpdateDataSourceApiV1DataSourcesDataSourceIdPutResponses];

export type ListEmbeddingModelConfigsApiV1EmbeddingModelConfigsGetData = {
  body?: never;
  path?: never;
  query?: {
    project_id?: string | null;
    organization_id?: string | null;
  };
  url: "/api/v1/embedding-model-configs";
};

export type ListEmbeddingModelConfigsApiV1EmbeddingModelConfigsGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type ListEmbeddingModelConfigsApiV1EmbeddingModelConfigsGetError =
  ListEmbeddingModelConfigsApiV1EmbeddingModelConfigsGetErrors[keyof ListEmbeddingModelConfigsApiV1EmbeddingModelConfigsGetErrors];

export type ListEmbeddingModelConfigsApiV1EmbeddingModelConfigsGetResponses = {
  /**
   * Successful Response
   */
  200: Array<EmbeddingModelConfig>;
};

export type ListEmbeddingModelConfigsApiV1EmbeddingModelConfigsGetResponse =
  ListEmbeddingModelConfigsApiV1EmbeddingModelConfigsGetResponses[keyof ListEmbeddingModelConfigsApiV1EmbeddingModelConfigsGetResponses];

export type CreateEmbeddingModelConfigApiV1EmbeddingModelConfigsPostData = {
  body: EmbeddingModelConfigCreate;
  path?: never;
  query?: {
    project_id?: string | null;
    organization_id?: string | null;
  };
  url: "/api/v1/embedding-model-configs";
};

export type CreateEmbeddingModelConfigApiV1EmbeddingModelConfigsPostErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type CreateEmbeddingModelConfigApiV1EmbeddingModelConfigsPostError =
  CreateEmbeddingModelConfigApiV1EmbeddingModelConfigsPostErrors[keyof CreateEmbeddingModelConfigApiV1EmbeddingModelConfigsPostErrors];

export type CreateEmbeddingModelConfigApiV1EmbeddingModelConfigsPostResponses =
  {
    /**
     * Successful Response
     */
    201: EmbeddingModelConfig;
  };

export type CreateEmbeddingModelConfigApiV1EmbeddingModelConfigsPostResponse =
  CreateEmbeddingModelConfigApiV1EmbeddingModelConfigsPostResponses[keyof CreateEmbeddingModelConfigApiV1EmbeddingModelConfigsPostResponses];

export type UpsertEmbeddingModelConfigApiV1EmbeddingModelConfigsPutData = {
  body: EmbeddingModelConfigUpdate;
  path?: never;
  query?: {
    project_id?: string | null;
    organization_id?: string | null;
  };
  url: "/api/v1/embedding-model-configs";
};

export type UpsertEmbeddingModelConfigApiV1EmbeddingModelConfigsPutErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type UpsertEmbeddingModelConfigApiV1EmbeddingModelConfigsPutError =
  UpsertEmbeddingModelConfigApiV1EmbeddingModelConfigsPutErrors[keyof UpsertEmbeddingModelConfigApiV1EmbeddingModelConfigsPutErrors];

export type UpsertEmbeddingModelConfigApiV1EmbeddingModelConfigsPutResponses = {
  /**
   * Successful Response
   */
  200: EmbeddingModelConfig;
};

export type UpsertEmbeddingModelConfigApiV1EmbeddingModelConfigsPutResponse =
  UpsertEmbeddingModelConfigApiV1EmbeddingModelConfigsPutResponses[keyof UpsertEmbeddingModelConfigApiV1EmbeddingModelConfigsPutResponses];

export type DeleteEmbeddingModelConfigApiV1EmbeddingModelConfigsEmbeddingModelConfigIdDeleteData =
  {
    body?: never;
    path: {
      embedding_model_config_id: string;
    };
    query?: {
      project_id?: string | null;
      organization_id?: string | null;
    };
    url: "/api/v1/embedding-model-configs/{embedding_model_config_id}";
  };

export type DeleteEmbeddingModelConfigApiV1EmbeddingModelConfigsEmbeddingModelConfigIdDeleteErrors =
  {
    /**
     * Validation Error
     */
    422: HttpValidationError;
  };

export type DeleteEmbeddingModelConfigApiV1EmbeddingModelConfigsEmbeddingModelConfigIdDeleteError =
  DeleteEmbeddingModelConfigApiV1EmbeddingModelConfigsEmbeddingModelConfigIdDeleteErrors[keyof DeleteEmbeddingModelConfigApiV1EmbeddingModelConfigsEmbeddingModelConfigIdDeleteErrors];

export type DeleteEmbeddingModelConfigApiV1EmbeddingModelConfigsEmbeddingModelConfigIdDeleteResponses =
  {
    /**
     * Successful Response
     */
    204: void;
  };

export type DeleteEmbeddingModelConfigApiV1EmbeddingModelConfigsEmbeddingModelConfigIdDeleteResponse =
  DeleteEmbeddingModelConfigApiV1EmbeddingModelConfigsEmbeddingModelConfigIdDeleteResponses[keyof DeleteEmbeddingModelConfigApiV1EmbeddingModelConfigsEmbeddingModelConfigIdDeleteResponses];

export type UpdateEmbeddingModelConfigApiV1EmbeddingModelConfigsEmbeddingModelConfigIdPutData =
  {
    body: EmbeddingModelConfigUpdate;
    path: {
      embedding_model_config_id: string;
    };
    query?: {
      project_id?: string | null;
      organization_id?: string | null;
    };
    url: "/api/v1/embedding-model-configs/{embedding_model_config_id}";
  };

export type UpdateEmbeddingModelConfigApiV1EmbeddingModelConfigsEmbeddingModelConfigIdPutErrors =
  {
    /**
     * Validation Error
     */
    422: HttpValidationError;
  };

export type UpdateEmbeddingModelConfigApiV1EmbeddingModelConfigsEmbeddingModelConfigIdPutError =
  UpdateEmbeddingModelConfigApiV1EmbeddingModelConfigsEmbeddingModelConfigIdPutErrors[keyof UpdateEmbeddingModelConfigApiV1EmbeddingModelConfigsEmbeddingModelConfigIdPutErrors];

export type UpdateEmbeddingModelConfigApiV1EmbeddingModelConfigsEmbeddingModelConfigIdPutResponses =
  {
    /**
     * Successful Response
     */
    200: EmbeddingModelConfig;
  };

export type UpdateEmbeddingModelConfigApiV1EmbeddingModelConfigsEmbeddingModelConfigIdPutResponse =
  UpdateEmbeddingModelConfigApiV1EmbeddingModelConfigsEmbeddingModelConfigIdPutResponses[keyof UpdateEmbeddingModelConfigApiV1EmbeddingModelConfigsEmbeddingModelConfigIdPutResponses];

export type ListOrganizationsApiV1OrganizationsGetData = {
  body?: never;
  path?: never;
  query?: never;
  url: "/api/v1/organizations";
};

export type ListOrganizationsApiV1OrganizationsGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type ListOrganizationsApiV1OrganizationsGetError =
  ListOrganizationsApiV1OrganizationsGetErrors[keyof ListOrganizationsApiV1OrganizationsGetErrors];

export type ListOrganizationsApiV1OrganizationsGetResponses = {
  /**
   * Successful Response
   */
  200: Array<Organization>;
};

export type ListOrganizationsApiV1OrganizationsGetResponse =
  ListOrganizationsApiV1OrganizationsGetResponses[keyof ListOrganizationsApiV1OrganizationsGetResponses];

export type CreateOrganizationApiV1OrganizationsPostData = {
  body: OrganizationCreate;
  path?: never;
  query?: never;
  url: "/api/v1/organizations";
};

export type CreateOrganizationApiV1OrganizationsPostErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type CreateOrganizationApiV1OrganizationsPostError =
  CreateOrganizationApiV1OrganizationsPostErrors[keyof CreateOrganizationApiV1OrganizationsPostErrors];

export type CreateOrganizationApiV1OrganizationsPostResponses = {
  /**
   * Successful Response
   */
  200: Organization;
};

export type CreateOrganizationApiV1OrganizationsPostResponse =
  CreateOrganizationApiV1OrganizationsPostResponses[keyof CreateOrganizationApiV1OrganizationsPostResponses];

export type UpsertOrganizationApiV1OrganizationsPutData = {
  body: OrganizationCreate;
  path?: never;
  query?: never;
  url: "/api/v1/organizations";
};

export type UpsertOrganizationApiV1OrganizationsPutErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type UpsertOrganizationApiV1OrganizationsPutError =
  UpsertOrganizationApiV1OrganizationsPutErrors[keyof UpsertOrganizationApiV1OrganizationsPutErrors];

export type UpsertOrganizationApiV1OrganizationsPutResponses = {
  /**
   * Successful Response
   */
  200: Organization;
};

export type UpsertOrganizationApiV1OrganizationsPutResponse =
  UpsertOrganizationApiV1OrganizationsPutResponses[keyof UpsertOrganizationApiV1OrganizationsPutResponses];

export type GetDefaultOrganizationApiV1OrganizationsDefaultGetData = {
  body?: never;
  path?: never;
  query?: never;
  url: "/api/v1/organizations/default";
};

export type GetDefaultOrganizationApiV1OrganizationsDefaultGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type GetDefaultOrganizationApiV1OrganizationsDefaultGetError =
  GetDefaultOrganizationApiV1OrganizationsDefaultGetErrors[keyof GetDefaultOrganizationApiV1OrganizationsDefaultGetErrors];

export type GetDefaultOrganizationApiV1OrganizationsDefaultGetResponses = {
  /**
   * Successful Response
   */
  200: Organization;
};

export type GetDefaultOrganizationApiV1OrganizationsDefaultGetResponse =
  GetDefaultOrganizationApiV1OrganizationsDefaultGetResponses[keyof GetDefaultOrganizationApiV1OrganizationsDefaultGetResponses];

export type SetDefaultOrganizationApiV1OrganizationsDefaultPutData = {
  body: DefaultOrganizationUpdate;
  path?: never;
  query?: never;
  url: "/api/v1/organizations/default";
};

export type SetDefaultOrganizationApiV1OrganizationsDefaultPutErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type SetDefaultOrganizationApiV1OrganizationsDefaultPutError =
  SetDefaultOrganizationApiV1OrganizationsDefaultPutErrors[keyof SetDefaultOrganizationApiV1OrganizationsDefaultPutErrors];

export type SetDefaultOrganizationApiV1OrganizationsDefaultPutResponses = {
  /**
   * Successful Response
   */
  200: Organization;
};

export type SetDefaultOrganizationApiV1OrganizationsDefaultPutResponse =
  SetDefaultOrganizationApiV1OrganizationsDefaultPutResponses[keyof SetDefaultOrganizationApiV1OrganizationsDefaultPutResponses];

export type DeleteOrganizationApiV1OrganizationsOrganizationIdDeleteData = {
  body?: never;
  path: {
    organization_id: string;
  };
  query?: never;
  url: "/api/v1/organizations/{organization_id}";
};

export type DeleteOrganizationApiV1OrganizationsOrganizationIdDeleteErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type DeleteOrganizationApiV1OrganizationsOrganizationIdDeleteError =
  DeleteOrganizationApiV1OrganizationsOrganizationIdDeleteErrors[keyof DeleteOrganizationApiV1OrganizationsOrganizationIdDeleteErrors];

export type DeleteOrganizationApiV1OrganizationsOrganizationIdDeleteResponses =
  {
    /**
     * Successful Response
     */
    204: void;
  };

export type DeleteOrganizationApiV1OrganizationsOrganizationIdDeleteResponse =
  DeleteOrganizationApiV1OrganizationsOrganizationIdDeleteResponses[keyof DeleteOrganizationApiV1OrganizationsOrganizationIdDeleteResponses];

export type GetOrganizationApiV1OrganizationsOrganizationIdGetData = {
  body?: never;
  path: {
    organization_id: string;
  };
  query?: never;
  url: "/api/v1/organizations/{organization_id}";
};

export type GetOrganizationApiV1OrganizationsOrganizationIdGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type GetOrganizationApiV1OrganizationsOrganizationIdGetError =
  GetOrganizationApiV1OrganizationsOrganizationIdGetErrors[keyof GetOrganizationApiV1OrganizationsOrganizationIdGetErrors];

export type GetOrganizationApiV1OrganizationsOrganizationIdGetResponses = {
  /**
   * Successful Response
   */
  200: Organization;
};

export type GetOrganizationApiV1OrganizationsOrganizationIdGetResponse =
  GetOrganizationApiV1OrganizationsOrganizationIdGetResponses[keyof GetOrganizationApiV1OrganizationsOrganizationIdGetResponses];

export type UpdateOrganizationApiV1OrganizationsOrganizationIdPutData = {
  body: OrganizationUpdate;
  path: {
    organization_id: string;
  };
  query?: never;
  url: "/api/v1/organizations/{organization_id}";
};

export type UpdateOrganizationApiV1OrganizationsOrganizationIdPutErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type UpdateOrganizationApiV1OrganizationsOrganizationIdPutError =
  UpdateOrganizationApiV1OrganizationsOrganizationIdPutErrors[keyof UpdateOrganizationApiV1OrganizationsOrganizationIdPutErrors];

export type UpdateOrganizationApiV1OrganizationsOrganizationIdPutResponses = {
  /**
   * Successful Response
   */
  200: Organization;
};

export type UpdateOrganizationApiV1OrganizationsOrganizationIdPutResponse =
  UpdateOrganizationApiV1OrganizationsOrganizationIdPutResponses[keyof UpdateOrganizationApiV1OrganizationsOrganizationIdPutResponses];

export type GetOrganizationUsageApiV1OrganizationsOrganizationIdUsageGetData = {
  body?: never;
  path: {
    organization_id: string;
  };
  query?: {
    get_current_invoice_total?: boolean;
  };
  url: "/api/v1/organizations/{organization_id}/usage";
};

export type GetOrganizationUsageApiV1OrganizationsOrganizationIdUsageGetErrors =
  {
    /**
     * Validation Error
     */
    422: HttpValidationError;
  };

export type GetOrganizationUsageApiV1OrganizationsOrganizationIdUsageGetError =
  GetOrganizationUsageApiV1OrganizationsOrganizationIdUsageGetErrors[keyof GetOrganizationUsageApiV1OrganizationsOrganizationIdUsageGetErrors];

export type GetOrganizationUsageApiV1OrganizationsOrganizationIdUsageGetResponses =
  {
    /**
     * Successful Response
     */
    200: UsageAndPlan;
  };

export type GetOrganizationUsageApiV1OrganizationsOrganizationIdUsageGetResponse =
  GetOrganizationUsageApiV1OrganizationsOrganizationIdUsageGetResponses[keyof GetOrganizationUsageApiV1OrganizationsOrganizationIdUsageGetResponses];

export type ListOrganizationUsersApiV1OrganizationsOrganizationIdUsersGetData =
  {
    body?: never;
    path: {
      organization_id: string;
    };
    query?: never;
    url: "/api/v1/organizations/{organization_id}/users";
  };

export type ListOrganizationUsersApiV1OrganizationsOrganizationIdUsersGetErrors =
  {
    /**
     * Validation Error
     */
    422: HttpValidationError;
  };

export type ListOrganizationUsersApiV1OrganizationsOrganizationIdUsersGetError =
  ListOrganizationUsersApiV1OrganizationsOrganizationIdUsersGetErrors[keyof ListOrganizationUsersApiV1OrganizationsOrganizationIdUsersGetErrors];

export type ListOrganizationUsersApiV1OrganizationsOrganizationIdUsersGetResponses =
  {
    /**
     * Successful Response
     */
    200: Array<UserOrganization>;
  };

export type ListOrganizationUsersApiV1OrganizationsOrganizationIdUsersGetResponse =
  ListOrganizationUsersApiV1OrganizationsOrganizationIdUsersGetResponses[keyof ListOrganizationUsersApiV1OrganizationsOrganizationIdUsersGetResponses];

export type AddUsersToOrganizationApiV1OrganizationsOrganizationIdUsersPutData =
  {
    body: Array<UserOrganizationCreate>;
    path: {
      organization_id: string;
    };
    query?: never;
    url: "/api/v1/organizations/{organization_id}/users";
  };

export type AddUsersToOrganizationApiV1OrganizationsOrganizationIdUsersPutErrors =
  {
    /**
     * Validation Error
     */
    422: HttpValidationError;
  };

export type AddUsersToOrganizationApiV1OrganizationsOrganizationIdUsersPutError =
  AddUsersToOrganizationApiV1OrganizationsOrganizationIdUsersPutErrors[keyof AddUsersToOrganizationApiV1OrganizationsOrganizationIdUsersPutErrors];

export type AddUsersToOrganizationApiV1OrganizationsOrganizationIdUsersPutResponses =
  {
    /**
     * Successful Response
     */
    200: Array<UserOrganization>;
  };

export type AddUsersToOrganizationApiV1OrganizationsOrganizationIdUsersPutResponse =
  AddUsersToOrganizationApiV1OrganizationsOrganizationIdUsersPutResponses[keyof AddUsersToOrganizationApiV1OrganizationsOrganizationIdUsersPutResponses];

export type RemoveUsersFromOrganizationApiV1OrganizationsOrganizationIdUsersMemberUserIdDeleteData =
  {
    body?: Array<string> | null;
    path: {
      organization_id: string;
      member_user_id: string;
    };
    query?: never;
    url: "/api/v1/organizations/{organization_id}/users/{member_user_id}";
  };

export type RemoveUsersFromOrganizationApiV1OrganizationsOrganizationIdUsersMemberUserIdDeleteErrors =
  {
    /**
     * Validation Error
     */
    422: HttpValidationError;
  };

export type RemoveUsersFromOrganizationApiV1OrganizationsOrganizationIdUsersMemberUserIdDeleteError =
  RemoveUsersFromOrganizationApiV1OrganizationsOrganizationIdUsersMemberUserIdDeleteErrors[keyof RemoveUsersFromOrganizationApiV1OrganizationsOrganizationIdUsersMemberUserIdDeleteErrors];

export type RemoveUsersFromOrganizationApiV1OrganizationsOrganizationIdUsersMemberUserIdDeleteResponses =
  {
    /**
     * Successful Response
     */
    204: void;
  };

export type RemoveUsersFromOrganizationApiV1OrganizationsOrganizationIdUsersMemberUserIdDeleteResponse =
  RemoveUsersFromOrganizationApiV1OrganizationsOrganizationIdUsersMemberUserIdDeleteResponses[keyof RemoveUsersFromOrganizationApiV1OrganizationsOrganizationIdUsersMemberUserIdDeleteResponses];

export type BatchRemoveUsersFromOrganizationApiV1OrganizationsOrganizationIdUsersRemovePutData =
  {
    body: Array<UserOrganizationDelete>;
    path: {
      organization_id: string;
    };
    query?: never;
    url: "/api/v1/organizations/{organization_id}/users/remove";
  };

export type BatchRemoveUsersFromOrganizationApiV1OrganizationsOrganizationIdUsersRemovePutErrors =
  {
    /**
     * Validation Error
     */
    422: HttpValidationError;
  };

export type BatchRemoveUsersFromOrganizationApiV1OrganizationsOrganizationIdUsersRemovePutError =
  BatchRemoveUsersFromOrganizationApiV1OrganizationsOrganizationIdUsersRemovePutErrors[keyof BatchRemoveUsersFromOrganizationApiV1OrganizationsOrganizationIdUsersRemovePutErrors];

export type BatchRemoveUsersFromOrganizationApiV1OrganizationsOrganizationIdUsersRemovePutResponses =
  {
    /**
     * Successful Response
     */
    204: void;
  };

export type BatchRemoveUsersFromOrganizationApiV1OrganizationsOrganizationIdUsersRemovePutResponse =
  BatchRemoveUsersFromOrganizationApiV1OrganizationsOrganizationIdUsersRemovePutResponses[keyof BatchRemoveUsersFromOrganizationApiV1OrganizationsOrganizationIdUsersRemovePutResponses];

export type ListRolesApiV1OrganizationsOrganizationIdRolesGetData = {
  body?: never;
  path: {
    organization_id: string;
  };
  query?: never;
  url: "/api/v1/organizations/{organization_id}/roles";
};

export type ListRolesApiV1OrganizationsOrganizationIdRolesGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type ListRolesApiV1OrganizationsOrganizationIdRolesGetError =
  ListRolesApiV1OrganizationsOrganizationIdRolesGetErrors[keyof ListRolesApiV1OrganizationsOrganizationIdRolesGetErrors];

export type ListRolesApiV1OrganizationsOrganizationIdRolesGetResponses = {
  /**
   * Successful Response
   */
  200: Array<Role>;
};

export type ListRolesApiV1OrganizationsOrganizationIdRolesGetResponse =
  ListRolesApiV1OrganizationsOrganizationIdRolesGetResponses[keyof ListRolesApiV1OrganizationsOrganizationIdRolesGetResponses];

export type GetUserRoleApiV1OrganizationsOrganizationIdUsersRolesGetData = {
  body?: never;
  path: {
    organization_id: string;
  };
  query?: {
    project_id?: string | null;
  };
  url: "/api/v1/organizations/{organization_id}/users/roles";
};

export type GetUserRoleApiV1OrganizationsOrganizationIdUsersRolesGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type GetUserRoleApiV1OrganizationsOrganizationIdUsersRolesGetError =
  GetUserRoleApiV1OrganizationsOrganizationIdUsersRolesGetErrors[keyof GetUserRoleApiV1OrganizationsOrganizationIdUsersRolesGetErrors];

export type GetUserRoleApiV1OrganizationsOrganizationIdUsersRolesGetResponses =
  {
    /**
     * Successful Response
     */
    200: UserOrganizationRole | null;
  };

export type GetUserRoleApiV1OrganizationsOrganizationIdUsersRolesGetResponse =
  GetUserRoleApiV1OrganizationsOrganizationIdUsersRolesGetResponses[keyof GetUserRoleApiV1OrganizationsOrganizationIdUsersRolesGetResponses];

export type AssignRoleToUserInOrganizationApiV1OrganizationsOrganizationIdUsersRolesPutData =
  {
    body: UserOrganizationRoleCreate;
    path: {
      organization_id: string;
    };
    query?: never;
    url: "/api/v1/organizations/{organization_id}/users/roles";
  };

export type AssignRoleToUserInOrganizationApiV1OrganizationsOrganizationIdUsersRolesPutErrors =
  {
    /**
     * Validation Error
     */
    422: HttpValidationError;
  };

export type AssignRoleToUserInOrganizationApiV1OrganizationsOrganizationIdUsersRolesPutError =
  AssignRoleToUserInOrganizationApiV1OrganizationsOrganizationIdUsersRolesPutErrors[keyof AssignRoleToUserInOrganizationApiV1OrganizationsOrganizationIdUsersRolesPutErrors];

export type AssignRoleToUserInOrganizationApiV1OrganizationsOrganizationIdUsersRolesPutResponses =
  {
    /**
     * Successful Response
     */
    200: UserOrganizationRole;
  };

export type AssignRoleToUserInOrganizationApiV1OrganizationsOrganizationIdUsersRolesPutResponse =
  AssignRoleToUserInOrganizationApiV1OrganizationsOrganizationIdUsersRolesPutResponses[keyof AssignRoleToUserInOrganizationApiV1OrganizationsOrganizationIdUsersRolesPutResponses];

export type ListProjectsByUserApiV1OrganizationsOrganizationIdUsersUserIdProjectsGetData =
  {
    body?: never;
    path: {
      organization_id: string;
      user_id: string;
    };
    query?: never;
    url: "/api/v1/organizations/{organization_id}/users/{user_id}/projects";
  };

export type ListProjectsByUserApiV1OrganizationsOrganizationIdUsersUserIdProjectsGetErrors =
  {
    /**
     * Validation Error
     */
    422: HttpValidationError;
  };

export type ListProjectsByUserApiV1OrganizationsOrganizationIdUsersUserIdProjectsGetError =
  ListProjectsByUserApiV1OrganizationsOrganizationIdUsersUserIdProjectsGetErrors[keyof ListProjectsByUserApiV1OrganizationsOrganizationIdUsersUserIdProjectsGetErrors];

export type ListProjectsByUserApiV1OrganizationsOrganizationIdUsersUserIdProjectsGetResponses =
  {
    /**
     * Successful Response
     */
    200: Array<Project>;
  };

export type ListProjectsByUserApiV1OrganizationsOrganizationIdUsersUserIdProjectsGetResponse =
  ListProjectsByUserApiV1OrganizationsOrganizationIdUsersUserIdProjectsGetResponses[keyof ListProjectsByUserApiV1OrganizationsOrganizationIdUsersUserIdProjectsGetResponses];

export type AddUserToProjectApiV1OrganizationsOrganizationIdUsersUserIdProjectsPutData =
  {
    body?: never;
    path: {
      organization_id: string | null;
      user_id: string;
    };
    query?: {
      project_id?: string | null;
    };
    url: "/api/v1/organizations/{organization_id}/users/{user_id}/projects";
  };

export type AddUserToProjectApiV1OrganizationsOrganizationIdUsersUserIdProjectsPutErrors =
  {
    /**
     * Validation Error
     */
    422: HttpValidationError;
  };

export type AddUserToProjectApiV1OrganizationsOrganizationIdUsersUserIdProjectsPutError =
  AddUserToProjectApiV1OrganizationsOrganizationIdUsersUserIdProjectsPutErrors[keyof AddUserToProjectApiV1OrganizationsOrganizationIdUsersUserIdProjectsPutErrors];

export type AddUserToProjectApiV1OrganizationsOrganizationIdUsersUserIdProjectsPutResponses =
  {
    /**
     * Successful Response
     */
    200: unknown;
  };

export type RemoveUserFromProjectApiV1OrganizationsOrganizationIdUsersUserIdProjectsProjectIdDeleteData =
  {
    body?: never;
    path: {
      organization_id: string;
      user_id: string;
      project_id: string;
    };
    query?: never;
    url: "/api/v1/organizations/{organization_id}/users/{user_id}/projects/{project_id}";
  };

export type RemoveUserFromProjectApiV1OrganizationsOrganizationIdUsersUserIdProjectsProjectIdDeleteErrors =
  {
    /**
     * Validation Error
     */
    422: HttpValidationError;
  };

export type RemoveUserFromProjectApiV1OrganizationsOrganizationIdUsersUserIdProjectsProjectIdDeleteError =
  RemoveUserFromProjectApiV1OrganizationsOrganizationIdUsersUserIdProjectsProjectIdDeleteErrors[keyof RemoveUserFromProjectApiV1OrganizationsOrganizationIdUsersUserIdProjectsProjectIdDeleteErrors];

export type RemoveUserFromProjectApiV1OrganizationsOrganizationIdUsersUserIdProjectsProjectIdDeleteResponses =
  {
    /**
     * Successful Response
     */
    200: unknown;
  };

export type ListProjectsApiV1ProjectsGetData = {
  body?: never;
  path?: never;
  query?: {
    organization_id?: string | null;
    project_name?: string | null;
  };
  url: "/api/v1/projects";
};

export type ListProjectsApiV1ProjectsGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type ListProjectsApiV1ProjectsGetError =
  ListProjectsApiV1ProjectsGetErrors[keyof ListProjectsApiV1ProjectsGetErrors];

export type ListProjectsApiV1ProjectsGetResponses = {
  /**
   * Successful Response
   */
  200: Array<Project>;
};

export type ListProjectsApiV1ProjectsGetResponse =
  ListProjectsApiV1ProjectsGetResponses[keyof ListProjectsApiV1ProjectsGetResponses];

export type CreateProjectApiV1ProjectsPostData = {
  body: ProjectCreate;
  path?: never;
  query?: {
    organization_id?: string | null;
  };
  url: "/api/v1/projects";
};

export type CreateProjectApiV1ProjectsPostErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type CreateProjectApiV1ProjectsPostError =
  CreateProjectApiV1ProjectsPostErrors[keyof CreateProjectApiV1ProjectsPostErrors];

export type CreateProjectApiV1ProjectsPostResponses = {
  /**
   * Successful Response
   */
  200: Project;
};

export type CreateProjectApiV1ProjectsPostResponse =
  CreateProjectApiV1ProjectsPostResponses[keyof CreateProjectApiV1ProjectsPostResponses];

export type UpsertProjectApiV1ProjectsPutData = {
  body: ProjectCreate;
  path?: never;
  query?: {
    organization_id?: string | null;
  };
  url: "/api/v1/projects";
};

export type UpsertProjectApiV1ProjectsPutErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type UpsertProjectApiV1ProjectsPutError =
  UpsertProjectApiV1ProjectsPutErrors[keyof UpsertProjectApiV1ProjectsPutErrors];

export type UpsertProjectApiV1ProjectsPutResponses = {
  /**
   * Successful Response
   */
  200: Project;
};

export type UpsertProjectApiV1ProjectsPutResponse =
  UpsertProjectApiV1ProjectsPutResponses[keyof UpsertProjectApiV1ProjectsPutResponses];

export type DeleteProjectApiV1ProjectsProjectIdDeleteData = {
  body?: never;
  path: {
    project_id: string | null;
  };
  query?: {
    organization_id?: string | null;
  };
  url: "/api/v1/projects/{project_id}";
};

export type DeleteProjectApiV1ProjectsProjectIdDeleteErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type DeleteProjectApiV1ProjectsProjectIdDeleteError =
  DeleteProjectApiV1ProjectsProjectIdDeleteErrors[keyof DeleteProjectApiV1ProjectsProjectIdDeleteErrors];

export type DeleteProjectApiV1ProjectsProjectIdDeleteResponses = {
  /**
   * Successful Response
   */
  204: void;
};

export type DeleteProjectApiV1ProjectsProjectIdDeleteResponse =
  DeleteProjectApiV1ProjectsProjectIdDeleteResponses[keyof DeleteProjectApiV1ProjectsProjectIdDeleteResponses];

export type GetProjectApiV1ProjectsProjectIdGetData = {
  body?: never;
  path: {
    project_id: string | null;
  };
  query?: {
    organization_id?: string | null;
  };
  url: "/api/v1/projects/{project_id}";
};

export type GetProjectApiV1ProjectsProjectIdGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type GetProjectApiV1ProjectsProjectIdGetError =
  GetProjectApiV1ProjectsProjectIdGetErrors[keyof GetProjectApiV1ProjectsProjectIdGetErrors];

export type GetProjectApiV1ProjectsProjectIdGetResponses = {
  /**
   * Successful Response
   */
  200: Project;
};

export type GetProjectApiV1ProjectsProjectIdGetResponse =
  GetProjectApiV1ProjectsProjectIdGetResponses[keyof GetProjectApiV1ProjectsProjectIdGetResponses];

export type UpdateExistingProjectApiV1ProjectsProjectIdPutData = {
  body: ProjectUpdate;
  path: {
    project_id: string | null;
  };
  query?: {
    organization_id?: string | null;
  };
  url: "/api/v1/projects/{project_id}";
};

export type UpdateExistingProjectApiV1ProjectsProjectIdPutErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type UpdateExistingProjectApiV1ProjectsProjectIdPutError =
  UpdateExistingProjectApiV1ProjectsProjectIdPutErrors[keyof UpdateExistingProjectApiV1ProjectsProjectIdPutErrors];

export type UpdateExistingProjectApiV1ProjectsProjectIdPutResponses = {
  /**
   * Successful Response
   */
  200: Project;
};

export type UpdateExistingProjectApiV1ProjectsProjectIdPutResponse =
  UpdateExistingProjectApiV1ProjectsProjectIdPutResponses[keyof UpdateExistingProjectApiV1ProjectsProjectIdPutResponses];

export type GetCurrentProjectApiV1ProjectsCurrentGetData = {
  body?: never;
  path?: never;
  query?: {
    project_id?: string | null;
    organization_id?: string | null;
  };
  url: "/api/v1/projects/current";
};

export type GetCurrentProjectApiV1ProjectsCurrentGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type GetCurrentProjectApiV1ProjectsCurrentGetError =
  GetCurrentProjectApiV1ProjectsCurrentGetErrors[keyof GetCurrentProjectApiV1ProjectsCurrentGetErrors];

export type GetCurrentProjectApiV1ProjectsCurrentGetResponses = {
  /**
   * Successful Response
   */
  200: Project;
};

export type GetCurrentProjectApiV1ProjectsCurrentGetResponse =
  GetCurrentProjectApiV1ProjectsCurrentGetResponses[keyof GetCurrentProjectApiV1ProjectsCurrentGetResponses];

export type GetProjectUsageApiV1ProjectsProjectIdUsageGetData = {
  body?: never;
  path: {
    project_id: string | null;
  };
  query?: {
    get_current_invoice_total?: boolean;
    organization_id?: string | null;
  };
  url: "/api/v1/projects/{project_id}/usage";
};

export type GetProjectUsageApiV1ProjectsProjectIdUsageGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type GetProjectUsageApiV1ProjectsProjectIdUsageGetError =
  GetProjectUsageApiV1ProjectsProjectIdUsageGetErrors[keyof GetProjectUsageApiV1ProjectsProjectIdUsageGetErrors];

export type GetProjectUsageApiV1ProjectsProjectIdUsageGetResponses = {
  /**
   * Successful Response
   */
  200: UsageAndPlan;
};

export type GetProjectUsageApiV1ProjectsProjectIdUsageGetResponse =
  GetProjectUsageApiV1ProjectsProjectIdUsageGetResponses[keyof GetProjectUsageApiV1ProjectsProjectIdUsageGetResponses];

export type DeleteFileApiV1FilesIdDeleteData = {
  body?: never;
  path: {
    id: string;
  };
  query?: {
    project_id?: string | null;
    organization_id?: string | null;
  };
  url: "/api/v1/files/{id}";
};

export type DeleteFileApiV1FilesIdDeleteErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type DeleteFileApiV1FilesIdDeleteError =
  DeleteFileApiV1FilesIdDeleteErrors[keyof DeleteFileApiV1FilesIdDeleteErrors];

export type DeleteFileApiV1FilesIdDeleteResponses = {
  /**
   * Successful Response
   */
  204: void;
};

export type DeleteFileApiV1FilesIdDeleteResponse =
  DeleteFileApiV1FilesIdDeleteResponses[keyof DeleteFileApiV1FilesIdDeleteResponses];

export type GetFileApiV1FilesIdGetData = {
  body?: never;
  path: {
    id: string;
  };
  query?: {
    project_id?: string | null;
    organization_id?: string | null;
  };
  url: "/api/v1/files/{id}";
};

export type GetFileApiV1FilesIdGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type GetFileApiV1FilesIdGetError =
  GetFileApiV1FilesIdGetErrors[keyof GetFileApiV1FilesIdGetErrors];

export type GetFileApiV1FilesIdGetResponses = {
  /**
   * Successful Response
   */
  200: File;
};

export type GetFileApiV1FilesIdGetResponse =
  GetFileApiV1FilesIdGetResponses[keyof GetFileApiV1FilesIdGetResponses];

export type ListFilesApiV1FilesGetData = {
  body?: never;
  path?: never;
  query?: {
    project_id?: string | null;
    organization_id?: string | null;
  };
  url: "/api/v1/files";
};

export type ListFilesApiV1FilesGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type ListFilesApiV1FilesGetError =
  ListFilesApiV1FilesGetErrors[keyof ListFilesApiV1FilesGetErrors];

export type ListFilesApiV1FilesGetResponses = {
  /**
   * Successful Response
   */
  200: Array<File>;
};

export type ListFilesApiV1FilesGetResponse =
  ListFilesApiV1FilesGetResponses[keyof ListFilesApiV1FilesGetResponses];

export type UploadFileApiV1FilesPostData = {
  body: BodyUploadFileApiV1FilesPost;
  path?: never;
  query?: {
    external_file_id?: string | null;
    project_id?: string | null;
    organization_id?: string | null;
  };
  url: "/api/v1/files";
};

export type UploadFileApiV1FilesPostErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type UploadFileApiV1FilesPostError =
  UploadFileApiV1FilesPostErrors[keyof UploadFileApiV1FilesPostErrors];

export type UploadFileApiV1FilesPostResponses = {
  /**
   * Successful Response
   */
  200: File;
};

export type UploadFileApiV1FilesPostResponse =
  UploadFileApiV1FilesPostResponses[keyof UploadFileApiV1FilesPostResponses];

export type GeneratePresignedUrlApiV1FilesPutData = {
  body: FileCreate;
  path?: never;
  query?: {
    expires_at_seconds?: number | null;
    project_id?: string | null;
    organization_id?: string | null;
  };
  url: "/api/v1/files";
};

export type GeneratePresignedUrlApiV1FilesPutErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type GeneratePresignedUrlApiV1FilesPutError =
  GeneratePresignedUrlApiV1FilesPutErrors[keyof GeneratePresignedUrlApiV1FilesPutErrors];

export type GeneratePresignedUrlApiV1FilesPutResponses = {
  /**
   * Successful Response
   */
  200: FileIdPresignedUrl;
};

export type GeneratePresignedUrlApiV1FilesPutResponse =
  GeneratePresignedUrlApiV1FilesPutResponses[keyof GeneratePresignedUrlApiV1FilesPutResponses];

export type SyncFilesApiV1FilesSyncPutData = {
  body?: never;
  path?: never;
  query?: {
    project_id?: string | null;
    organization_id?: string | null;
  };
  url: "/api/v1/files/sync";
};

export type SyncFilesApiV1FilesSyncPutErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type SyncFilesApiV1FilesSyncPutError =
  SyncFilesApiV1FilesSyncPutErrors[keyof SyncFilesApiV1FilesSyncPutErrors];

export type SyncFilesApiV1FilesSyncPutResponses = {
  /**
   * Successful Response
   */
  200: Array<File>;
};

export type SyncFilesApiV1FilesSyncPutResponse =
  SyncFilesApiV1FilesSyncPutResponses[keyof SyncFilesApiV1FilesSyncPutResponses];

export type UploadFileFromUrlApiV1FilesUploadFromUrlPutData = {
  body: FileCreateFromUrl;
  path?: never;
  query?: {
    project_id?: string | null;
    organization_id?: string | null;
  };
  url: "/api/v1/files/upload_from_url";
};

export type UploadFileFromUrlApiV1FilesUploadFromUrlPutErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type UploadFileFromUrlApiV1FilesUploadFromUrlPutError =
  UploadFileFromUrlApiV1FilesUploadFromUrlPutErrors[keyof UploadFileFromUrlApiV1FilesUploadFromUrlPutErrors];

export type UploadFileFromUrlApiV1FilesUploadFromUrlPutResponses = {
  /**
   * Successful Response
   */
  200: File;
};

export type UploadFileFromUrlApiV1FilesUploadFromUrlPutResponse =
  UploadFileFromUrlApiV1FilesUploadFromUrlPutResponses[keyof UploadFileFromUrlApiV1FilesUploadFromUrlPutResponses];

export type ReadFileContentApiV1FilesIdContentGetData = {
  body?: never;
  path: {
    id: string;
  };
  query?: {
    expires_at_seconds?: number | null;
    project_id?: string | null;
    organization_id?: string | null;
  };
  url: "/api/v1/files/{id}/content";
};

export type ReadFileContentApiV1FilesIdContentGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type ReadFileContentApiV1FilesIdContentGetError =
  ReadFileContentApiV1FilesIdContentGetErrors[keyof ReadFileContentApiV1FilesIdContentGetErrors];

export type ReadFileContentApiV1FilesIdContentGetResponses = {
  /**
   * Successful Response
   */
  200: PresignedUrl;
};

export type ReadFileContentApiV1FilesIdContentGetResponse =
  ReadFileContentApiV1FilesIdContentGetResponses[keyof ReadFileContentApiV1FilesIdContentGetResponses];

export type ListFilePageScreenshotsApiV1FilesIdPageScreenshotsGetData = {
  body?: never;
  path: {
    id: string;
  };
  query?: {
    project_id?: string | null;
    organization_id?: string | null;
  };
  url: "/api/v1/files/{id}/page_screenshots";
};

export type ListFilePageScreenshotsApiV1FilesIdPageScreenshotsGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type ListFilePageScreenshotsApiV1FilesIdPageScreenshotsGetError =
  ListFilePageScreenshotsApiV1FilesIdPageScreenshotsGetErrors[keyof ListFilePageScreenshotsApiV1FilesIdPageScreenshotsGetErrors];

export type ListFilePageScreenshotsApiV1FilesIdPageScreenshotsGetResponses = {
  /**
   * Successful Response
   */
  200: Array<PageScreenshotMetadata>;
};

export type ListFilePageScreenshotsApiV1FilesIdPageScreenshotsGetResponse =
  ListFilePageScreenshotsApiV1FilesIdPageScreenshotsGetResponses[keyof ListFilePageScreenshotsApiV1FilesIdPageScreenshotsGetResponses];

export type GetFilePageScreenshotApiV1FilesIdPageScreenshotsPageIndexGetData = {
  body?: never;
  path: {
    id: string;
    page_index: number;
  };
  query?: {
    project_id?: string | null;
    organization_id?: string | null;
  };
  url: "/api/v1/files/{id}/page_screenshots/{page_index}";
};

export type GetFilePageScreenshotApiV1FilesIdPageScreenshotsPageIndexGetErrors =
  {
    /**
     * Validation Error
     */
    422: HttpValidationError;
  };

export type GetFilePageScreenshotApiV1FilesIdPageScreenshotsPageIndexGetError =
  GetFilePageScreenshotApiV1FilesIdPageScreenshotsPageIndexGetErrors[keyof GetFilePageScreenshotApiV1FilesIdPageScreenshotsPageIndexGetErrors];

export type GetFilePageScreenshotApiV1FilesIdPageScreenshotsPageIndexGetResponses =
  {
    /**
     * Successful Response
     */
    200: unknown;
  };

export type ListFilePagesFiguresApiV1FilesIdPageFiguresGetData = {
  body?: never;
  path: {
    id: string;
  };
  query?: {
    project_id?: string | null;
    organization_id?: string | null;
  };
  url: "/api/v1/files/{id}/page-figures";
};

export type ListFilePagesFiguresApiV1FilesIdPageFiguresGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type ListFilePagesFiguresApiV1FilesIdPageFiguresGetError =
  ListFilePagesFiguresApiV1FilesIdPageFiguresGetErrors[keyof ListFilePagesFiguresApiV1FilesIdPageFiguresGetErrors];

export type ListFilePagesFiguresApiV1FilesIdPageFiguresGetResponses = {
  /**
   * Successful Response
   */
  200: Array<PageFigureMetadata>;
};

export type ListFilePagesFiguresApiV1FilesIdPageFiguresGetResponse =
  ListFilePagesFiguresApiV1FilesIdPageFiguresGetResponses[keyof ListFilePagesFiguresApiV1FilesIdPageFiguresGetResponses];

export type ListFilePageFiguresApiV1FilesIdPageFiguresPageIndexGetData = {
  body?: never;
  path: {
    id: string;
    page_index: number;
  };
  query?: {
    project_id?: string | null;
    organization_id?: string | null;
  };
  url: "/api/v1/files/{id}/page-figures/{page_index}";
};

export type ListFilePageFiguresApiV1FilesIdPageFiguresPageIndexGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type ListFilePageFiguresApiV1FilesIdPageFiguresPageIndexGetError =
  ListFilePageFiguresApiV1FilesIdPageFiguresPageIndexGetErrors[keyof ListFilePageFiguresApiV1FilesIdPageFiguresPageIndexGetErrors];

export type ListFilePageFiguresApiV1FilesIdPageFiguresPageIndexGetResponses = {
  /**
   * Successful Response
   */
  200: Array<PageFigureMetadata>;
};

export type ListFilePageFiguresApiV1FilesIdPageFiguresPageIndexGetResponse =
  ListFilePageFiguresApiV1FilesIdPageFiguresPageIndexGetResponses[keyof ListFilePageFiguresApiV1FilesIdPageFiguresPageIndexGetResponses];

export type GetFilePageFigureApiV1FilesIdPageFiguresPageIndexFigureNameGetData =
  {
    body?: never;
    path: {
      id: string;
      page_index: number;
      figure_name: string;
    };
    query?: {
      project_id?: string | null;
      organization_id?: string | null;
    };
    url: "/api/v1/files/{id}/page-figures/{page_index}/{figure_name}";
  };

export type GetFilePageFigureApiV1FilesIdPageFiguresPageIndexFigureNameGetErrors =
  {
    /**
     * Validation Error
     */
    422: HttpValidationError;
  };

export type GetFilePageFigureApiV1FilesIdPageFiguresPageIndexFigureNameGetError =
  GetFilePageFigureApiV1FilesIdPageFiguresPageIndexFigureNameGetErrors[keyof GetFilePageFigureApiV1FilesIdPageFiguresPageIndexFigureNameGetErrors];

export type GetFilePageFigureApiV1FilesIdPageFiguresPageIndexFigureNameGetResponses =
  {
    /**
     * Successful Response
     */
    200: unknown;
  };

export type GenerateFilePageScreenshotPresignedUrlApiV1FilesIdPageScreenshotsPageIndexPresignedUrlPostData =
  {
    body?: never;
    path: {
      id: string;
      page_index: number;
    };
    query?: {
      project_id?: string | null;
      organization_id?: string | null;
    };
    url: "/api/v1/files/{id}/page_screenshots/{page_index}/presigned_url";
  };

export type GenerateFilePageScreenshotPresignedUrlApiV1FilesIdPageScreenshotsPageIndexPresignedUrlPostErrors =
  {
    /**
     * Validation Error
     */
    422: HttpValidationError;
  };

export type GenerateFilePageScreenshotPresignedUrlApiV1FilesIdPageScreenshotsPageIndexPresignedUrlPostError =
  GenerateFilePageScreenshotPresignedUrlApiV1FilesIdPageScreenshotsPageIndexPresignedUrlPostErrors[keyof GenerateFilePageScreenshotPresignedUrlApiV1FilesIdPageScreenshotsPageIndexPresignedUrlPostErrors];

export type GenerateFilePageScreenshotPresignedUrlApiV1FilesIdPageScreenshotsPageIndexPresignedUrlPostResponses =
  {
    /**
     * Successful Response
     */
    200: PresignedUrl;
  };

export type GenerateFilePageScreenshotPresignedUrlApiV1FilesIdPageScreenshotsPageIndexPresignedUrlPostResponse =
  GenerateFilePageScreenshotPresignedUrlApiV1FilesIdPageScreenshotsPageIndexPresignedUrlPostResponses[keyof GenerateFilePageScreenshotPresignedUrlApiV1FilesIdPageScreenshotsPageIndexPresignedUrlPostResponses];

export type GenerateFilePageFigurePresignedUrlApiV1FilesIdPageFiguresPageIndexFigureNamePresignedUrlPostData =
  {
    body?: never;
    path: {
      id: string;
      page_index: number;
      figure_name: string;
    };
    query?: {
      project_id?: string | null;
      organization_id?: string | null;
    };
    url: "/api/v1/files/{id}/page-figures/{page_index}/{figure_name}/presigned_url";
  };

export type GenerateFilePageFigurePresignedUrlApiV1FilesIdPageFiguresPageIndexFigureNamePresignedUrlPostErrors =
  {
    /**
     * Validation Error
     */
    422: HttpValidationError;
  };

export type GenerateFilePageFigurePresignedUrlApiV1FilesIdPageFiguresPageIndexFigureNamePresignedUrlPostError =
  GenerateFilePageFigurePresignedUrlApiV1FilesIdPageFiguresPageIndexFigureNamePresignedUrlPostErrors[keyof GenerateFilePageFigurePresignedUrlApiV1FilesIdPageFiguresPageIndexFigureNamePresignedUrlPostErrors];

export type GenerateFilePageFigurePresignedUrlApiV1FilesIdPageFiguresPageIndexFigureNamePresignedUrlPostResponses =
  {
    /**
     * Successful Response
     */
    200: PresignedUrl;
  };

export type GenerateFilePageFigurePresignedUrlApiV1FilesIdPageFiguresPageIndexFigureNamePresignedUrlPostResponse =
  GenerateFilePageFigurePresignedUrlApiV1FilesIdPageFiguresPageIndexFigureNamePresignedUrlPostResponses[keyof GenerateFilePageFigurePresignedUrlApiV1FilesIdPageFiguresPageIndexFigureNamePresignedUrlPostResponses];

export type SearchPipelinesApiV1PipelinesGetData = {
  body?: never;
  path?: never;
  query?: {
    project_id?: string | null;
    project_name?: string | null;
    pipeline_name?: string | null;
    pipeline_type?: PipelineType | null;
    organization_id?: string | null;
  };
  url: "/api/v1/pipelines";
};

export type SearchPipelinesApiV1PipelinesGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type SearchPipelinesApiV1PipelinesGetError =
  SearchPipelinesApiV1PipelinesGetErrors[keyof SearchPipelinesApiV1PipelinesGetErrors];

export type SearchPipelinesApiV1PipelinesGetResponses = {
  /**
   * Successful Response
   */
  200: Array<PipelineReadable>;
};

export type SearchPipelinesApiV1PipelinesGetResponse =
  SearchPipelinesApiV1PipelinesGetResponses[keyof SearchPipelinesApiV1PipelinesGetResponses];

export type CreatePipelineApiV1PipelinesPostData = {
  body: PipelineCreateWritable;
  path?: never;
  query?: {
    project_id?: string | null;
    organization_id?: string | null;
  };
  url: "/api/v1/pipelines";
};

export type CreatePipelineApiV1PipelinesPostErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type CreatePipelineApiV1PipelinesPostError =
  CreatePipelineApiV1PipelinesPostErrors[keyof CreatePipelineApiV1PipelinesPostErrors];

export type CreatePipelineApiV1PipelinesPostResponses = {
  /**
   * Successful Response
   */
  200: PipelineReadable;
};

export type CreatePipelineApiV1PipelinesPostResponse =
  CreatePipelineApiV1PipelinesPostResponses[keyof CreatePipelineApiV1PipelinesPostResponses];

export type UpsertPipelineApiV1PipelinesPutData = {
  body: PipelineCreateWritable;
  path?: never;
  query?: {
    project_id?: string | null;
    organization_id?: string | null;
  };
  url: "/api/v1/pipelines";
};

export type UpsertPipelineApiV1PipelinesPutErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type UpsertPipelineApiV1PipelinesPutError =
  UpsertPipelineApiV1PipelinesPutErrors[keyof UpsertPipelineApiV1PipelinesPutErrors];

export type UpsertPipelineApiV1PipelinesPutResponses = {
  /**
   * Successful Response
   */
  200: PipelineReadable;
};

export type UpsertPipelineApiV1PipelinesPutResponse =
  UpsertPipelineApiV1PipelinesPutResponses[keyof UpsertPipelineApiV1PipelinesPutResponses];

export type DeletePipelineApiV1PipelinesPipelineIdDeleteData = {
  body?: never;
  path: {
    pipeline_id: string;
  };
  query?: never;
  url: "/api/v1/pipelines/{pipeline_id}";
};

export type DeletePipelineApiV1PipelinesPipelineIdDeleteErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type DeletePipelineApiV1PipelinesPipelineIdDeleteError =
  DeletePipelineApiV1PipelinesPipelineIdDeleteErrors[keyof DeletePipelineApiV1PipelinesPipelineIdDeleteErrors];

export type DeletePipelineApiV1PipelinesPipelineIdDeleteResponses = {
  /**
   * Successful Response
   */
  204: void;
};

export type DeletePipelineApiV1PipelinesPipelineIdDeleteResponse =
  DeletePipelineApiV1PipelinesPipelineIdDeleteResponses[keyof DeletePipelineApiV1PipelinesPipelineIdDeleteResponses];

export type GetPipelineApiV1PipelinesPipelineIdGetData = {
  body?: never;
  path: {
    pipeline_id: string;
  };
  query?: never;
  url: "/api/v1/pipelines/{pipeline_id}";
};

export type GetPipelineApiV1PipelinesPipelineIdGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type GetPipelineApiV1PipelinesPipelineIdGetError =
  GetPipelineApiV1PipelinesPipelineIdGetErrors[keyof GetPipelineApiV1PipelinesPipelineIdGetErrors];

export type GetPipelineApiV1PipelinesPipelineIdGetResponses = {
  /**
   * Successful Response
   */
  200: PipelineReadable;
};

export type GetPipelineApiV1PipelinesPipelineIdGetResponse =
  GetPipelineApiV1PipelinesPipelineIdGetResponses[keyof GetPipelineApiV1PipelinesPipelineIdGetResponses];

export type UpdateExistingPipelineApiV1PipelinesPipelineIdPutData = {
  body: PipelineUpdateWritable;
  path: {
    pipeline_id: string;
  };
  query?: never;
  url: "/api/v1/pipelines/{pipeline_id}";
};

export type UpdateExistingPipelineApiV1PipelinesPipelineIdPutErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type UpdateExistingPipelineApiV1PipelinesPipelineIdPutError =
  UpdateExistingPipelineApiV1PipelinesPipelineIdPutErrors[keyof UpdateExistingPipelineApiV1PipelinesPipelineIdPutErrors];

export type UpdateExistingPipelineApiV1PipelinesPipelineIdPutResponses = {
  /**
   * Successful Response
   */
  200: PipelineReadable;
};

export type UpdateExistingPipelineApiV1PipelinesPipelineIdPutResponse =
  UpdateExistingPipelineApiV1PipelinesPipelineIdPutResponses[keyof UpdateExistingPipelineApiV1PipelinesPipelineIdPutResponses];

export type GetPipelineStatusApiV1PipelinesPipelineIdStatusGetData = {
  body?: never;
  path: {
    pipeline_id: string;
  };
  query?: never;
  url: "/api/v1/pipelines/{pipeline_id}/status";
};

export type GetPipelineStatusApiV1PipelinesPipelineIdStatusGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type GetPipelineStatusApiV1PipelinesPipelineIdStatusGetError =
  GetPipelineStatusApiV1PipelinesPipelineIdStatusGetErrors[keyof GetPipelineStatusApiV1PipelinesPipelineIdStatusGetErrors];

export type GetPipelineStatusApiV1PipelinesPipelineIdStatusGetResponses = {
  /**
   * Successful Response
   */
  200: ManagedIngestionStatusResponse;
};

export type GetPipelineStatusApiV1PipelinesPipelineIdStatusGetResponse =
  GetPipelineStatusApiV1PipelinesPipelineIdStatusGetResponses[keyof GetPipelineStatusApiV1PipelinesPipelineIdStatusGetResponses];

export type SyncPipelineApiV1PipelinesPipelineIdSyncPostData = {
  body?: never;
  path: {
    pipeline_id: string;
  };
  query?: never;
  url: "/api/v1/pipelines/{pipeline_id}/sync";
};

export type SyncPipelineApiV1PipelinesPipelineIdSyncPostErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type SyncPipelineApiV1PipelinesPipelineIdSyncPostError =
  SyncPipelineApiV1PipelinesPipelineIdSyncPostErrors[keyof SyncPipelineApiV1PipelinesPipelineIdSyncPostErrors];

export type SyncPipelineApiV1PipelinesPipelineIdSyncPostResponses = {
  /**
   * Successful Response
   */
  200: PipelineReadable;
};

export type SyncPipelineApiV1PipelinesPipelineIdSyncPostResponse =
  SyncPipelineApiV1PipelinesPipelineIdSyncPostResponses[keyof SyncPipelineApiV1PipelinesPipelineIdSyncPostResponses];

export type CancelPipelineSyncApiV1PipelinesPipelineIdSyncCancelPostData = {
  body?: never;
  path: {
    pipeline_id: string;
  };
  query?: never;
  url: "/api/v1/pipelines/{pipeline_id}/sync/cancel";
};

export type CancelPipelineSyncApiV1PipelinesPipelineIdSyncCancelPostErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type CancelPipelineSyncApiV1PipelinesPipelineIdSyncCancelPostError =
  CancelPipelineSyncApiV1PipelinesPipelineIdSyncCancelPostErrors[keyof CancelPipelineSyncApiV1PipelinesPipelineIdSyncCancelPostErrors];

export type CancelPipelineSyncApiV1PipelinesPipelineIdSyncCancelPostResponses =
  {
    /**
     * Successful Response
     */
    200: PipelineReadable;
  };

export type CancelPipelineSyncApiV1PipelinesPipelineIdSyncCancelPostResponse =
  CancelPipelineSyncApiV1PipelinesPipelineIdSyncCancelPostResponses[keyof CancelPipelineSyncApiV1PipelinesPipelineIdSyncCancelPostResponses];

export type ForceDeletePipelineApiV1PipelinesPipelineIdForceDeletePostData = {
  body?: never;
  path: {
    pipeline_id: string;
  };
  query?: never;
  url: "/api/v1/pipelines/{pipeline_id}/force-delete";
};

export type ForceDeletePipelineApiV1PipelinesPipelineIdForceDeletePostErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type ForceDeletePipelineApiV1PipelinesPipelineIdForceDeletePostError =
  ForceDeletePipelineApiV1PipelinesPipelineIdForceDeletePostErrors[keyof ForceDeletePipelineApiV1PipelinesPipelineIdForceDeletePostErrors];

export type ForceDeletePipelineApiV1PipelinesPipelineIdForceDeletePostResponses =
  {
    /**
     * Successful Response
     */
    204: void;
  };

export type ForceDeletePipelineApiV1PipelinesPipelineIdForceDeletePostResponse =
  ForceDeletePipelineApiV1PipelinesPipelineIdForceDeletePostResponses[keyof ForceDeletePipelineApiV1PipelinesPipelineIdForceDeletePostResponses];

export type CopyPipelineApiV1PipelinesPipelineIdCopyPostData = {
  body?: never;
  path: {
    pipeline_id: string;
  };
  query?: never;
  url: "/api/v1/pipelines/{pipeline_id}/copy";
};

export type CopyPipelineApiV1PipelinesPipelineIdCopyPostErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type CopyPipelineApiV1PipelinesPipelineIdCopyPostError =
  CopyPipelineApiV1PipelinesPipelineIdCopyPostErrors[keyof CopyPipelineApiV1PipelinesPipelineIdCopyPostErrors];

export type CopyPipelineApiV1PipelinesPipelineIdCopyPostResponses = {
  /**
   * Successful Response
   */
  200: PipelineReadable;
};

export type CopyPipelineApiV1PipelinesPipelineIdCopyPostResponse =
  CopyPipelineApiV1PipelinesPipelineIdCopyPostResponses[keyof CopyPipelineApiV1PipelinesPipelineIdCopyPostResponses];

export type ListPipelineFilesApiV1PipelinesPipelineIdFilesGetData = {
  body?: never;
  path: {
    pipeline_id: string;
  };
  query?: {
    data_source_id?: string | null;
    only_manually_uploaded?: boolean;
  };
  url: "/api/v1/pipelines/{pipeline_id}/files";
};

export type ListPipelineFilesApiV1PipelinesPipelineIdFilesGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type ListPipelineFilesApiV1PipelinesPipelineIdFilesGetError =
  ListPipelineFilesApiV1PipelinesPipelineIdFilesGetErrors[keyof ListPipelineFilesApiV1PipelinesPipelineIdFilesGetErrors];

export type ListPipelineFilesApiV1PipelinesPipelineIdFilesGetResponses = {
  /**
   * Successful Response
   */
  200: Array<PipelineFile>;
};

export type ListPipelineFilesApiV1PipelinesPipelineIdFilesGetResponse =
  ListPipelineFilesApiV1PipelinesPipelineIdFilesGetResponses[keyof ListPipelineFilesApiV1PipelinesPipelineIdFilesGetResponses];

export type AddFilesToPipelineApiApiV1PipelinesPipelineIdFilesPutData = {
  body: Array<PipelineFileCreate>;
  path: {
    pipeline_id: string;
  };
  query?: never;
  url: "/api/v1/pipelines/{pipeline_id}/files";
};

export type AddFilesToPipelineApiApiV1PipelinesPipelineIdFilesPutErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type AddFilesToPipelineApiApiV1PipelinesPipelineIdFilesPutError =
  AddFilesToPipelineApiApiV1PipelinesPipelineIdFilesPutErrors[keyof AddFilesToPipelineApiApiV1PipelinesPipelineIdFilesPutErrors];

export type AddFilesToPipelineApiApiV1PipelinesPipelineIdFilesPutResponses = {
  /**
   * Successful Response
   */
  200: Array<PipelineFile>;
};

export type AddFilesToPipelineApiApiV1PipelinesPipelineIdFilesPutResponse =
  AddFilesToPipelineApiApiV1PipelinesPipelineIdFilesPutResponses[keyof AddFilesToPipelineApiApiV1PipelinesPipelineIdFilesPutResponses];

export type ListPipelineFiles2ApiV1PipelinesPipelineIdFiles2GetData = {
  body?: never;
  path: {
    pipeline_id: string;
  };
  query?: {
    data_source_id?: string | null;
    only_manually_uploaded?: boolean;
    file_name_contains?: string | null;
    limit?: number | null;
    offset?: number | null;
    order_by?: string | null;
  };
  url: "/api/v1/pipelines/{pipeline_id}/files2";
};

export type ListPipelineFiles2ApiV1PipelinesPipelineIdFiles2GetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type ListPipelineFiles2ApiV1PipelinesPipelineIdFiles2GetError =
  ListPipelineFiles2ApiV1PipelinesPipelineIdFiles2GetErrors[keyof ListPipelineFiles2ApiV1PipelinesPipelineIdFiles2GetErrors];

export type ListPipelineFiles2ApiV1PipelinesPipelineIdFiles2GetResponses = {
  /**
   * Successful Response
   */
  200: PaginatedListPipelineFilesResponse;
};

export type ListPipelineFiles2ApiV1PipelinesPipelineIdFiles2GetResponse =
  ListPipelineFiles2ApiV1PipelinesPipelineIdFiles2GetResponses[keyof ListPipelineFiles2ApiV1PipelinesPipelineIdFiles2GetResponses];

export type GetPipelineFileStatusCountsApiV1PipelinesPipelineIdFilesStatusCountsGetData =
  {
    body?: never;
    path: {
      pipeline_id: string;
    };
    query?: {
      data_source_id?: string | null;
      only_manually_uploaded?: boolean;
    };
    url: "/api/v1/pipelines/{pipeline_id}/files/status-counts";
  };

export type GetPipelineFileStatusCountsApiV1PipelinesPipelineIdFilesStatusCountsGetErrors =
  {
    /**
     * Validation Error
     */
    422: HttpValidationError;
  };

export type GetPipelineFileStatusCountsApiV1PipelinesPipelineIdFilesStatusCountsGetError =
  GetPipelineFileStatusCountsApiV1PipelinesPipelineIdFilesStatusCountsGetErrors[keyof GetPipelineFileStatusCountsApiV1PipelinesPipelineIdFilesStatusCountsGetErrors];

export type GetPipelineFileStatusCountsApiV1PipelinesPipelineIdFilesStatusCountsGetResponses =
  {
    /**
     * Successful Response
     */
    200: FileCountByStatusResponse;
  };

export type GetPipelineFileStatusCountsApiV1PipelinesPipelineIdFilesStatusCountsGetResponse =
  GetPipelineFileStatusCountsApiV1PipelinesPipelineIdFilesStatusCountsGetResponses[keyof GetPipelineFileStatusCountsApiV1PipelinesPipelineIdFilesStatusCountsGetResponses];

export type GetPipelineFileStatusApiV1PipelinesPipelineIdFilesFileIdStatusGetData =
  {
    body?: never;
    path: {
      file_id: string;
      pipeline_id: string;
    };
    query?: never;
    url: "/api/v1/pipelines/{pipeline_id}/files/{file_id}/status";
  };

export type GetPipelineFileStatusApiV1PipelinesPipelineIdFilesFileIdStatusGetErrors =
  {
    /**
     * Validation Error
     */
    422: HttpValidationError;
  };

export type GetPipelineFileStatusApiV1PipelinesPipelineIdFilesFileIdStatusGetError =
  GetPipelineFileStatusApiV1PipelinesPipelineIdFilesFileIdStatusGetErrors[keyof GetPipelineFileStatusApiV1PipelinesPipelineIdFilesFileIdStatusGetErrors];

export type GetPipelineFileStatusApiV1PipelinesPipelineIdFilesFileIdStatusGetResponses =
  {
    /**
     * Successful Response
     */
    200: ManagedIngestionStatusResponse;
  };

export type GetPipelineFileStatusApiV1PipelinesPipelineIdFilesFileIdStatusGetResponse =
  GetPipelineFileStatusApiV1PipelinesPipelineIdFilesFileIdStatusGetResponses[keyof GetPipelineFileStatusApiV1PipelinesPipelineIdFilesFileIdStatusGetResponses];

export type DeletePipelineFileApiV1PipelinesPipelineIdFilesFileIdDeleteData = {
  body?: never;
  path: {
    file_id: string;
    pipeline_id: string;
  };
  query?: never;
  url: "/api/v1/pipelines/{pipeline_id}/files/{file_id}";
};

export type DeletePipelineFileApiV1PipelinesPipelineIdFilesFileIdDeleteErrors =
  {
    /**
     * Validation Error
     */
    422: HttpValidationError;
  };

export type DeletePipelineFileApiV1PipelinesPipelineIdFilesFileIdDeleteError =
  DeletePipelineFileApiV1PipelinesPipelineIdFilesFileIdDeleteErrors[keyof DeletePipelineFileApiV1PipelinesPipelineIdFilesFileIdDeleteErrors];

export type DeletePipelineFileApiV1PipelinesPipelineIdFilesFileIdDeleteResponses =
  {
    /**
     * Successful Response
     */
    204: void;
  };

export type DeletePipelineFileApiV1PipelinesPipelineIdFilesFileIdDeleteResponse =
  DeletePipelineFileApiV1PipelinesPipelineIdFilesFileIdDeleteResponses[keyof DeletePipelineFileApiV1PipelinesPipelineIdFilesFileIdDeleteResponses];

export type UpdatePipelineFileApiV1PipelinesPipelineIdFilesFileIdPutData = {
  body: PipelineFileUpdate;
  path: {
    file_id: string;
    pipeline_id: string;
  };
  query?: never;
  url: "/api/v1/pipelines/{pipeline_id}/files/{file_id}";
};

export type UpdatePipelineFileApiV1PipelinesPipelineIdFilesFileIdPutErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type UpdatePipelineFileApiV1PipelinesPipelineIdFilesFileIdPutError =
  UpdatePipelineFileApiV1PipelinesPipelineIdFilesFileIdPutErrors[keyof UpdatePipelineFileApiV1PipelinesPipelineIdFilesFileIdPutErrors];

export type UpdatePipelineFileApiV1PipelinesPipelineIdFilesFileIdPutResponses =
  {
    /**
     * Successful Response
     */
    200: PipelineFile;
  };

export type UpdatePipelineFileApiV1PipelinesPipelineIdFilesFileIdPutResponse =
  UpdatePipelineFileApiV1PipelinesPipelineIdFilesFileIdPutResponses[keyof UpdatePipelineFileApiV1PipelinesPipelineIdFilesFileIdPutResponses];

export type DeletePipelineFilesMetadataApiV1PipelinesPipelineIdMetadataDeleteData =
  {
    body?: never;
    path: {
      pipeline_id: string;
    };
    query?: never;
    url: "/api/v1/pipelines/{pipeline_id}/metadata";
  };

export type DeletePipelineFilesMetadataApiV1PipelinesPipelineIdMetadataDeleteErrors =
  {
    /**
     * Validation Error
     */
    422: HttpValidationError;
  };

export type DeletePipelineFilesMetadataApiV1PipelinesPipelineIdMetadataDeleteError =
  DeletePipelineFilesMetadataApiV1PipelinesPipelineIdMetadataDeleteErrors[keyof DeletePipelineFilesMetadataApiV1PipelinesPipelineIdMetadataDeleteErrors];

export type DeletePipelineFilesMetadataApiV1PipelinesPipelineIdMetadataDeleteResponses =
  {
    /**
     * Successful Response
     */
    204: void;
  };

export type DeletePipelineFilesMetadataApiV1PipelinesPipelineIdMetadataDeleteResponse =
  DeletePipelineFilesMetadataApiV1PipelinesPipelineIdMetadataDeleteResponses[keyof DeletePipelineFilesMetadataApiV1PipelinesPipelineIdMetadataDeleteResponses];

export type ImportPipelineMetadataApiV1PipelinesPipelineIdMetadataPutData = {
  body: BodyImportPipelineMetadataApiV1PipelinesPipelineIdMetadataPut;
  path: {
    pipeline_id: string;
  };
  query?: never;
  url: "/api/v1/pipelines/{pipeline_id}/metadata";
};

export type ImportPipelineMetadataApiV1PipelinesPipelineIdMetadataPutErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type ImportPipelineMetadataApiV1PipelinesPipelineIdMetadataPutError =
  ImportPipelineMetadataApiV1PipelinesPipelineIdMetadataPutErrors[keyof ImportPipelineMetadataApiV1PipelinesPipelineIdMetadataPutErrors];

export type ImportPipelineMetadataApiV1PipelinesPipelineIdMetadataPutResponses =
  {
    /**
     * Successful Response
     */
    200: {
      [key: string]: string;
    };
  };

export type ImportPipelineMetadataApiV1PipelinesPipelineIdMetadataPutResponse =
  ImportPipelineMetadataApiV1PipelinesPipelineIdMetadataPutResponses[keyof ImportPipelineMetadataApiV1PipelinesPipelineIdMetadataPutResponses];

export type ListPipelineDataSourcesApiV1PipelinesPipelineIdDataSourcesGetData =
  {
    body?: never;
    path: {
      pipeline_id: string;
    };
    query?: never;
    url: "/api/v1/pipelines/{pipeline_id}/data-sources";
  };

export type ListPipelineDataSourcesApiV1PipelinesPipelineIdDataSourcesGetErrors =
  {
    /**
     * Validation Error
     */
    422: HttpValidationError;
  };

export type ListPipelineDataSourcesApiV1PipelinesPipelineIdDataSourcesGetError =
  ListPipelineDataSourcesApiV1PipelinesPipelineIdDataSourcesGetErrors[keyof ListPipelineDataSourcesApiV1PipelinesPipelineIdDataSourcesGetErrors];

export type ListPipelineDataSourcesApiV1PipelinesPipelineIdDataSourcesGetResponses =
  {
    /**
     * Successful Response
     */
    200: Array<PipelineDataSourceReadable>;
  };

export type ListPipelineDataSourcesApiV1PipelinesPipelineIdDataSourcesGetResponse =
  ListPipelineDataSourcesApiV1PipelinesPipelineIdDataSourcesGetResponses[keyof ListPipelineDataSourcesApiV1PipelinesPipelineIdDataSourcesGetResponses];

export type AddDataSourcesToPipelineApiV1PipelinesPipelineIdDataSourcesPutData =
  {
    body: Array<PipelineDataSourceCreate>;
    path: {
      pipeline_id: string;
    };
    query?: never;
    url: "/api/v1/pipelines/{pipeline_id}/data-sources";
  };

export type AddDataSourcesToPipelineApiV1PipelinesPipelineIdDataSourcesPutErrors =
  {
    /**
     * Validation Error
     */
    422: HttpValidationError;
  };

export type AddDataSourcesToPipelineApiV1PipelinesPipelineIdDataSourcesPutError =
  AddDataSourcesToPipelineApiV1PipelinesPipelineIdDataSourcesPutErrors[keyof AddDataSourcesToPipelineApiV1PipelinesPipelineIdDataSourcesPutErrors];

export type AddDataSourcesToPipelineApiV1PipelinesPipelineIdDataSourcesPutResponses =
  {
    /**
     * Successful Response
     */
    200: Array<PipelineDataSourceReadable>;
  };

export type AddDataSourcesToPipelineApiV1PipelinesPipelineIdDataSourcesPutResponse =
  AddDataSourcesToPipelineApiV1PipelinesPipelineIdDataSourcesPutResponses[keyof AddDataSourcesToPipelineApiV1PipelinesPipelineIdDataSourcesPutResponses];

export type DeletePipelineDataSourceApiV1PipelinesPipelineIdDataSourcesDataSourceIdDeleteData =
  {
    body?: never;
    path: {
      data_source_id: string;
      pipeline_id: string;
    };
    query?: never;
    url: "/api/v1/pipelines/{pipeline_id}/data-sources/{data_source_id}";
  };

export type DeletePipelineDataSourceApiV1PipelinesPipelineIdDataSourcesDataSourceIdDeleteErrors =
  {
    /**
     * Validation Error
     */
    422: HttpValidationError;
  };

export type DeletePipelineDataSourceApiV1PipelinesPipelineIdDataSourcesDataSourceIdDeleteError =
  DeletePipelineDataSourceApiV1PipelinesPipelineIdDataSourcesDataSourceIdDeleteErrors[keyof DeletePipelineDataSourceApiV1PipelinesPipelineIdDataSourcesDataSourceIdDeleteErrors];

export type DeletePipelineDataSourceApiV1PipelinesPipelineIdDataSourcesDataSourceIdDeleteResponses =
  {
    /**
     * Successful Response
     */
    204: void;
  };

export type DeletePipelineDataSourceApiV1PipelinesPipelineIdDataSourcesDataSourceIdDeleteResponse =
  DeletePipelineDataSourceApiV1PipelinesPipelineIdDataSourcesDataSourceIdDeleteResponses[keyof DeletePipelineDataSourceApiV1PipelinesPipelineIdDataSourcesDataSourceIdDeleteResponses];

export type UpdatePipelineDataSourceApiV1PipelinesPipelineIdDataSourcesDataSourceIdPutData =
  {
    body: PipelineDataSourceUpdate;
    path: {
      data_source_id: string;
      pipeline_id: string;
    };
    query?: never;
    url: "/api/v1/pipelines/{pipeline_id}/data-sources/{data_source_id}";
  };

export type UpdatePipelineDataSourceApiV1PipelinesPipelineIdDataSourcesDataSourceIdPutErrors =
  {
    /**
     * Validation Error
     */
    422: HttpValidationError;
  };

export type UpdatePipelineDataSourceApiV1PipelinesPipelineIdDataSourcesDataSourceIdPutError =
  UpdatePipelineDataSourceApiV1PipelinesPipelineIdDataSourcesDataSourceIdPutErrors[keyof UpdatePipelineDataSourceApiV1PipelinesPipelineIdDataSourcesDataSourceIdPutErrors];

export type UpdatePipelineDataSourceApiV1PipelinesPipelineIdDataSourcesDataSourceIdPutResponses =
  {
    /**
     * Successful Response
     */
    200: PipelineDataSourceReadable;
  };

export type UpdatePipelineDataSourceApiV1PipelinesPipelineIdDataSourcesDataSourceIdPutResponse =
  UpdatePipelineDataSourceApiV1PipelinesPipelineIdDataSourcesDataSourceIdPutResponses[keyof UpdatePipelineDataSourceApiV1PipelinesPipelineIdDataSourcesDataSourceIdPutResponses];

export type SyncPipelineDataSourceApiV1PipelinesPipelineIdDataSourcesDataSourceIdSyncPostData =
  {
    body?: never;
    path: {
      data_source_id: string;
      pipeline_id: string;
    };
    query?: never;
    url: "/api/v1/pipelines/{pipeline_id}/data-sources/{data_source_id}/sync";
  };

export type SyncPipelineDataSourceApiV1PipelinesPipelineIdDataSourcesDataSourceIdSyncPostErrors =
  {
    /**
     * Validation Error
     */
    422: HttpValidationError;
  };

export type SyncPipelineDataSourceApiV1PipelinesPipelineIdDataSourcesDataSourceIdSyncPostError =
  SyncPipelineDataSourceApiV1PipelinesPipelineIdDataSourcesDataSourceIdSyncPostErrors[keyof SyncPipelineDataSourceApiV1PipelinesPipelineIdDataSourcesDataSourceIdSyncPostErrors];

export type SyncPipelineDataSourceApiV1PipelinesPipelineIdDataSourcesDataSourceIdSyncPostResponses =
  {
    /**
     * Successful Response
     */
    200: PipelineReadable;
  };

export type SyncPipelineDataSourceApiV1PipelinesPipelineIdDataSourcesDataSourceIdSyncPostResponse =
  SyncPipelineDataSourceApiV1PipelinesPipelineIdDataSourcesDataSourceIdSyncPostResponses[keyof SyncPipelineDataSourceApiV1PipelinesPipelineIdDataSourcesDataSourceIdSyncPostResponses];

export type GetPipelineDataSourceStatusApiV1PipelinesPipelineIdDataSourcesDataSourceIdStatusGetData =
  {
    body?: never;
    path: {
      data_source_id: string;
      pipeline_id: string;
    };
    query?: never;
    url: "/api/v1/pipelines/{pipeline_id}/data-sources/{data_source_id}/status";
  };

export type GetPipelineDataSourceStatusApiV1PipelinesPipelineIdDataSourcesDataSourceIdStatusGetErrors =
  {
    /**
     * Validation Error
     */
    422: HttpValidationError;
  };

export type GetPipelineDataSourceStatusApiV1PipelinesPipelineIdDataSourcesDataSourceIdStatusGetError =
  GetPipelineDataSourceStatusApiV1PipelinesPipelineIdDataSourcesDataSourceIdStatusGetErrors[keyof GetPipelineDataSourceStatusApiV1PipelinesPipelineIdDataSourcesDataSourceIdStatusGetErrors];

export type GetPipelineDataSourceStatusApiV1PipelinesPipelineIdDataSourcesDataSourceIdStatusGetResponses =
  {
    /**
     * Successful Response
     */
    200: ManagedIngestionStatusResponse;
  };

export type GetPipelineDataSourceStatusApiV1PipelinesPipelineIdDataSourcesDataSourceIdStatusGetResponse =
  GetPipelineDataSourceStatusApiV1PipelinesPipelineIdDataSourcesDataSourceIdStatusGetResponses[keyof GetPipelineDataSourceStatusApiV1PipelinesPipelineIdDataSourcesDataSourceIdStatusGetResponses];

export type RunSearchApiV1PipelinesPipelineIdRetrievePostData = {
  body: RetrievalParams;
  path: {
    pipeline_id: string;
  };
  query?: {
    project_id?: string | null;
    organization_id?: string | null;
  };
  url: "/api/v1/pipelines/{pipeline_id}/retrieve";
};

export type RunSearchApiV1PipelinesPipelineIdRetrievePostErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type RunSearchApiV1PipelinesPipelineIdRetrievePostError =
  RunSearchApiV1PipelinesPipelineIdRetrievePostErrors[keyof RunSearchApiV1PipelinesPipelineIdRetrievePostErrors];

export type RunSearchApiV1PipelinesPipelineIdRetrievePostResponses = {
  /**
   * Successful Response
   */
  200: RetrieveResults;
};

export type RunSearchApiV1PipelinesPipelineIdRetrievePostResponse =
  RunSearchApiV1PipelinesPipelineIdRetrievePostResponses[keyof RunSearchApiV1PipelinesPipelineIdRetrievePostResponses];

export type ListPipelineJobsApiV1PipelinesPipelineIdJobsGetData = {
  body?: never;
  path: {
    pipeline_id: string;
  };
  query?: never;
  url: "/api/v1/pipelines/{pipeline_id}/jobs";
};

export type ListPipelineJobsApiV1PipelinesPipelineIdJobsGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type ListPipelineJobsApiV1PipelinesPipelineIdJobsGetError =
  ListPipelineJobsApiV1PipelinesPipelineIdJobsGetErrors[keyof ListPipelineJobsApiV1PipelinesPipelineIdJobsGetErrors];

export type ListPipelineJobsApiV1PipelinesPipelineIdJobsGetResponses = {
  /**
   * Successful Response
   */
  200: Array<PipelineDeployment>;
};

export type ListPipelineJobsApiV1PipelinesPipelineIdJobsGetResponse =
  ListPipelineJobsApiV1PipelinesPipelineIdJobsGetResponses[keyof ListPipelineJobsApiV1PipelinesPipelineIdJobsGetResponses];

export type GetPipelineJobApiV1PipelinesPipelineIdJobsJobIdGetData = {
  body?: never;
  path: {
    job_id: string;
    pipeline_id: string;
  };
  query?: never;
  url: "/api/v1/pipelines/{pipeline_id}/jobs/{job_id}";
};

export type GetPipelineJobApiV1PipelinesPipelineIdJobsJobIdGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type GetPipelineJobApiV1PipelinesPipelineIdJobsJobIdGetError =
  GetPipelineJobApiV1PipelinesPipelineIdJobsJobIdGetErrors[keyof GetPipelineJobApiV1PipelinesPipelineIdJobsJobIdGetErrors];

export type GetPipelineJobApiV1PipelinesPipelineIdJobsJobIdGetResponses = {
  /**
   * Successful Response
   */
  200: PipelineDeployment;
};

export type GetPipelineJobApiV1PipelinesPipelineIdJobsJobIdGetResponse =
  GetPipelineJobApiV1PipelinesPipelineIdJobsJobIdGetResponses[keyof GetPipelineJobApiV1PipelinesPipelineIdJobsJobIdGetResponses];

export type GetPlaygroundSessionApiV1PipelinesPipelineIdPlaygroundSessionGetData =
  {
    body?: never;
    path: {
      pipeline_id: string;
    };
    query?: never;
    url: "/api/v1/pipelines/{pipeline_id}/playground-session";
  };

export type GetPlaygroundSessionApiV1PipelinesPipelineIdPlaygroundSessionGetErrors =
  {
    /**
     * Validation Error
     */
    422: HttpValidationError;
  };

export type GetPlaygroundSessionApiV1PipelinesPipelineIdPlaygroundSessionGetError =
  GetPlaygroundSessionApiV1PipelinesPipelineIdPlaygroundSessionGetErrors[keyof GetPlaygroundSessionApiV1PipelinesPipelineIdPlaygroundSessionGetErrors];

export type GetPlaygroundSessionApiV1PipelinesPipelineIdPlaygroundSessionGetResponses =
  {
    /**
     * Successful Response
     */
    200: PlaygroundSession;
  };

export type GetPlaygroundSessionApiV1PipelinesPipelineIdPlaygroundSessionGetResponse =
  GetPlaygroundSessionApiV1PipelinesPipelineIdPlaygroundSessionGetResponses[keyof GetPlaygroundSessionApiV1PipelinesPipelineIdPlaygroundSessionGetResponses];

export type ChatApiV1PipelinesPipelineIdChatPostData = {
  body: ChatInputParams;
  path: {
    pipeline_id: string;
  };
  query?: never;
  url: "/api/v1/pipelines/{pipeline_id}/chat";
};

export type ChatApiV1PipelinesPipelineIdChatPostErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type ChatApiV1PipelinesPipelineIdChatPostError =
  ChatApiV1PipelinesPipelineIdChatPostErrors[keyof ChatApiV1PipelinesPipelineIdChatPostErrors];

export type ChatApiV1PipelinesPipelineIdChatPostResponses = {
  /**
   * Successful Response
   */
  200: unknown;
};

export type ListPipelineDocumentsApiV1PipelinesPipelineIdDocumentsGetData = {
  body?: never;
  path: {
    pipeline_id: string;
  };
  query?: {
    skip?: number;
    limit?: number;
    file_id?: string | null;
    only_direct_upload?: boolean | null;
    only_api_data_source_documents?: boolean | null;
  };
  url: "/api/v1/pipelines/{pipeline_id}/documents";
};

export type ListPipelineDocumentsApiV1PipelinesPipelineIdDocumentsGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type ListPipelineDocumentsApiV1PipelinesPipelineIdDocumentsGetError =
  ListPipelineDocumentsApiV1PipelinesPipelineIdDocumentsGetErrors[keyof ListPipelineDocumentsApiV1PipelinesPipelineIdDocumentsGetErrors];

export type ListPipelineDocumentsApiV1PipelinesPipelineIdDocumentsGetResponses =
  {
    /**
     * Successful Response
     */
    200: Array<CloudDocument>;
  };

export type ListPipelineDocumentsApiV1PipelinesPipelineIdDocumentsGetResponse =
  ListPipelineDocumentsApiV1PipelinesPipelineIdDocumentsGetResponses[keyof ListPipelineDocumentsApiV1PipelinesPipelineIdDocumentsGetResponses];

export type CreateBatchPipelineDocumentsApiV1PipelinesPipelineIdDocumentsPostData =
  {
    body: Array<CloudDocumentCreate>;
    path: {
      pipeline_id: string;
    };
    query?: never;
    url: "/api/v1/pipelines/{pipeline_id}/documents";
  };

export type CreateBatchPipelineDocumentsApiV1PipelinesPipelineIdDocumentsPostErrors =
  {
    /**
     * Validation Error
     */
    422: HttpValidationError;
  };

export type CreateBatchPipelineDocumentsApiV1PipelinesPipelineIdDocumentsPostError =
  CreateBatchPipelineDocumentsApiV1PipelinesPipelineIdDocumentsPostErrors[keyof CreateBatchPipelineDocumentsApiV1PipelinesPipelineIdDocumentsPostErrors];

export type CreateBatchPipelineDocumentsApiV1PipelinesPipelineIdDocumentsPostResponses =
  {
    /**
     * Successful Response
     */
    200: Array<CloudDocument>;
  };

export type CreateBatchPipelineDocumentsApiV1PipelinesPipelineIdDocumentsPostResponse =
  CreateBatchPipelineDocumentsApiV1PipelinesPipelineIdDocumentsPostResponses[keyof CreateBatchPipelineDocumentsApiV1PipelinesPipelineIdDocumentsPostResponses];

export type UpsertBatchPipelineDocumentsApiV1PipelinesPipelineIdDocumentsPutData =
  {
    body: Array<CloudDocumentCreate>;
    path: {
      pipeline_id: string;
    };
    query?: never;
    url: "/api/v1/pipelines/{pipeline_id}/documents";
  };

export type UpsertBatchPipelineDocumentsApiV1PipelinesPipelineIdDocumentsPutErrors =
  {
    /**
     * Validation Error
     */
    422: HttpValidationError;
  };

export type UpsertBatchPipelineDocumentsApiV1PipelinesPipelineIdDocumentsPutError =
  UpsertBatchPipelineDocumentsApiV1PipelinesPipelineIdDocumentsPutErrors[keyof UpsertBatchPipelineDocumentsApiV1PipelinesPipelineIdDocumentsPutErrors];

export type UpsertBatchPipelineDocumentsApiV1PipelinesPipelineIdDocumentsPutResponses =
  {
    /**
     * Successful Response
     */
    200: Array<CloudDocument>;
  };

export type UpsertBatchPipelineDocumentsApiV1PipelinesPipelineIdDocumentsPutResponse =
  UpsertBatchPipelineDocumentsApiV1PipelinesPipelineIdDocumentsPutResponses[keyof UpsertBatchPipelineDocumentsApiV1PipelinesPipelineIdDocumentsPutResponses];

export type PaginatedListPipelineDocumentsApiV1PipelinesPipelineIdDocumentsPaginatedGetData =
  {
    body?: never;
    path: {
      pipeline_id: string;
    };
    query?: {
      skip?: number;
      limit?: number;
      file_id?: string | null;
      only_direct_upload?: boolean | null;
      only_api_data_source_documents?: boolean | null;
    };
    url: "/api/v1/pipelines/{pipeline_id}/documents/paginated";
  };

export type PaginatedListPipelineDocumentsApiV1PipelinesPipelineIdDocumentsPaginatedGetErrors =
  {
    /**
     * Validation Error
     */
    422: HttpValidationError;
  };

export type PaginatedListPipelineDocumentsApiV1PipelinesPipelineIdDocumentsPaginatedGetError =
  PaginatedListPipelineDocumentsApiV1PipelinesPipelineIdDocumentsPaginatedGetErrors[keyof PaginatedListPipelineDocumentsApiV1PipelinesPipelineIdDocumentsPaginatedGetErrors];

export type PaginatedListPipelineDocumentsApiV1PipelinesPipelineIdDocumentsPaginatedGetResponses =
  {
    /**
     * Successful Response
     */
    200: PaginatedListCloudDocumentsResponse;
  };

export type PaginatedListPipelineDocumentsApiV1PipelinesPipelineIdDocumentsPaginatedGetResponse =
  PaginatedListPipelineDocumentsApiV1PipelinesPipelineIdDocumentsPaginatedGetResponses[keyof PaginatedListPipelineDocumentsApiV1PipelinesPipelineIdDocumentsPaginatedGetResponses];

export type DeletePipelineDocumentApiV1PipelinesPipelineIdDocumentsDocumentIdDeleteData =
  {
    body?: never;
    path: {
      document_id: string;
      pipeline_id: string;
    };
    query?: never;
    url: "/api/v1/pipelines/{pipeline_id}/documents/{document_id}";
  };

export type DeletePipelineDocumentApiV1PipelinesPipelineIdDocumentsDocumentIdDeleteErrors =
  {
    /**
     * Validation Error
     */
    422: HttpValidationError;
  };

export type DeletePipelineDocumentApiV1PipelinesPipelineIdDocumentsDocumentIdDeleteError =
  DeletePipelineDocumentApiV1PipelinesPipelineIdDocumentsDocumentIdDeleteErrors[keyof DeletePipelineDocumentApiV1PipelinesPipelineIdDocumentsDocumentIdDeleteErrors];

export type DeletePipelineDocumentApiV1PipelinesPipelineIdDocumentsDocumentIdDeleteResponses =
  {
    /**
     * Successful Response
     */
    204: void;
  };

export type DeletePipelineDocumentApiV1PipelinesPipelineIdDocumentsDocumentIdDeleteResponse =
  DeletePipelineDocumentApiV1PipelinesPipelineIdDocumentsDocumentIdDeleteResponses[keyof DeletePipelineDocumentApiV1PipelinesPipelineIdDocumentsDocumentIdDeleteResponses];

export type GetPipelineDocumentApiV1PipelinesPipelineIdDocumentsDocumentIdGetData =
  {
    body?: never;
    path: {
      document_id: string;
      pipeline_id: string;
    };
    query?: never;
    url: "/api/v1/pipelines/{pipeline_id}/documents/{document_id}";
  };

export type GetPipelineDocumentApiV1PipelinesPipelineIdDocumentsDocumentIdGetErrors =
  {
    /**
     * Validation Error
     */
    422: HttpValidationError;
  };

export type GetPipelineDocumentApiV1PipelinesPipelineIdDocumentsDocumentIdGetError =
  GetPipelineDocumentApiV1PipelinesPipelineIdDocumentsDocumentIdGetErrors[keyof GetPipelineDocumentApiV1PipelinesPipelineIdDocumentsDocumentIdGetErrors];

export type GetPipelineDocumentApiV1PipelinesPipelineIdDocumentsDocumentIdGetResponses =
  {
    /**
     * Successful Response
     */
    200: CloudDocument;
  };

export type GetPipelineDocumentApiV1PipelinesPipelineIdDocumentsDocumentIdGetResponse =
  GetPipelineDocumentApiV1PipelinesPipelineIdDocumentsDocumentIdGetResponses[keyof GetPipelineDocumentApiV1PipelinesPipelineIdDocumentsDocumentIdGetResponses];

export type GetPipelineDocumentStatusApiV1PipelinesPipelineIdDocumentsDocumentIdStatusGetData =
  {
    body?: never;
    path: {
      document_id: string;
      pipeline_id: string;
    };
    query?: never;
    url: "/api/v1/pipelines/{pipeline_id}/documents/{document_id}/status";
  };

export type GetPipelineDocumentStatusApiV1PipelinesPipelineIdDocumentsDocumentIdStatusGetErrors =
  {
    /**
     * Validation Error
     */
    422: HttpValidationError;
  };

export type GetPipelineDocumentStatusApiV1PipelinesPipelineIdDocumentsDocumentIdStatusGetError =
  GetPipelineDocumentStatusApiV1PipelinesPipelineIdDocumentsDocumentIdStatusGetErrors[keyof GetPipelineDocumentStatusApiV1PipelinesPipelineIdDocumentsDocumentIdStatusGetErrors];

export type GetPipelineDocumentStatusApiV1PipelinesPipelineIdDocumentsDocumentIdStatusGetResponses =
  {
    /**
     * Successful Response
     */
    200: ManagedIngestionStatusResponse;
  };

export type GetPipelineDocumentStatusApiV1PipelinesPipelineIdDocumentsDocumentIdStatusGetResponse =
  GetPipelineDocumentStatusApiV1PipelinesPipelineIdDocumentsDocumentIdStatusGetResponses[keyof GetPipelineDocumentStatusApiV1PipelinesPipelineIdDocumentsDocumentIdStatusGetResponses];

export type SyncPipelineDocumentApiV1PipelinesPipelineIdDocumentsDocumentIdSyncPostData =
  {
    body?: never;
    path: {
      document_id: string;
      pipeline_id: string;
    };
    query?: never;
    url: "/api/v1/pipelines/{pipeline_id}/documents/{document_id}/sync";
  };

export type SyncPipelineDocumentApiV1PipelinesPipelineIdDocumentsDocumentIdSyncPostErrors =
  {
    /**
     * Validation Error
     */
    422: HttpValidationError;
  };

export type SyncPipelineDocumentApiV1PipelinesPipelineIdDocumentsDocumentIdSyncPostError =
  SyncPipelineDocumentApiV1PipelinesPipelineIdDocumentsDocumentIdSyncPostErrors[keyof SyncPipelineDocumentApiV1PipelinesPipelineIdDocumentsDocumentIdSyncPostErrors];

export type SyncPipelineDocumentApiV1PipelinesPipelineIdDocumentsDocumentIdSyncPostResponses =
  {
    /**
     * Successful Response
     */
    200: unknown;
  };

export type ListPipelineDocumentChunksApiV1PipelinesPipelineIdDocumentsDocumentIdChunksGetData =
  {
    body?: never;
    path: {
      document_id: string;
      pipeline_id: string;
    };
    query?: never;
    url: "/api/v1/pipelines/{pipeline_id}/documents/{document_id}/chunks";
  };

export type ListPipelineDocumentChunksApiV1PipelinesPipelineIdDocumentsDocumentIdChunksGetErrors =
  {
    /**
     * Validation Error
     */
    422: HttpValidationError;
  };

export type ListPipelineDocumentChunksApiV1PipelinesPipelineIdDocumentsDocumentIdChunksGetError =
  ListPipelineDocumentChunksApiV1PipelinesPipelineIdDocumentsDocumentIdChunksGetErrors[keyof ListPipelineDocumentChunksApiV1PipelinesPipelineIdDocumentsDocumentIdChunksGetErrors];

export type ListPipelineDocumentChunksApiV1PipelinesPipelineIdDocumentsDocumentIdChunksGetResponses =
  {
    /**
     * Successful Response
     */
    200: Array<TextNode>;
  };

export type ListPipelineDocumentChunksApiV1PipelinesPipelineIdDocumentsDocumentIdChunksGetResponse =
  ListPipelineDocumentChunksApiV1PipelinesPipelineIdDocumentsDocumentIdChunksGetResponses[keyof ListPipelineDocumentChunksApiV1PipelinesPipelineIdDocumentsDocumentIdChunksGetResponses];

export type ForceSyncAllPipelineDocumentsApiV1PipelinesPipelineIdDocumentsForceSyncAllPostData =
  {
    body?: never;
    path: {
      pipeline_id: string;
    };
    query?: {
      batch_size?: number;
      /**
       * Only sync retriable documents (failed/cancelled/not-started/stalled-in-progress)
       */
      only_failed?: boolean;
    };
    url: "/api/v1/pipelines/{pipeline_id}/documents/force-sync-all";
  };

export type ForceSyncAllPipelineDocumentsApiV1PipelinesPipelineIdDocumentsForceSyncAllPostErrors =
  {
    /**
     * Validation Error
     */
    422: HttpValidationError;
  };

export type ForceSyncAllPipelineDocumentsApiV1PipelinesPipelineIdDocumentsForceSyncAllPostError =
  ForceSyncAllPipelineDocumentsApiV1PipelinesPipelineIdDocumentsForceSyncAllPostErrors[keyof ForceSyncAllPipelineDocumentsApiV1PipelinesPipelineIdDocumentsForceSyncAllPostErrors];

export type ForceSyncAllPipelineDocumentsApiV1PipelinesPipelineIdDocumentsForceSyncAllPostResponses =
  {
    /**
     * Successful Response
     */
    202: unknown;
  };

export type ListRetrieversApiV1RetrieversGetData = {
  body?: never;
  path?: never;
  query?: {
    name?: string | null;
    project_id?: string | null;
    organization_id?: string | null;
  };
  url: "/api/v1/retrievers";
};

export type ListRetrieversApiV1RetrieversGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type ListRetrieversApiV1RetrieversGetError =
  ListRetrieversApiV1RetrieversGetErrors[keyof ListRetrieversApiV1RetrieversGetErrors];

export type ListRetrieversApiV1RetrieversGetResponses = {
  /**
   * Successful Response
   */
  200: Array<Retriever>;
};

export type ListRetrieversApiV1RetrieversGetResponse =
  ListRetrieversApiV1RetrieversGetResponses[keyof ListRetrieversApiV1RetrieversGetResponses];

export type CreateRetrieverApiV1RetrieversPostData = {
  body: RetrieverCreate;
  path?: never;
  query?: {
    project_id?: string | null;
    organization_id?: string | null;
  };
  url: "/api/v1/retrievers";
};

export type CreateRetrieverApiV1RetrieversPostErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type CreateRetrieverApiV1RetrieversPostError =
  CreateRetrieverApiV1RetrieversPostErrors[keyof CreateRetrieverApiV1RetrieversPostErrors];

export type CreateRetrieverApiV1RetrieversPostResponses = {
  /**
   * Successful Response
   */
  200: Retriever;
};

export type CreateRetrieverApiV1RetrieversPostResponse =
  CreateRetrieverApiV1RetrieversPostResponses[keyof CreateRetrieverApiV1RetrieversPostResponses];

export type UpsertRetrieverApiV1RetrieversPutData = {
  body: RetrieverCreate;
  path?: never;
  query?: {
    project_id?: string | null;
    organization_id?: string | null;
  };
  url: "/api/v1/retrievers";
};

export type UpsertRetrieverApiV1RetrieversPutErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type UpsertRetrieverApiV1RetrieversPutError =
  UpsertRetrieverApiV1RetrieversPutErrors[keyof UpsertRetrieverApiV1RetrieversPutErrors];

export type UpsertRetrieverApiV1RetrieversPutResponses = {
  /**
   * Successful Response
   */
  200: Retriever;
};

export type UpsertRetrieverApiV1RetrieversPutResponse =
  UpsertRetrieverApiV1RetrieversPutResponses[keyof UpsertRetrieverApiV1RetrieversPutResponses];

export type DeleteRetrieverApiV1RetrieversRetrieverIdDeleteData = {
  body?: never;
  path: {
    retriever_id: string;
  };
  query?: never;
  url: "/api/v1/retrievers/{retriever_id}";
};

export type DeleteRetrieverApiV1RetrieversRetrieverIdDeleteErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type DeleteRetrieverApiV1RetrieversRetrieverIdDeleteError =
  DeleteRetrieverApiV1RetrieversRetrieverIdDeleteErrors[keyof DeleteRetrieverApiV1RetrieversRetrieverIdDeleteErrors];

export type DeleteRetrieverApiV1RetrieversRetrieverIdDeleteResponses = {
  /**
   * Successful Response
   */
  204: void;
};

export type DeleteRetrieverApiV1RetrieversRetrieverIdDeleteResponse =
  DeleteRetrieverApiV1RetrieversRetrieverIdDeleteResponses[keyof DeleteRetrieverApiV1RetrieversRetrieverIdDeleteResponses];

export type GetRetrieverApiV1RetrieversRetrieverIdGetData = {
  body?: never;
  path: {
    retriever_id: string;
  };
  query?: {
    project_id?: string | null;
    organization_id?: string | null;
  };
  url: "/api/v1/retrievers/{retriever_id}";
};

export type GetRetrieverApiV1RetrieversRetrieverIdGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type GetRetrieverApiV1RetrieversRetrieverIdGetError =
  GetRetrieverApiV1RetrieversRetrieverIdGetErrors[keyof GetRetrieverApiV1RetrieversRetrieverIdGetErrors];

export type GetRetrieverApiV1RetrieversRetrieverIdGetResponses = {
  /**
   * Successful Response
   */
  200: Retriever;
};

export type GetRetrieverApiV1RetrieversRetrieverIdGetResponse =
  GetRetrieverApiV1RetrieversRetrieverIdGetResponses[keyof GetRetrieverApiV1RetrieversRetrieverIdGetResponses];

export type UpdateRetrieverApiV1RetrieversRetrieverIdPutData = {
  body: RetrieverUpdate;
  path: {
    retriever_id: string;
  };
  query?: never;
  url: "/api/v1/retrievers/{retriever_id}";
};

export type UpdateRetrieverApiV1RetrieversRetrieverIdPutErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type UpdateRetrieverApiV1RetrieversRetrieverIdPutError =
  UpdateRetrieverApiV1RetrieversRetrieverIdPutErrors[keyof UpdateRetrieverApiV1RetrieversRetrieverIdPutErrors];

export type UpdateRetrieverApiV1RetrieversRetrieverIdPutResponses = {
  /**
   * Successful Response
   */
  200: Retriever;
};

export type UpdateRetrieverApiV1RetrieversRetrieverIdPutResponse =
  UpdateRetrieverApiV1RetrieversRetrieverIdPutResponses[keyof UpdateRetrieverApiV1RetrieversRetrieverIdPutResponses];

export type RetrieveApiV1RetrieversRetrieverIdRetrievePostData = {
  body: CompositeRetrievalParams;
  path: {
    retriever_id: string;
  };
  query?: {
    project_id?: string | null;
    organization_id?: string | null;
  };
  url: "/api/v1/retrievers/{retriever_id}/retrieve";
};

export type RetrieveApiV1RetrieversRetrieverIdRetrievePostErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type RetrieveApiV1RetrieversRetrieverIdRetrievePostError =
  RetrieveApiV1RetrieversRetrieverIdRetrievePostErrors[keyof RetrieveApiV1RetrieversRetrieverIdRetrievePostErrors];

export type RetrieveApiV1RetrieversRetrieverIdRetrievePostResponses = {
  /**
   * Successful Response
   */
  200: CompositeRetrievalResult;
};

export type RetrieveApiV1RetrieversRetrieverIdRetrievePostResponse =
  RetrieveApiV1RetrieversRetrieverIdRetrievePostResponses[keyof RetrieveApiV1RetrieversRetrieverIdRetrievePostResponses];

export type DirectRetrieveApiV1RetrieversRetrievePostData = {
  body: DirectRetrievalParams;
  path?: never;
  query?: {
    project_id?: string | null;
    organization_id?: string | null;
  };
  url: "/api/v1/retrievers/retrieve";
};

export type DirectRetrieveApiV1RetrieversRetrievePostErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type DirectRetrieveApiV1RetrieversRetrievePostError =
  DirectRetrieveApiV1RetrieversRetrievePostErrors[keyof DirectRetrieveApiV1RetrieversRetrievePostErrors];

export type DirectRetrieveApiV1RetrieversRetrievePostResponses = {
  /**
   * Successful Response
   */
  200: CompositeRetrievalResult;
};

export type DirectRetrieveApiV1RetrieversRetrievePostResponse =
  DirectRetrieveApiV1RetrieversRetrievePostResponses[keyof DirectRetrieveApiV1RetrieversRetrievePostResponses];

export type GetJobsApiV1JobsGetData = {
  body?: never;
  path?: never;
  query?: {
    job_name?: string | null;
    limit?: number;
    offset?: number;
    sort?: string | null;
    /**
     * Deprecated: This parameter is no longer supported as we've moved to usage v2. It will be removed in a future version.
     * @deprecated
     */
    include_usage_metrics?: boolean;
    project_id?: string | null;
    organization_id?: string | null;
  };
  url: "/api/v1/jobs";
};

export type GetJobsApiV1JobsGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type GetJobsApiV1JobsGetError =
  GetJobsApiV1JobsGetErrors[keyof GetJobsApiV1JobsGetErrors];

export type GetJobsApiV1JobsGetResponses = {
  /**
   * Successful Response
   */
  200: PaginatedJobsHistoryWithMetrics;
};

export type GetJobsApiV1JobsGetResponse =
  GetJobsApiV1JobsGetResponses[keyof GetJobsApiV1JobsGetResponses];

export type ListSupportedModelsApiV1EvalsModelsGetData = {
  body?: never;
  path?: never;
  query?: never;
  url: "/api/v1/evals/models";
};

export type ListSupportedModelsApiV1EvalsModelsGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type ListSupportedModelsApiV1EvalsModelsGetError =
  ListSupportedModelsApiV1EvalsModelsGetErrors[keyof ListSupportedModelsApiV1EvalsModelsGetErrors];

export type ListSupportedModelsApiV1EvalsModelsGetResponses = {
  /**
   * Successful Response
   */
  200: Array<SupportedLlmModel>;
};

export type ListSupportedModelsApiV1EvalsModelsGetResponse =
  ListSupportedModelsApiV1EvalsModelsGetResponses[keyof ListSupportedModelsApiV1EvalsModelsGetResponses];

export type GetJobImageResultApiV1ParsingJobJobIdResultImageNameGetData = {
  body?: never;
  path: {
    job_id: string;
    name: string;
  };
  query?: never;
  url: "/api/v1/parsing/job/{job_id}/result/image/{name}";
};

export type GetJobImageResultApiV1ParsingJobJobIdResultImageNameGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type GetJobImageResultApiV1ParsingJobJobIdResultImageNameGetError =
  GetJobImageResultApiV1ParsingJobJobIdResultImageNameGetErrors[keyof GetJobImageResultApiV1ParsingJobJobIdResultImageNameGetErrors];

export type GetJobImageResultApiV1ParsingJobJobIdResultImageNameGetResponses = {
  /**
   * Successful Response
   */
  200: unknown;
};

export type GetSupportedFileExtensionsApiV1ParsingSupportedFileExtensionsGetData =
  {
    body?: never;
    path?: never;
    query?: never;
    url: "/api/v1/parsing/supported_file_extensions";
  };

export type GetSupportedFileExtensionsApiV1ParsingSupportedFileExtensionsGetResponses =
  {
    /**
     * Successful Response
     */
    200: Array<LlamaParseSupportedFileExtensions>;
  };

export type GetSupportedFileExtensionsApiV1ParsingSupportedFileExtensionsGetResponse =
  GetSupportedFileExtensionsApiV1ParsingSupportedFileExtensionsGetResponses[keyof GetSupportedFileExtensionsApiV1ParsingSupportedFileExtensionsGetResponses];

export type ScreenshotApiV1ParsingScreenshotPostData = {
  body?: BodyScreenshotApiV1ParsingScreenshotPost;
  path?: never;
  query?: {
    organization_id?: string | null;
    project_id?: string | null;
  };
  url: "/api/v1/parsing/screenshot";
};

export type ScreenshotApiV1ParsingScreenshotPostErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type ScreenshotApiV1ParsingScreenshotPostError =
  ScreenshotApiV1ParsingScreenshotPostErrors[keyof ScreenshotApiV1ParsingScreenshotPostErrors];

export type ScreenshotApiV1ParsingScreenshotPostResponses = {
  /**
   * Successful Response
   */
  200: ParsingJob;
};

export type ScreenshotApiV1ParsingScreenshotPostResponse =
  ScreenshotApiV1ParsingScreenshotPostResponses[keyof ScreenshotApiV1ParsingScreenshotPostResponses];

export type UploadFileApiV1ParsingUploadPostData = {
  body?: BodyUploadFileApiV1ParsingUploadPost;
  path?: never;
  query?: {
    organization_id?: string | null;
    project_id?: string | null;
  };
  url: "/api/v1/parsing/upload";
};

export type UploadFileApiV1ParsingUploadPostErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type UploadFileApiV1ParsingUploadPostError =
  UploadFileApiV1ParsingUploadPostErrors[keyof UploadFileApiV1ParsingUploadPostErrors];

export type UploadFileApiV1ParsingUploadPostResponses = {
  /**
   * Successful Response
   */
  200: ParsingJob;
};

export type UploadFileApiV1ParsingUploadPostResponse =
  UploadFileApiV1ParsingUploadPostResponses[keyof UploadFileApiV1ParsingUploadPostResponses];

export type GetJobApiV1ParsingJobJobIdGetData = {
  body?: never;
  path: {
    job_id: string;
  };
  query?: never;
  url: "/api/v1/parsing/job/{job_id}";
};

export type GetJobApiV1ParsingJobJobIdGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type GetJobApiV1ParsingJobJobIdGetError =
  GetJobApiV1ParsingJobJobIdGetErrors[keyof GetJobApiV1ParsingJobJobIdGetErrors];

export type GetJobApiV1ParsingJobJobIdGetResponses = {
  /**
   * Successful Response
   */
  200: ParsingJob;
};

export type GetJobApiV1ParsingJobJobIdGetResponse =
  GetJobApiV1ParsingJobJobIdGetResponses[keyof GetJobApiV1ParsingJobJobIdGetResponses];

export type GetJobParametersApiV1ParsingJobJobIdParametersGetData = {
  body?: never;
  path: {
    job_id: string;
  };
  query?: never;
  url: "/api/v1/parsing/job/{job_id}/parameters";
};

export type GetJobParametersApiV1ParsingJobJobIdParametersGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type GetJobParametersApiV1ParsingJobJobIdParametersGetError =
  GetJobParametersApiV1ParsingJobJobIdParametersGetErrors[keyof GetJobParametersApiV1ParsingJobJobIdParametersGetErrors];

export type GetJobParametersApiV1ParsingJobJobIdParametersGetResponses = {
  /**
   * Successful Response
   */
  200: unknown;
};

export type GetParsingJobDetailsApiV1ParsingJobJobIdDetailsGetData = {
  body?: never;
  path: {
    job_id: string;
  };
  query?: never;
  url: "/api/v1/parsing/job/{job_id}/details";
};

export type GetParsingJobDetailsApiV1ParsingJobJobIdDetailsGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type GetParsingJobDetailsApiV1ParsingJobJobIdDetailsGetError =
  GetParsingJobDetailsApiV1ParsingJobJobIdDetailsGetErrors[keyof GetParsingJobDetailsApiV1ParsingJobJobIdDetailsGetErrors];

export type GetParsingJobDetailsApiV1ParsingJobJobIdDetailsGetResponses = {
  /**
   * Successful Response
   */
  200: unknown;
};

export type GetJobTextResultApiV1ParsingJobJobIdResultTextGetData = {
  body?: never;
  path: {
    job_id: string;
  };
  query?: {
    organization_id?: string | null;
  };
  url: "/api/v1/parsing/job/{job_id}/result/text";
};

export type GetJobTextResultApiV1ParsingJobJobIdResultTextGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type GetJobTextResultApiV1ParsingJobJobIdResultTextGetError =
  GetJobTextResultApiV1ParsingJobJobIdResultTextGetErrors[keyof GetJobTextResultApiV1ParsingJobJobIdResultTextGetErrors];

export type GetJobTextResultApiV1ParsingJobJobIdResultTextGetResponses = {
  /**
   * Successful Response
   */
  200: ParsingJobTextResult;
};

export type GetJobTextResultApiV1ParsingJobJobIdResultTextGetResponse =
  GetJobTextResultApiV1ParsingJobJobIdResultTextGetResponses[keyof GetJobTextResultApiV1ParsingJobJobIdResultTextGetResponses];

export type GetJobRawTextResultRawApiV1ParsingJobJobIdResultRawTextGetData = {
  body?: never;
  path: {
    job_id: string;
  };
  query?: never;
  url: "/api/v1/parsing/job/{job_id}/result/raw/text";
};

export type GetJobRawTextResultRawApiV1ParsingJobJobIdResultRawTextGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type GetJobRawTextResultRawApiV1ParsingJobJobIdResultRawTextGetError =
  GetJobRawTextResultRawApiV1ParsingJobJobIdResultRawTextGetErrors[keyof GetJobRawTextResultRawApiV1ParsingJobJobIdResultRawTextGetErrors];

export type GetJobRawTextResultRawApiV1ParsingJobJobIdResultRawTextGetResponses =
  {
    /**
     * Successful Response
     */
    200: unknown;
  };

export type GetJobRawTextResultApiV1ParsingJobJobIdResultPdfGetData = {
  body?: never;
  path: {
    job_id: string;
  };
  query?: never;
  url: "/api/v1/parsing/job/{job_id}/result/pdf";
};

export type GetJobRawTextResultApiV1ParsingJobJobIdResultPdfGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type GetJobRawTextResultApiV1ParsingJobJobIdResultPdfGetError =
  GetJobRawTextResultApiV1ParsingJobJobIdResultPdfGetErrors[keyof GetJobRawTextResultApiV1ParsingJobJobIdResultPdfGetErrors];

export type GetJobRawTextResultApiV1ParsingJobJobIdResultPdfGetResponses = {
  /**
   * Successful Response
   */
  200: unknown;
};

export type GetJobRawTextResultRawPdfApiV1ParsingJobJobIdResultRawPdfGetData = {
  body?: never;
  path: {
    job_id: string;
  };
  query?: never;
  url: "/api/v1/parsing/job/{job_id}/result/raw/pdf";
};

export type GetJobRawTextResultRawPdfApiV1ParsingJobJobIdResultRawPdfGetErrors =
  {
    /**
     * Validation Error
     */
    422: HttpValidationError;
  };

export type GetJobRawTextResultRawPdfApiV1ParsingJobJobIdResultRawPdfGetError =
  GetJobRawTextResultRawPdfApiV1ParsingJobJobIdResultRawPdfGetErrors[keyof GetJobRawTextResultRawPdfApiV1ParsingJobJobIdResultRawPdfGetErrors];

export type GetJobRawTextResultRawPdfApiV1ParsingJobJobIdResultRawPdfGetResponses =
  {
    /**
     * Successful Response
     */
    200: unknown;
  };

export type GetJobStructuredResultApiV1ParsingJobJobIdResultStructuredGetData =
  {
    body?: never;
    path: {
      job_id: string;
    };
    query?: {
      organization_id?: string | null;
    };
    url: "/api/v1/parsing/job/{job_id}/result/structured";
  };

export type GetJobStructuredResultApiV1ParsingJobJobIdResultStructuredGetErrors =
  {
    /**
     * Validation Error
     */
    422: HttpValidationError;
  };

export type GetJobStructuredResultApiV1ParsingJobJobIdResultStructuredGetError =
  GetJobStructuredResultApiV1ParsingJobJobIdResultStructuredGetErrors[keyof GetJobStructuredResultApiV1ParsingJobJobIdResultStructuredGetErrors];

export type GetJobStructuredResultApiV1ParsingJobJobIdResultStructuredGetResponses =
  {
    /**
     * Successful Response
     */
    200: ParsingJobStructuredResult;
  };

export type GetJobStructuredResultApiV1ParsingJobJobIdResultStructuredGetResponse =
  GetJobStructuredResultApiV1ParsingJobJobIdResultStructuredGetResponses[keyof GetJobStructuredResultApiV1ParsingJobJobIdResultStructuredGetResponses];

export type GetJobRawStructuredResultApiV1ParsingJobJobIdResultRawStructuredGetData =
  {
    body?: never;
    path: {
      job_id: string;
    };
    query?: never;
    url: "/api/v1/parsing/job/{job_id}/result/raw/structured";
  };

export type GetJobRawStructuredResultApiV1ParsingJobJobIdResultRawStructuredGetErrors =
  {
    /**
     * Validation Error
     */
    422: HttpValidationError;
  };

export type GetJobRawStructuredResultApiV1ParsingJobJobIdResultRawStructuredGetError =
  GetJobRawStructuredResultApiV1ParsingJobJobIdResultRawStructuredGetErrors[keyof GetJobRawStructuredResultApiV1ParsingJobJobIdResultRawStructuredGetErrors];

export type GetJobRawStructuredResultApiV1ParsingJobJobIdResultRawStructuredGetResponses =
  {
    /**
     * Successful Response
     */
    200: unknown;
  };

export type GetJobRawXlsxResultApiV1ParsingJobJobIdResultXlsxGetData = {
  body?: never;
  path: {
    job_id: string;
  };
  query?: never;
  url: "/api/v1/parsing/job/{job_id}/result/xlsx";
};

export type GetJobRawXlsxResultApiV1ParsingJobJobIdResultXlsxGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type GetJobRawXlsxResultApiV1ParsingJobJobIdResultXlsxGetError =
  GetJobRawXlsxResultApiV1ParsingJobJobIdResultXlsxGetErrors[keyof GetJobRawXlsxResultApiV1ParsingJobJobIdResultXlsxGetErrors];

export type GetJobRawXlsxResultApiV1ParsingJobJobIdResultXlsxGetResponses = {
  /**
   * Successful Response
   */
  200: unknown;
};

export type GetJobRawXlsxResultRawApiV1ParsingJobJobIdResultRawXlsxGetData = {
  body?: never;
  path: {
    job_id: string;
  };
  query?: never;
  url: "/api/v1/parsing/job/{job_id}/result/raw/xlsx";
};

export type GetJobRawXlsxResultRawApiV1ParsingJobJobIdResultRawXlsxGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type GetJobRawXlsxResultRawApiV1ParsingJobJobIdResultRawXlsxGetError =
  GetJobRawXlsxResultRawApiV1ParsingJobJobIdResultRawXlsxGetErrors[keyof GetJobRawXlsxResultRawApiV1ParsingJobJobIdResultRawXlsxGetErrors];

export type GetJobRawXlsxResultRawApiV1ParsingJobJobIdResultRawXlsxGetResponses =
  {
    /**
     * Successful Response
     */
    200: unknown;
  };

export type GetJobResultApiV1ParsingJobJobIdResultMarkdownGetData = {
  body?: never;
  path: {
    job_id: string;
  };
  query?: {
    organization_id?: string | null;
  };
  url: "/api/v1/parsing/job/{job_id}/result/markdown";
};

export type GetJobResultApiV1ParsingJobJobIdResultMarkdownGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type GetJobResultApiV1ParsingJobJobIdResultMarkdownGetError =
  GetJobResultApiV1ParsingJobJobIdResultMarkdownGetErrors[keyof GetJobResultApiV1ParsingJobJobIdResultMarkdownGetErrors];

export type GetJobResultApiV1ParsingJobJobIdResultMarkdownGetResponses = {
  /**
   * Successful Response
   */
  200: ParsingJobMarkdownResult;
};

export type GetJobResultApiV1ParsingJobJobIdResultMarkdownGetResponse =
  GetJobResultApiV1ParsingJobJobIdResultMarkdownGetResponses[keyof GetJobResultApiV1ParsingJobJobIdResultMarkdownGetResponses];

export type GetJobRawMdResultApiV1ParsingJobJobIdResultRawMarkdownGetData = {
  body?: never;
  path: {
    job_id: string;
  };
  query?: never;
  url: "/api/v1/parsing/job/{job_id}/result/raw/markdown";
};

export type GetJobRawMdResultApiV1ParsingJobJobIdResultRawMarkdownGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type GetJobRawMdResultApiV1ParsingJobJobIdResultRawMarkdownGetError =
  GetJobRawMdResultApiV1ParsingJobJobIdResultRawMarkdownGetErrors[keyof GetJobRawMdResultApiV1ParsingJobJobIdResultRawMarkdownGetErrors];

export type GetJobRawMdResultApiV1ParsingJobJobIdResultRawMarkdownGetResponses =
  {
    /**
     * Successful Response
     */
    200: unknown;
  };

export type GetJobJsonResultApiV1ParsingJobJobIdResultJsonGetData = {
  body?: never;
  path: {
    job_id: string;
  };
  query?: {
    organization_id?: string | null;
  };
  url: "/api/v1/parsing/job/{job_id}/result/json";
};

export type GetJobJsonResultApiV1ParsingJobJobIdResultJsonGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type GetJobJsonResultApiV1ParsingJobJobIdResultJsonGetError =
  GetJobJsonResultApiV1ParsingJobJobIdResultJsonGetErrors[keyof GetJobJsonResultApiV1ParsingJobJobIdResultJsonGetErrors];

export type GetJobJsonResultApiV1ParsingJobJobIdResultJsonGetResponses = {
  /**
   * Successful Response
   */
  200: ParsingJobJsonResult;
};

export type GetJobJsonResultApiV1ParsingJobJobIdResultJsonGetResponse =
  GetJobJsonResultApiV1ParsingJobJobIdResultJsonGetResponses[keyof GetJobJsonResultApiV1ParsingJobJobIdResultJsonGetResponses];

export type GetJobJsonRawResultApiV1ParsingJobJobIdResultRawJsonGetData = {
  body?: never;
  path: {
    job_id: string;
  };
  query?: never;
  url: "/api/v1/parsing/job/{job_id}/result/raw/json";
};

export type GetJobJsonRawResultApiV1ParsingJobJobIdResultRawJsonGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type GetJobJsonRawResultApiV1ParsingJobJobIdResultRawJsonGetError =
  GetJobJsonRawResultApiV1ParsingJobJobIdResultRawJsonGetErrors[keyof GetJobJsonRawResultApiV1ParsingJobJobIdResultRawJsonGetErrors];

export type GetJobJsonRawResultApiV1ParsingJobJobIdResultRawJsonGetResponses = {
  /**
   * Successful Response
   */
  200: unknown;
};

export type GetParsingHistoryResultApiV1ParsingHistoryGetData = {
  body?: never;
  path?: never;
  query?: never;
  url: "/api/v1/parsing/history";
};

export type GetParsingHistoryResultApiV1ParsingHistoryGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type GetParsingHistoryResultApiV1ParsingHistoryGetError =
  GetParsingHistoryResultApiV1ParsingHistoryGetErrors[keyof GetParsingHistoryResultApiV1ParsingHistoryGetErrors];

export type GetParsingHistoryResultApiV1ParsingHistoryGetResponses = {
  /**
   * Successful Response
   */
  200: Array<ParsingHistoryItem>;
};

export type GetParsingHistoryResultApiV1ParsingHistoryGetResponse =
  GetParsingHistoryResultApiV1ParsingHistoryGetResponses[keyof GetParsingHistoryResultApiV1ParsingHistoryGetResponses];

export type GeneratePresignedUrlApiV1ParsingJobJobIdReadFilenameGetData = {
  body?: never;
  path: {
    job_id: string;
    filename: string;
  };
  query?: never;
  url: "/api/v1/parsing/job/{job_id}/read/{filename}";
};

export type GeneratePresignedUrlApiV1ParsingJobJobIdReadFilenameGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type GeneratePresignedUrlApiV1ParsingJobJobIdReadFilenameGetError =
  GeneratePresignedUrlApiV1ParsingJobJobIdReadFilenameGetErrors[keyof GeneratePresignedUrlApiV1ParsingJobJobIdReadFilenameGetErrors];

export type GeneratePresignedUrlApiV1ParsingJobJobIdReadFilenameGetResponses = {
  /**
   * Successful Response
   */
  200: PresignedUrl;
};

export type GeneratePresignedUrlApiV1ParsingJobJobIdReadFilenameGetResponse =
  GeneratePresignedUrlApiV1ParsingJobJobIdReadFilenameGetResponses[keyof GeneratePresignedUrlApiV1ParsingJobJobIdReadFilenameGetResponses];

export type GetChatAppsApiV1AppsGetData = {
  body?: never;
  path?: never;
  query?: {
    project_id?: string | null;
    organization_id?: string | null;
  };
  url: "/api/v1/apps/";
};

export type GetChatAppsApiV1AppsGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type GetChatAppsApiV1AppsGetError =
  GetChatAppsApiV1AppsGetErrors[keyof GetChatAppsApiV1AppsGetErrors];

export type GetChatAppsApiV1AppsGetResponses = {
  /**
   * Successful Response
   */
  200: Array<ChatAppResponse>;
};

export type GetChatAppsApiV1AppsGetResponse =
  GetChatAppsApiV1AppsGetResponses[keyof GetChatAppsApiV1AppsGetResponses];

export type CreateChatAppApiV1AppsPostData = {
  body: ChatAppCreate;
  path?: never;
  query?: {
    project_id?: string | null;
    organization_id?: string | null;
  };
  url: "/api/v1/apps/";
};

export type CreateChatAppApiV1AppsPostErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type CreateChatAppApiV1AppsPostError =
  CreateChatAppApiV1AppsPostErrors[keyof CreateChatAppApiV1AppsPostErrors];

export type CreateChatAppApiV1AppsPostResponses = {
  /**
   * Successful Response
   */
  200: ChatApp;
};

export type CreateChatAppApiV1AppsPostResponse =
  CreateChatAppApiV1AppsPostResponses[keyof CreateChatAppApiV1AppsPostResponses];

export type DeleteChatAppApiV1AppsIdDeleteData = {
  body?: never;
  path: {
    id: string;
  };
  query?: never;
  url: "/api/v1/apps/{id}";
};

export type DeleteChatAppApiV1AppsIdDeleteErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type DeleteChatAppApiV1AppsIdDeleteError =
  DeleteChatAppApiV1AppsIdDeleteErrors[keyof DeleteChatAppApiV1AppsIdDeleteErrors];

export type DeleteChatAppApiV1AppsIdDeleteResponses = {
  /**
   * Successful Response
   */
  200: unknown;
};

export type GetChatAppApiV1AppsIdGetData = {
  body?: never;
  path: {
    id: string;
  };
  query?: never;
  url: "/api/v1/apps/{id}";
};

export type GetChatAppApiV1AppsIdGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type GetChatAppApiV1AppsIdGetError =
  GetChatAppApiV1AppsIdGetErrors[keyof GetChatAppApiV1AppsIdGetErrors];

export type GetChatAppApiV1AppsIdGetResponses = {
  /**
   * Successful Response
   */
  200: ChatApp;
};

export type GetChatAppApiV1AppsIdGetResponse =
  GetChatAppApiV1AppsIdGetResponses[keyof GetChatAppApiV1AppsIdGetResponses];

export type UpdateChatAppApiV1AppsIdPutData = {
  body: ChatAppUpdate;
  path: {
    id: string;
  };
  query?: {
    project_id?: string | null;
    organization_id?: string | null;
  };
  url: "/api/v1/apps/{id}";
};

export type UpdateChatAppApiV1AppsIdPutErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type UpdateChatAppApiV1AppsIdPutError =
  UpdateChatAppApiV1AppsIdPutErrors[keyof UpdateChatAppApiV1AppsIdPutErrors];

export type UpdateChatAppApiV1AppsIdPutResponses = {
  /**
   * Successful Response
   */
  200: ChatApp;
};

export type UpdateChatAppApiV1AppsIdPutResponse =
  UpdateChatAppApiV1AppsIdPutResponses[keyof UpdateChatAppApiV1AppsIdPutResponses];

export type ChatWithChatAppApiV1AppsIdChatPostData = {
  body: AppChatInputParams;
  path: {
    id: string;
  };
  query?: never;
  url: "/api/v1/apps/{id}/chat";
};

export type ChatWithChatAppApiV1AppsIdChatPostErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type ChatWithChatAppApiV1AppsIdChatPostError =
  ChatWithChatAppApiV1AppsIdChatPostErrors[keyof ChatWithChatAppApiV1AppsIdChatPostErrors];

export type ChatWithChatAppApiV1AppsIdChatPostResponses = {
  /**
   * Successful Response
   */
  200: unknown;
};

export type ListClassifyJobsApiV1ClassifierJobsGetData = {
  body?: never;
  path?: never;
  query?: {
    project_id?: string | null;
    organization_id?: string | null;
    page_size?: number | null;
    page_token?: string | null;
  };
  url: "/api/v1/classifier/jobs";
};

export type ListClassifyJobsApiV1ClassifierJobsGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type ListClassifyJobsApiV1ClassifierJobsGetError =
  ListClassifyJobsApiV1ClassifierJobsGetErrors[keyof ListClassifyJobsApiV1ClassifierJobsGetErrors];

export type ListClassifyJobsApiV1ClassifierJobsGetResponses = {
  /**
   * Successful Response
   */
  200: PaginatedResponseClassifyJob;
};

export type ListClassifyJobsApiV1ClassifierJobsGetResponse =
  ListClassifyJobsApiV1ClassifierJobsGetResponses[keyof ListClassifyJobsApiV1ClassifierJobsGetResponses];

export type CreateClassifyJobApiV1ClassifierJobsPostData = {
  body: ClassifyJobCreate;
  path?: never;
  query?: {
    project_id?: string | null;
    organization_id?: string | null;
  };
  url: "/api/v1/classifier/jobs";
};

export type CreateClassifyJobApiV1ClassifierJobsPostErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type CreateClassifyJobApiV1ClassifierJobsPostError =
  CreateClassifyJobApiV1ClassifierJobsPostErrors[keyof CreateClassifyJobApiV1ClassifierJobsPostErrors];

export type CreateClassifyJobApiV1ClassifierJobsPostResponses = {
  /**
   * Successful Response
   */
  200: ClassifyJob;
};

export type CreateClassifyJobApiV1ClassifierJobsPostResponse =
  CreateClassifyJobApiV1ClassifierJobsPostResponses[keyof CreateClassifyJobApiV1ClassifierJobsPostResponses];

export type GetClassifyJobApiV1ClassifierJobsClassifyJobIdGetData = {
  body?: never;
  path: {
    classify_job_id: string;
  };
  query?: {
    project_id?: string | null;
    organization_id?: string | null;
  };
  url: "/api/v1/classifier/jobs/{classify_job_id}";
};

export type GetClassifyJobApiV1ClassifierJobsClassifyJobIdGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type GetClassifyJobApiV1ClassifierJobsClassifyJobIdGetError =
  GetClassifyJobApiV1ClassifierJobsClassifyJobIdGetErrors[keyof GetClassifyJobApiV1ClassifierJobsClassifyJobIdGetErrors];

export type GetClassifyJobApiV1ClassifierJobsClassifyJobIdGetResponses = {
  /**
   * Successful Response
   */
  200: ClassifyJob;
};

export type GetClassifyJobApiV1ClassifierJobsClassifyJobIdGetResponse =
  GetClassifyJobApiV1ClassifierJobsClassifyJobIdGetResponses[keyof GetClassifyJobApiV1ClassifierJobsClassifyJobIdGetResponses];

export type GetClassificationJobResultsApiV1ClassifierJobsClassifyJobIdResultsGetData =
  {
    body?: never;
    path: {
      classify_job_id: string;
    };
    query?: {
      project_id?: string | null;
      organization_id?: string | null;
    };
    url: "/api/v1/classifier/jobs/{classify_job_id}/results";
  };

export type GetClassificationJobResultsApiV1ClassifierJobsClassifyJobIdResultsGetErrors =
  {
    /**
     * Validation Error
     */
    422: HttpValidationError;
  };

export type GetClassificationJobResultsApiV1ClassifierJobsClassifyJobIdResultsGetError =
  GetClassificationJobResultsApiV1ClassifierJobsClassifyJobIdResultsGetErrors[keyof GetClassificationJobResultsApiV1ClassifierJobsClassifyJobIdResultsGetErrors];

export type GetClassificationJobResultsApiV1ClassifierJobsClassifyJobIdResultsGetResponses =
  {
    /**
     * Successful Response
     */
    200: ClassifyJobResults;
  };

export type GetClassificationJobResultsApiV1ClassifierJobsClassifyJobIdResultsGetResponse =
  GetClassificationJobResultsApiV1ClassifierJobsClassifyJobIdResultsGetResponses[keyof GetClassificationJobResultsApiV1ClassifierJobsClassifyJobIdResultsGetResponses];

export type ReadSelfApiV1AuthMeGetData = {
  body?: never;
  path?: never;
  query?: never;
  url: "/api/v1/auth/me";
};

export type ReadSelfApiV1AuthMeGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type ReadSelfApiV1AuthMeGetError =
  ReadSelfApiV1AuthMeGetErrors[keyof ReadSelfApiV1AuthMeGetErrors];

export type ReadSelfApiV1AuthMeGetResponses = {
  /**
   * Successful Response
   */
  200: User;
};

export type ReadSelfApiV1AuthMeGetResponse =
  ReadSelfApiV1AuthMeGetResponses[keyof ReadSelfApiV1AuthMeGetResponses];

export type CreateCustomerPortalSessionApiV1BillingCustomerPortalSessionPostData =
  {
    body: CustomerPortalSessionCreatePayload;
    path?: never;
    query?: {
      organization_id?: string | null;
    };
    url: "/api/v1/billing/customer-portal-session";
  };

export type CreateCustomerPortalSessionApiV1BillingCustomerPortalSessionPostErrors =
  {
    /**
     * Validation Error
     */
    422: HttpValidationError;
  };

export type CreateCustomerPortalSessionApiV1BillingCustomerPortalSessionPostError =
  CreateCustomerPortalSessionApiV1BillingCustomerPortalSessionPostErrors[keyof CreateCustomerPortalSessionApiV1BillingCustomerPortalSessionPostErrors];

export type CreateCustomerPortalSessionApiV1BillingCustomerPortalSessionPostResponses =
  {
    /**
     * Successful Response
     */
    200: string;
  };

export type CreateCustomerPortalSessionApiV1BillingCustomerPortalSessionPostResponse =
  CreateCustomerPortalSessionApiV1BillingCustomerPortalSessionPostResponses[keyof CreateCustomerPortalSessionApiV1BillingCustomerPortalSessionPostResponses];

export type DowngradePlanApiV1BillingDowngradePlanPostData = {
  body?: never;
  path?: never;
  query: {
    organization_id: string;
  };
  url: "/api/v1/billing/downgrade-plan";
};

export type DowngradePlanApiV1BillingDowngradePlanPostErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type DowngradePlanApiV1BillingDowngradePlanPostError =
  DowngradePlanApiV1BillingDowngradePlanPostErrors[keyof DowngradePlanApiV1BillingDowngradePlanPostErrors];

export type DowngradePlanApiV1BillingDowngradePlanPostResponses = {
  /**
   * Successful Response
   */
  200: {
    [key: string]: "success";
  };
};

export type DowngradePlanApiV1BillingDowngradePlanPostResponse =
  DowngradePlanApiV1BillingDowngradePlanPostResponses[keyof DowngradePlanApiV1BillingDowngradePlanPostResponses];

export type CreateIntentAndCustomerSessionApiV1BillingCreateIntentAndCustomerSessionPostData =
  {
    body?: never;
    path?: never;
    query: {
      plan_name:
        | "free"
        | "llama_parse"
        | "enterprise"
        | "unknown"
        | "free_contract"
        | "pro"
        | "enterprise_contract"
        | "enterprise_poc"
        | "free_v1"
        | "starter_v1"
        | "pro_v1";
      organization_id?: string | null;
    };
    url: "/api/v1/billing/create-intent-and-customer-session";
  };

export type CreateIntentAndCustomerSessionApiV1BillingCreateIntentAndCustomerSessionPostErrors =
  {
    /**
     * Validation Error
     */
    422: HttpValidationError;
  };

export type CreateIntentAndCustomerSessionApiV1BillingCreateIntentAndCustomerSessionPostError =
  CreateIntentAndCustomerSessionApiV1BillingCreateIntentAndCustomerSessionPostErrors[keyof CreateIntentAndCustomerSessionApiV1BillingCreateIntentAndCustomerSessionPostErrors];

export type CreateIntentAndCustomerSessionApiV1BillingCreateIntentAndCustomerSessionPostResponses =
  {
    /**
     * Successful Response
     */
    200: CreateIntentAndCustomerSessionResponse;
  };

export type CreateIntentAndCustomerSessionApiV1BillingCreateIntentAndCustomerSessionPostResponse =
  CreateIntentAndCustomerSessionApiV1BillingCreateIntentAndCustomerSessionPostResponses[keyof CreateIntentAndCustomerSessionApiV1BillingCreateIntentAndCustomerSessionPostResponses];

export type GetMetronomeDashboardApiV1BillingMetronomeDashboardGetData = {
  body?: never;
  path?: never;
  query: {
    organization_id: string;
    /**
     * The type of dashboard to get
     */
    dashboard_type?: MetronomeDashboardType;
  };
  url: "/api/v1/billing/metronome/dashboard";
};

export type GetMetronomeDashboardApiV1BillingMetronomeDashboardGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type GetMetronomeDashboardApiV1BillingMetronomeDashboardGetError =
  GetMetronomeDashboardApiV1BillingMetronomeDashboardGetErrors[keyof GetMetronomeDashboardApiV1BillingMetronomeDashboardGetErrors];

export type GetMetronomeDashboardApiV1BillingMetronomeDashboardGetResponses = {
  /**
   * Successful Response
   */
  200: MetronomeDashboardResponse;
};

export type GetMetronomeDashboardApiV1BillingMetronomeDashboardGetResponse =
  GetMetronomeDashboardApiV1BillingMetronomeDashboardGetResponses[keyof GetMetronomeDashboardApiV1BillingMetronomeDashboardGetResponses];

export type ListExtractionAgentsApiV1ExtractionExtractionAgentsGetData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * Whether to include default agents in the results
     */
    include_default?: boolean;
    project_id?: string | null;
    organization_id?: string | null;
  };
  url: "/api/v1/extraction/extraction-agents";
};

export type ListExtractionAgentsApiV1ExtractionExtractionAgentsGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type ListExtractionAgentsApiV1ExtractionExtractionAgentsGetError =
  ListExtractionAgentsApiV1ExtractionExtractionAgentsGetErrors[keyof ListExtractionAgentsApiV1ExtractionExtractionAgentsGetErrors];

export type ListExtractionAgentsApiV1ExtractionExtractionAgentsGetResponses = {
  /**
   * Successful Response
   */
  200: Array<ExtractAgent>;
};

export type ListExtractionAgentsApiV1ExtractionExtractionAgentsGetResponse =
  ListExtractionAgentsApiV1ExtractionExtractionAgentsGetResponses[keyof ListExtractionAgentsApiV1ExtractionExtractionAgentsGetResponses];

export type CreateExtractionAgentApiV1ExtractionExtractionAgentsPostData = {
  body: ExtractAgentCreate;
  path?: never;
  query?: {
    project_id?: string | null;
    organization_id?: string | null;
  };
  url: "/api/v1/extraction/extraction-agents";
};

export type CreateExtractionAgentApiV1ExtractionExtractionAgentsPostErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type CreateExtractionAgentApiV1ExtractionExtractionAgentsPostError =
  CreateExtractionAgentApiV1ExtractionExtractionAgentsPostErrors[keyof CreateExtractionAgentApiV1ExtractionExtractionAgentsPostErrors];

export type CreateExtractionAgentApiV1ExtractionExtractionAgentsPostResponses =
  {
    /**
     * Successful Response
     */
    200: ExtractAgent;
  };

export type CreateExtractionAgentApiV1ExtractionExtractionAgentsPostResponse =
  CreateExtractionAgentApiV1ExtractionExtractionAgentsPostResponses[keyof CreateExtractionAgentApiV1ExtractionExtractionAgentsPostResponses];

export type ValidateExtractionSchemaApiV1ExtractionExtractionAgentsSchemaValidationPostData =
  {
    body: ExtractSchemaValidateRequest;
    path?: never;
    query?: never;
    url: "/api/v1/extraction/extraction-agents/schema/validation";
  };

export type ValidateExtractionSchemaApiV1ExtractionExtractionAgentsSchemaValidationPostErrors =
  {
    /**
     * Validation Error
     */
    422: HttpValidationError;
  };

export type ValidateExtractionSchemaApiV1ExtractionExtractionAgentsSchemaValidationPostError =
  ValidateExtractionSchemaApiV1ExtractionExtractionAgentsSchemaValidationPostErrors[keyof ValidateExtractionSchemaApiV1ExtractionExtractionAgentsSchemaValidationPostErrors];

export type ValidateExtractionSchemaApiV1ExtractionExtractionAgentsSchemaValidationPostResponses =
  {
    /**
     * Successful Response
     */
    200: ExtractSchemaValidateResponse;
  };

export type ValidateExtractionSchemaApiV1ExtractionExtractionAgentsSchemaValidationPostResponse =
  ValidateExtractionSchemaApiV1ExtractionExtractionAgentsSchemaValidationPostResponses[keyof ValidateExtractionSchemaApiV1ExtractionExtractionAgentsSchemaValidationPostResponses];

export type GenerateExtractionSchemaApiV1ExtractionExtractionAgentsSchemaGeneratePostData =
  {
    body: ExtractSchemaGenerateRequest;
    path?: never;
    query?: {
      project_id?: string | null;
      organization_id?: string | null;
    };
    url: "/api/v1/extraction/extraction-agents/schema/generate";
  };

export type GenerateExtractionSchemaApiV1ExtractionExtractionAgentsSchemaGeneratePostErrors =
  {
    /**
     * Validation Error
     */
    422: HttpValidationError;
  };

export type GenerateExtractionSchemaApiV1ExtractionExtractionAgentsSchemaGeneratePostError =
  GenerateExtractionSchemaApiV1ExtractionExtractionAgentsSchemaGeneratePostErrors[keyof GenerateExtractionSchemaApiV1ExtractionExtractionAgentsSchemaGeneratePostErrors];

export type GenerateExtractionSchemaApiV1ExtractionExtractionAgentsSchemaGeneratePostResponses =
  {
    /**
     * Successful Response
     */
    200: ExtractSchemaGenerateResponse;
  };

export type GenerateExtractionSchemaApiV1ExtractionExtractionAgentsSchemaGeneratePostResponse =
  GenerateExtractionSchemaApiV1ExtractionExtractionAgentsSchemaGeneratePostResponses[keyof GenerateExtractionSchemaApiV1ExtractionExtractionAgentsSchemaGeneratePostResponses];

export type GetExtractionAgentByNameApiV1ExtractionExtractionAgentsByNameNameGetData =
  {
    body?: never;
    path: {
      name: string;
    };
    query?: {
      project_id?: string | null;
      organization_id?: string | null;
    };
    url: "/api/v1/extraction/extraction-agents/by-name/{name}";
  };

export type GetExtractionAgentByNameApiV1ExtractionExtractionAgentsByNameNameGetErrors =
  {
    /**
     * Validation Error
     */
    422: HttpValidationError;
  };

export type GetExtractionAgentByNameApiV1ExtractionExtractionAgentsByNameNameGetError =
  GetExtractionAgentByNameApiV1ExtractionExtractionAgentsByNameNameGetErrors[keyof GetExtractionAgentByNameApiV1ExtractionExtractionAgentsByNameNameGetErrors];

export type GetExtractionAgentByNameApiV1ExtractionExtractionAgentsByNameNameGetResponses =
  {
    /**
     * Successful Response
     */
    200: ExtractAgent;
  };

export type GetExtractionAgentByNameApiV1ExtractionExtractionAgentsByNameNameGetResponse =
  GetExtractionAgentByNameApiV1ExtractionExtractionAgentsByNameNameGetResponses[keyof GetExtractionAgentByNameApiV1ExtractionExtractionAgentsByNameNameGetResponses];

export type GetOrCreateDefaultExtractionAgentApiV1ExtractionExtractionAgentsDefaultGetData =
  {
    body?: never;
    path?: never;
    query?: {
      project_id?: string | null;
      organization_id?: string | null;
    };
    url: "/api/v1/extraction/extraction-agents/default";
  };

export type GetOrCreateDefaultExtractionAgentApiV1ExtractionExtractionAgentsDefaultGetErrors =
  {
    /**
     * Validation Error
     */
    422: HttpValidationError;
  };

export type GetOrCreateDefaultExtractionAgentApiV1ExtractionExtractionAgentsDefaultGetError =
  GetOrCreateDefaultExtractionAgentApiV1ExtractionExtractionAgentsDefaultGetErrors[keyof GetOrCreateDefaultExtractionAgentApiV1ExtractionExtractionAgentsDefaultGetErrors];

export type GetOrCreateDefaultExtractionAgentApiV1ExtractionExtractionAgentsDefaultGetResponses =
  {
    /**
     * Successful Response
     */
    200: ExtractAgent;
  };

export type GetOrCreateDefaultExtractionAgentApiV1ExtractionExtractionAgentsDefaultGetResponse =
  GetOrCreateDefaultExtractionAgentApiV1ExtractionExtractionAgentsDefaultGetResponses[keyof GetOrCreateDefaultExtractionAgentApiV1ExtractionExtractionAgentsDefaultGetResponses];

export type DeleteExtractionAgentApiV1ExtractionExtractionAgentsExtractionAgentIdDeleteData =
  {
    body?: never;
    path: {
      extraction_agent_id: string;
    };
    query?: never;
    url: "/api/v1/extraction/extraction-agents/{extraction_agent_id}";
  };

export type DeleteExtractionAgentApiV1ExtractionExtractionAgentsExtractionAgentIdDeleteErrors =
  {
    /**
     * Validation Error
     */
    422: HttpValidationError;
  };

export type DeleteExtractionAgentApiV1ExtractionExtractionAgentsExtractionAgentIdDeleteError =
  DeleteExtractionAgentApiV1ExtractionExtractionAgentsExtractionAgentIdDeleteErrors[keyof DeleteExtractionAgentApiV1ExtractionExtractionAgentsExtractionAgentIdDeleteErrors];

export type DeleteExtractionAgentApiV1ExtractionExtractionAgentsExtractionAgentIdDeleteResponses =
  {
    /**
     * Successful Response
     */
    200: unknown;
  };

export type GetExtractionAgentApiV1ExtractionExtractionAgentsExtractionAgentIdGetData =
  {
    body?: never;
    path: {
      extraction_agent_id: string;
    };
    query?: never;
    url: "/api/v1/extraction/extraction-agents/{extraction_agent_id}";
  };

export type GetExtractionAgentApiV1ExtractionExtractionAgentsExtractionAgentIdGetErrors =
  {
    /**
     * Validation Error
     */
    422: HttpValidationError;
  };

export type GetExtractionAgentApiV1ExtractionExtractionAgentsExtractionAgentIdGetError =
  GetExtractionAgentApiV1ExtractionExtractionAgentsExtractionAgentIdGetErrors[keyof GetExtractionAgentApiV1ExtractionExtractionAgentsExtractionAgentIdGetErrors];

export type GetExtractionAgentApiV1ExtractionExtractionAgentsExtractionAgentIdGetResponses =
  {
    /**
     * Successful Response
     */
    200: ExtractAgent;
  };

export type GetExtractionAgentApiV1ExtractionExtractionAgentsExtractionAgentIdGetResponse =
  GetExtractionAgentApiV1ExtractionExtractionAgentsExtractionAgentIdGetResponses[keyof GetExtractionAgentApiV1ExtractionExtractionAgentsExtractionAgentIdGetResponses];

export type UpdateExtractionAgentApiV1ExtractionExtractionAgentsExtractionAgentIdPutData =
  {
    body: ExtractAgentUpdate;
    path: {
      extraction_agent_id: string;
    };
    query?: never;
    url: "/api/v1/extraction/extraction-agents/{extraction_agent_id}";
  };

export type UpdateExtractionAgentApiV1ExtractionExtractionAgentsExtractionAgentIdPutErrors =
  {
    /**
     * Validation Error
     */
    422: HttpValidationError;
  };

export type UpdateExtractionAgentApiV1ExtractionExtractionAgentsExtractionAgentIdPutError =
  UpdateExtractionAgentApiV1ExtractionExtractionAgentsExtractionAgentIdPutErrors[keyof UpdateExtractionAgentApiV1ExtractionExtractionAgentsExtractionAgentIdPutErrors];

export type UpdateExtractionAgentApiV1ExtractionExtractionAgentsExtractionAgentIdPutResponses =
  {
    /**
     * Successful Response
     */
    200: ExtractAgent;
  };

export type UpdateExtractionAgentApiV1ExtractionExtractionAgentsExtractionAgentIdPutResponse =
  UpdateExtractionAgentApiV1ExtractionExtractionAgentsExtractionAgentIdPutResponses[keyof UpdateExtractionAgentApiV1ExtractionExtractionAgentsExtractionAgentIdPutResponses];

export type ListJobsApiV1ExtractionJobsGetData = {
  body?: never;
  path?: never;
  query: {
    extraction_agent_id: string;
  };
  url: "/api/v1/extraction/jobs";
};

export type ListJobsApiV1ExtractionJobsGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type ListJobsApiV1ExtractionJobsGetError =
  ListJobsApiV1ExtractionJobsGetErrors[keyof ListJobsApiV1ExtractionJobsGetErrors];

export type ListJobsApiV1ExtractionJobsGetResponses = {
  /**
   * Successful Response
   */
  200: Array<ExtractJob>;
};

export type ListJobsApiV1ExtractionJobsGetResponse =
  ListJobsApiV1ExtractionJobsGetResponses[keyof ListJobsApiV1ExtractionJobsGetResponses];

export type RunJobApiV1ExtractionJobsPostData = {
  body: ExtractJobCreate;
  path?: never;
  query?: {
    from_ui?: boolean;
  };
  url: "/api/v1/extraction/jobs";
};

export type RunJobApiV1ExtractionJobsPostErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type RunJobApiV1ExtractionJobsPostError =
  RunJobApiV1ExtractionJobsPostErrors[keyof RunJobApiV1ExtractionJobsPostErrors];

export type RunJobApiV1ExtractionJobsPostResponses = {
  /**
   * Successful Response
   */
  200: ExtractJob;
};

export type RunJobApiV1ExtractionJobsPostResponse =
  RunJobApiV1ExtractionJobsPostResponses[keyof RunJobApiV1ExtractionJobsPostResponses];

export type GetJobApiV1ExtractionJobsJobIdGetData = {
  body?: never;
  path: {
    job_id: string;
  };
  query?: never;
  url: "/api/v1/extraction/jobs/{job_id}";
};

export type GetJobApiV1ExtractionJobsJobIdGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type GetJobApiV1ExtractionJobsJobIdGetError =
  GetJobApiV1ExtractionJobsJobIdGetErrors[keyof GetJobApiV1ExtractionJobsJobIdGetErrors];

export type GetJobApiV1ExtractionJobsJobIdGetResponses = {
  /**
   * Successful Response
   */
  200: ExtractJob;
};

export type GetJobApiV1ExtractionJobsJobIdGetResponse =
  GetJobApiV1ExtractionJobsJobIdGetResponses[keyof GetJobApiV1ExtractionJobsJobIdGetResponses];

export type RunJobTestUserApiV1ExtractionJobsTestPostData = {
  body: BodyRunJobTestUserApiV1ExtractionJobsTestPost;
  path?: never;
  query?: {
    from_ui?: boolean;
  };
  url: "/api/v1/extraction/jobs/test";
};

export type RunJobTestUserApiV1ExtractionJobsTestPostErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type RunJobTestUserApiV1ExtractionJobsTestPostError =
  RunJobTestUserApiV1ExtractionJobsTestPostErrors[keyof RunJobTestUserApiV1ExtractionJobsTestPostErrors];

export type RunJobTestUserApiV1ExtractionJobsTestPostResponses = {
  /**
   * Successful Response
   */
  200: ExtractJob;
};

export type RunJobTestUserApiV1ExtractionJobsTestPostResponse =
  RunJobTestUserApiV1ExtractionJobsTestPostResponses[keyof RunJobTestUserApiV1ExtractionJobsTestPostResponses];

export type RunJobOnFileApiV1ExtractionJobsFilePostData = {
  body: BodyRunJobOnFileApiV1ExtractionJobsFilePost;
  path?: never;
  query?: {
    from_ui?: boolean;
  };
  url: "/api/v1/extraction/jobs/file";
};

export type RunJobOnFileApiV1ExtractionJobsFilePostErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type RunJobOnFileApiV1ExtractionJobsFilePostError =
  RunJobOnFileApiV1ExtractionJobsFilePostErrors[keyof RunJobOnFileApiV1ExtractionJobsFilePostErrors];

export type RunJobOnFileApiV1ExtractionJobsFilePostResponses = {
  /**
   * Successful Response
   */
  200: ExtractJob;
};

export type RunJobOnFileApiV1ExtractionJobsFilePostResponse =
  RunJobOnFileApiV1ExtractionJobsFilePostResponses[keyof RunJobOnFileApiV1ExtractionJobsFilePostResponses];

export type RunBatchJobsApiV1ExtractionJobsBatchPostData = {
  body: ExtractJobCreateBatch;
  path?: never;
  query?: {
    from_ui?: boolean;
  };
  url: "/api/v1/extraction/jobs/batch";
};

export type RunBatchJobsApiV1ExtractionJobsBatchPostErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type RunBatchJobsApiV1ExtractionJobsBatchPostError =
  RunBatchJobsApiV1ExtractionJobsBatchPostErrors[keyof RunBatchJobsApiV1ExtractionJobsBatchPostErrors];

export type RunBatchJobsApiV1ExtractionJobsBatchPostResponses = {
  /**
   * Successful Response
   */
  200: Array<ExtractJob>;
};

export type RunBatchJobsApiV1ExtractionJobsBatchPostResponse =
  RunBatchJobsApiV1ExtractionJobsBatchPostResponses[keyof RunBatchJobsApiV1ExtractionJobsBatchPostResponses];

export type GetJobResultApiV1ExtractionJobsJobIdResultGetData = {
  body?: never;
  path: {
    job_id: string;
  };
  query?: {
    project_id?: string | null;
    organization_id?: string | null;
  };
  url: "/api/v1/extraction/jobs/{job_id}/result";
};

export type GetJobResultApiV1ExtractionJobsJobIdResultGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type GetJobResultApiV1ExtractionJobsJobIdResultGetError =
  GetJobResultApiV1ExtractionJobsJobIdResultGetErrors[keyof GetJobResultApiV1ExtractionJobsJobIdResultGetErrors];

export type GetJobResultApiV1ExtractionJobsJobIdResultGetResponses = {
  /**
   * Successful Response
   */
  200: ExtractResultset;
};

export type GetJobResultApiV1ExtractionJobsJobIdResultGetResponse =
  GetJobResultApiV1ExtractionJobsJobIdResultGetResponses[keyof GetJobResultApiV1ExtractionJobsJobIdResultGetResponses];

export type ListExtractRunsApiV1ExtractionRunsGetData = {
  body?: never;
  path?: never;
  query: {
    extraction_agent_id: string;
    skip?: number;
    limit?: number;
  };
  url: "/api/v1/extraction/runs";
};

export type ListExtractRunsApiV1ExtractionRunsGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type ListExtractRunsApiV1ExtractionRunsGetError =
  ListExtractRunsApiV1ExtractionRunsGetErrors[keyof ListExtractRunsApiV1ExtractionRunsGetErrors];

export type ListExtractRunsApiV1ExtractionRunsGetResponses = {
  /**
   * Successful Response
   */
  200: PaginatedExtractRunsResponse;
};

export type ListExtractRunsApiV1ExtractionRunsGetResponse =
  ListExtractRunsApiV1ExtractionRunsGetResponses[keyof ListExtractRunsApiV1ExtractionRunsGetResponses];

export type GetLatestRunFromUiApiV1ExtractionRunsLatestFromUiGetData = {
  body?: never;
  path?: never;
  query: {
    extraction_agent_id: string;
  };
  url: "/api/v1/extraction/runs/latest-from-ui";
};

export type GetLatestRunFromUiApiV1ExtractionRunsLatestFromUiGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type GetLatestRunFromUiApiV1ExtractionRunsLatestFromUiGetError =
  GetLatestRunFromUiApiV1ExtractionRunsLatestFromUiGetErrors[keyof GetLatestRunFromUiApiV1ExtractionRunsLatestFromUiGetErrors];

export type GetLatestRunFromUiApiV1ExtractionRunsLatestFromUiGetResponses = {
  /**
   * Successful Response
   */
  200: ExtractRun | null;
};

export type GetLatestRunFromUiApiV1ExtractionRunsLatestFromUiGetResponse =
  GetLatestRunFromUiApiV1ExtractionRunsLatestFromUiGetResponses[keyof GetLatestRunFromUiApiV1ExtractionRunsLatestFromUiGetResponses];

export type GetRunByJobIdApiV1ExtractionRunsByJobJobIdGetData = {
  body?: never;
  path: {
    job_id: string;
  };
  query?: {
    project_id?: string | null;
    organization_id?: string | null;
  };
  url: "/api/v1/extraction/runs/by-job/{job_id}";
};

export type GetRunByJobIdApiV1ExtractionRunsByJobJobIdGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type GetRunByJobIdApiV1ExtractionRunsByJobJobIdGetError =
  GetRunByJobIdApiV1ExtractionRunsByJobJobIdGetErrors[keyof GetRunByJobIdApiV1ExtractionRunsByJobJobIdGetErrors];

export type GetRunByJobIdApiV1ExtractionRunsByJobJobIdGetResponses = {
  /**
   * Successful Response
   */
  200: ExtractRun;
};

export type GetRunByJobIdApiV1ExtractionRunsByJobJobIdGetResponse =
  GetRunByJobIdApiV1ExtractionRunsByJobJobIdGetResponses[keyof GetRunByJobIdApiV1ExtractionRunsByJobJobIdGetResponses];

export type DeleteExtractionRunApiV1ExtractionRunsRunIdDeleteData = {
  body?: never;
  path: {
    run_id: string;
  };
  query?: {
    project_id?: string | null;
    organization_id?: string | null;
  };
  url: "/api/v1/extraction/runs/{run_id}";
};

export type DeleteExtractionRunApiV1ExtractionRunsRunIdDeleteErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type DeleteExtractionRunApiV1ExtractionRunsRunIdDeleteError =
  DeleteExtractionRunApiV1ExtractionRunsRunIdDeleteErrors[keyof DeleteExtractionRunApiV1ExtractionRunsRunIdDeleteErrors];

export type DeleteExtractionRunApiV1ExtractionRunsRunIdDeleteResponses = {
  /**
   * Successful Response
   */
  200: unknown;
};

export type GetRunApiV1ExtractionRunsRunIdGetData = {
  body?: never;
  path: {
    run_id: string;
  };
  query?: {
    project_id?: string | null;
    organization_id?: string | null;
  };
  url: "/api/v1/extraction/runs/{run_id}";
};

export type GetRunApiV1ExtractionRunsRunIdGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type GetRunApiV1ExtractionRunsRunIdGetError =
  GetRunApiV1ExtractionRunsRunIdGetErrors[keyof GetRunApiV1ExtractionRunsRunIdGetErrors];

export type GetRunApiV1ExtractionRunsRunIdGetResponses = {
  /**
   * Successful Response
   */
  200: ExtractRun;
};

export type GetRunApiV1ExtractionRunsRunIdGetResponse =
  GetRunApiV1ExtractionRunsRunIdGetResponses[keyof GetRunApiV1ExtractionRunsRunIdGetResponses];

export type ExtractStatelessApiV1ExtractionRunPostData = {
  body: ExtractStatelessRequest;
  path?: never;
  query?: {
    project_id?: string | null;
    organization_id?: string | null;
  };
  url: "/api/v1/extraction/run";
};

export type ExtractStatelessApiV1ExtractionRunPostErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type ExtractStatelessApiV1ExtractionRunPostError =
  ExtractStatelessApiV1ExtractionRunPostErrors[keyof ExtractStatelessApiV1ExtractionRunPostErrors];

export type ExtractStatelessApiV1ExtractionRunPostResponses = {
  /**
   * Successful Response
   */
  200: ExtractJob;
};

export type ExtractStatelessApiV1ExtractionRunPostResponse =
  ExtractStatelessApiV1ExtractionRunPostResponses[keyof ExtractStatelessApiV1ExtractionRunPostResponses];

export type ListApiKeysApiV1BetaApiKeysGetData = {
  body?: never;
  path?: never;
  query?: {
    page_size?: number | null;
    page_token?: string | null;
    name?: string | null;
    project_id?: string | null;
    key_type?: ApiKeyType | null;
  };
  url: "/api/v1/beta/api-keys";
};

export type ListApiKeysApiV1BetaApiKeysGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type ListApiKeysApiV1BetaApiKeysGetError =
  ListApiKeysApiV1BetaApiKeysGetErrors[keyof ListApiKeysApiV1BetaApiKeysGetErrors];

export type ListApiKeysApiV1BetaApiKeysGetResponses = {
  /**
   * Successful Response
   */
  200: ApiKeyQueryResponse;
};

export type ListApiKeysApiV1BetaApiKeysGetResponse =
  ListApiKeysApiV1BetaApiKeysGetResponses[keyof ListApiKeysApiV1BetaApiKeysGetResponses];

export type CreateApiKeyApiV1BetaApiKeysPostData = {
  body: ApiKeyCreate;
  path?: never;
  query?: never;
  url: "/api/v1/beta/api-keys";
};

export type CreateApiKeyApiV1BetaApiKeysPostErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type CreateApiKeyApiV1BetaApiKeysPostError =
  CreateApiKeyApiV1BetaApiKeysPostErrors[keyof CreateApiKeyApiV1BetaApiKeysPostErrors];

export type CreateApiKeyApiV1BetaApiKeysPostResponses = {
  /**
   * Successful Response
   */
  201: ApiKey;
};

export type CreateApiKeyApiV1BetaApiKeysPostResponse =
  CreateApiKeyApiV1BetaApiKeysPostResponses[keyof CreateApiKeyApiV1BetaApiKeysPostResponses];

export type DeleteApiKeyApiV1BetaApiKeysApiKeyIdDeleteData = {
  body?: never;
  path: {
    api_key_id: string;
  };
  query?: never;
  url: "/api/v1/beta/api-keys/{api_key_id}";
};

export type DeleteApiKeyApiV1BetaApiKeysApiKeyIdDeleteErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type DeleteApiKeyApiV1BetaApiKeysApiKeyIdDeleteError =
  DeleteApiKeyApiV1BetaApiKeysApiKeyIdDeleteErrors[keyof DeleteApiKeyApiV1BetaApiKeysApiKeyIdDeleteErrors];

export type DeleteApiKeyApiV1BetaApiKeysApiKeyIdDeleteResponses = {
  /**
   * Successful Response
   */
  204: void;
};

export type DeleteApiKeyApiV1BetaApiKeysApiKeyIdDeleteResponse =
  DeleteApiKeyApiV1BetaApiKeysApiKeyIdDeleteResponses[keyof DeleteApiKeyApiV1BetaApiKeysApiKeyIdDeleteResponses];

export type GetApiKeyApiV1BetaApiKeysApiKeyIdGetData = {
  body?: never;
  path: {
    api_key_id: string;
  };
  query?: never;
  url: "/api/v1/beta/api-keys/{api_key_id}";
};

export type GetApiKeyApiV1BetaApiKeysApiKeyIdGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type GetApiKeyApiV1BetaApiKeysApiKeyIdGetError =
  GetApiKeyApiV1BetaApiKeysApiKeyIdGetErrors[keyof GetApiKeyApiV1BetaApiKeysApiKeyIdGetErrors];

export type GetApiKeyApiV1BetaApiKeysApiKeyIdGetResponses = {
  /**
   * Successful Response
   */
  200: ApiKey;
};

export type GetApiKeyApiV1BetaApiKeysApiKeyIdGetResponse =
  GetApiKeyApiV1BetaApiKeysApiKeyIdGetResponses[keyof GetApiKeyApiV1BetaApiKeysApiKeyIdGetResponses];

export type ListBatchesApiV1BetaBatchesGetData = {
  body?: never;
  path?: never;
  query?: {
    limit?: number;
    offset?: number;
    project_id?: string | null;
    organization_id?: string | null;
  };
  url: "/api/v1/beta/batches";
};

export type ListBatchesApiV1BetaBatchesGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type ListBatchesApiV1BetaBatchesGetError =
  ListBatchesApiV1BetaBatchesGetErrors[keyof ListBatchesApiV1BetaBatchesGetErrors];

export type ListBatchesApiV1BetaBatchesGetResponses = {
  /**
   * Successful Response
   */
  200: BatchPaginatedList;
};

export type ListBatchesApiV1BetaBatchesGetResponse =
  ListBatchesApiV1BetaBatchesGetResponses[keyof ListBatchesApiV1BetaBatchesGetResponses];

export type CreateBatchApiV1BetaBatchesPostData = {
  body: BatchCreate;
  path?: never;
  query?: {
    organization_id?: string | null;
    project_id?: string | null;
  };
  url: "/api/v1/beta/batches";
};

export type CreateBatchApiV1BetaBatchesPostErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type CreateBatchApiV1BetaBatchesPostError =
  CreateBatchApiV1BetaBatchesPostErrors[keyof CreateBatchApiV1BetaBatchesPostErrors];

export type CreateBatchApiV1BetaBatchesPostResponses = {
  /**
   * Successful Response
   */
  200: Batch;
};

export type CreateBatchApiV1BetaBatchesPostResponse =
  CreateBatchApiV1BetaBatchesPostResponses[keyof CreateBatchApiV1BetaBatchesPostResponses];

export type GetBatchApiV1BetaBatchesBatchIdGetData = {
  body?: never;
  path: {
    batch_id: string;
  };
  query?: {
    organization_id?: string | null;
  };
  url: "/api/v1/beta/batches/{batch_id}";
};

export type GetBatchApiV1BetaBatchesBatchIdGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type GetBatchApiV1BetaBatchesBatchIdGetError =
  GetBatchApiV1BetaBatchesBatchIdGetErrors[keyof GetBatchApiV1BetaBatchesBatchIdGetErrors];

export type GetBatchApiV1BetaBatchesBatchIdGetResponses = {
  /**
   * Successful Response
   */
  200: BatchPublicOutput;
};

export type GetBatchApiV1BetaBatchesBatchIdGetResponse =
  GetBatchApiV1BetaBatchesBatchIdGetResponses[keyof GetBatchApiV1BetaBatchesBatchIdGetResponses];

export type DeleteAgentDataApiV1BetaAgentDataItemIdDeleteData = {
  body?: never;
  path: {
    item_id: string;
  };
  query?: {
    project_id?: string | null;
    organization_id?: string | null;
  };
  url: "/api/v1/beta/agent-data/{item_id}";
};

export type DeleteAgentDataApiV1BetaAgentDataItemIdDeleteErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type DeleteAgentDataApiV1BetaAgentDataItemIdDeleteError =
  DeleteAgentDataApiV1BetaAgentDataItemIdDeleteErrors[keyof DeleteAgentDataApiV1BetaAgentDataItemIdDeleteErrors];

export type DeleteAgentDataApiV1BetaAgentDataItemIdDeleteResponses = {
  /**
   * Successful Response
   */
  200: {
    [key: string]: string;
  };
};

export type DeleteAgentDataApiV1BetaAgentDataItemIdDeleteResponse =
  DeleteAgentDataApiV1BetaAgentDataItemIdDeleteResponses[keyof DeleteAgentDataApiV1BetaAgentDataItemIdDeleteResponses];

export type GetAgentDataApiV1BetaAgentDataItemIdGetData = {
  body?: never;
  path: {
    item_id: string;
  };
  query?: {
    project_id?: string | null;
    organization_id?: string | null;
  };
  url: "/api/v1/beta/agent-data/{item_id}";
};

export type GetAgentDataApiV1BetaAgentDataItemIdGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type GetAgentDataApiV1BetaAgentDataItemIdGetError =
  GetAgentDataApiV1BetaAgentDataItemIdGetErrors[keyof GetAgentDataApiV1BetaAgentDataItemIdGetErrors];

export type GetAgentDataApiV1BetaAgentDataItemIdGetResponses = {
  /**
   * Successful Response
   */
  200: AgentData;
};

export type GetAgentDataApiV1BetaAgentDataItemIdGetResponse =
  GetAgentDataApiV1BetaAgentDataItemIdGetResponses[keyof GetAgentDataApiV1BetaAgentDataItemIdGetResponses];

export type UpdateAgentDataApiV1BetaAgentDataItemIdPutData = {
  body: AgentDataUpdate;
  path: {
    item_id: string;
  };
  query?: {
    project_id?: string | null;
    organization_id?: string | null;
  };
  url: "/api/v1/beta/agent-data/{item_id}";
};

export type UpdateAgentDataApiV1BetaAgentDataItemIdPutErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type UpdateAgentDataApiV1BetaAgentDataItemIdPutError =
  UpdateAgentDataApiV1BetaAgentDataItemIdPutErrors[keyof UpdateAgentDataApiV1BetaAgentDataItemIdPutErrors];

export type UpdateAgentDataApiV1BetaAgentDataItemIdPutResponses = {
  /**
   * Successful Response
   */
  200: AgentData;
};

export type UpdateAgentDataApiV1BetaAgentDataItemIdPutResponse =
  UpdateAgentDataApiV1BetaAgentDataItemIdPutResponses[keyof UpdateAgentDataApiV1BetaAgentDataItemIdPutResponses];

export type CreateAgentDataApiV1BetaAgentDataPostData = {
  body: AgentDataCreate;
  path?: never;
  query?: {
    project_id?: string | null;
    organization_id?: string | null;
  };
  url: "/api/v1/beta/agent-data";
};

export type CreateAgentDataApiV1BetaAgentDataPostErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type CreateAgentDataApiV1BetaAgentDataPostError =
  CreateAgentDataApiV1BetaAgentDataPostErrors[keyof CreateAgentDataApiV1BetaAgentDataPostErrors];

export type CreateAgentDataApiV1BetaAgentDataPostResponses = {
  /**
   * Successful Response
   */
  200: AgentData;
};

export type CreateAgentDataApiV1BetaAgentDataPostResponse =
  CreateAgentDataApiV1BetaAgentDataPostResponses[keyof CreateAgentDataApiV1BetaAgentDataPostResponses];

export type SearchAgentDataApiV1BetaAgentDataSearchPostData = {
  body: SearchRequest;
  path?: never;
  query?: {
    project_id?: string | null;
    organization_id?: string | null;
  };
  url: "/api/v1/beta/agent-data/:search";
};

export type SearchAgentDataApiV1BetaAgentDataSearchPostErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type SearchAgentDataApiV1BetaAgentDataSearchPostError =
  SearchAgentDataApiV1BetaAgentDataSearchPostErrors[keyof SearchAgentDataApiV1BetaAgentDataSearchPostErrors];

export type SearchAgentDataApiV1BetaAgentDataSearchPostResponses = {
  /**
   * Successful Response
   */
  200: PaginatedResponseAgentData;
};

export type SearchAgentDataApiV1BetaAgentDataSearchPostResponse =
  SearchAgentDataApiV1BetaAgentDataSearchPostResponses[keyof SearchAgentDataApiV1BetaAgentDataSearchPostResponses];

export type AggregateAgentDataApiV1BetaAgentDataAggregatePostData = {
  body: AggregateRequest;
  path?: never;
  query?: {
    project_id?: string | null;
    organization_id?: string | null;
  };
  url: "/api/v1/beta/agent-data/:aggregate";
};

export type AggregateAgentDataApiV1BetaAgentDataAggregatePostErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type AggregateAgentDataApiV1BetaAgentDataAggregatePostError =
  AggregateAgentDataApiV1BetaAgentDataAggregatePostErrors[keyof AggregateAgentDataApiV1BetaAgentDataAggregatePostErrors];

export type AggregateAgentDataApiV1BetaAgentDataAggregatePostResponses = {
  /**
   * Successful Response
   */
  200: PaginatedResponseAggregateGroup;
};

export type AggregateAgentDataApiV1BetaAgentDataAggregatePostResponse =
  AggregateAgentDataApiV1BetaAgentDataAggregatePostResponses[keyof AggregateAgentDataApiV1BetaAgentDataAggregatePostResponses];

export type ListQuotaConfigurationsApiV1BetaQuotaManagementGetData = {
  body?: never;
  path?: never;
  query: {
    source_type: "organization";
    source_id: string;
    page?: number;
    page_size?: number;
  };
  url: "/api/v1/beta/quota-management";
};

export type ListQuotaConfigurationsApiV1BetaQuotaManagementGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type ListQuotaConfigurationsApiV1BetaQuotaManagementGetError =
  ListQuotaConfigurationsApiV1BetaQuotaManagementGetErrors[keyof ListQuotaConfigurationsApiV1BetaQuotaManagementGetErrors];

export type ListQuotaConfigurationsApiV1BetaQuotaManagementGetResponses = {
  /**
   * Successful Response
   */
  200: PaginatedResponseQuotaConfiguration;
};

export type ListQuotaConfigurationsApiV1BetaQuotaManagementGetResponse =
  ListQuotaConfigurationsApiV1BetaQuotaManagementGetResponses[keyof ListQuotaConfigurationsApiV1BetaQuotaManagementGetResponses];

export type CreateFileApiV1BetaFilesPostData = {
  body: FileCreate;
  path?: never;
  query?: {
    project_id?: string | null;
    organization_id?: string | null;
  };
  url: "/api/v1/beta/files";
};

export type CreateFileApiV1BetaFilesPostErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type CreateFileApiV1BetaFilesPostError =
  CreateFileApiV1BetaFilesPostErrors[keyof CreateFileApiV1BetaFilesPostErrors];

export type CreateFileApiV1BetaFilesPostResponses = {
  /**
   * Successful Response
   */
  200: File;
};

export type CreateFileApiV1BetaFilesPostResponse =
  CreateFileApiV1BetaFilesPostResponses[keyof CreateFileApiV1BetaFilesPostResponses];

export type UpsertFileApiV1BetaFilesPutData = {
  body: FileCreate;
  path?: never;
  query?: {
    project_id?: string | null;
    organization_id?: string | null;
  };
  url: "/api/v1/beta/files";
};

export type UpsertFileApiV1BetaFilesPutErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type UpsertFileApiV1BetaFilesPutError =
  UpsertFileApiV1BetaFilesPutErrors[keyof UpsertFileApiV1BetaFilesPutErrors];

export type UpsertFileApiV1BetaFilesPutResponses = {
  /**
   * Successful Response
   */
  200: File;
};

export type UpsertFileApiV1BetaFilesPutResponse =
  UpsertFileApiV1BetaFilesPutResponses[keyof UpsertFileApiV1BetaFilesPutResponses];

export type QueryFilesApiV1BetaFilesQueryPostData = {
  body: FileQueryRequest;
  path?: never;
  query?: {
    project_id?: string | null;
    organization_id?: string | null;
  };
  url: "/api/v1/beta/files/query";
};

export type QueryFilesApiV1BetaFilesQueryPostErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type QueryFilesApiV1BetaFilesQueryPostError =
  QueryFilesApiV1BetaFilesQueryPostErrors[keyof QueryFilesApiV1BetaFilesQueryPostErrors];

export type QueryFilesApiV1BetaFilesQueryPostResponses = {
  /**
   * Successful Response
   */
  200: FileQueryResponse;
};

export type QueryFilesApiV1BetaFilesQueryPostResponse =
  QueryFilesApiV1BetaFilesQueryPostResponses[keyof QueryFilesApiV1BetaFilesQueryPostResponses];

export type DeleteFileApiV1BetaFilesFileIdDeleteData = {
  body?: never;
  path: {
    file_id: string;
  };
  query?: {
    project_id?: string | null;
    organization_id?: string | null;
  };
  url: "/api/v1/beta/files/{file_id}";
};

export type DeleteFileApiV1BetaFilesFileIdDeleteErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type DeleteFileApiV1BetaFilesFileIdDeleteError =
  DeleteFileApiV1BetaFilesFileIdDeleteErrors[keyof DeleteFileApiV1BetaFilesFileIdDeleteErrors];

export type DeleteFileApiV1BetaFilesFileIdDeleteResponses = {
  /**
   * Successful Response
   */
  204: void;
};

export type DeleteFileApiV1BetaFilesFileIdDeleteResponse =
  DeleteFileApiV1BetaFilesFileIdDeleteResponses[keyof DeleteFileApiV1BetaFilesFileIdDeleteResponses];

export type ListParseConfigurationsApiV1BetaParseConfigurationsGetData = {
  body?: never;
  path?: never;
  query?: {
    page_size?: number | null;
    page_token?: string | null;
    name?: string | null;
    creator?: string | null;
    version?: string | null;
    project_id?: string | null;
    organization_id?: string | null;
  };
  url: "/api/v1/beta/parse-configurations";
};

export type ListParseConfigurationsApiV1BetaParseConfigurationsGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type ListParseConfigurationsApiV1BetaParseConfigurationsGetError =
  ListParseConfigurationsApiV1BetaParseConfigurationsGetErrors[keyof ListParseConfigurationsApiV1BetaParseConfigurationsGetErrors];

export type ListParseConfigurationsApiV1BetaParseConfigurationsGetResponses = {
  /**
   * Successful Response
   */
  200: ParseConfigurationQueryResponse;
};

export type ListParseConfigurationsApiV1BetaParseConfigurationsGetResponse =
  ListParseConfigurationsApiV1BetaParseConfigurationsGetResponses[keyof ListParseConfigurationsApiV1BetaParseConfigurationsGetResponses];

export type CreateParseConfigurationApiV1BetaParseConfigurationsPostData = {
  body: ParseConfigurationCreate;
  path?: never;
  query?: {
    project_id?: string | null;
    organization_id?: string | null;
  };
  url: "/api/v1/beta/parse-configurations";
};

export type CreateParseConfigurationApiV1BetaParseConfigurationsPostErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type CreateParseConfigurationApiV1BetaParseConfigurationsPostError =
  CreateParseConfigurationApiV1BetaParseConfigurationsPostErrors[keyof CreateParseConfigurationApiV1BetaParseConfigurationsPostErrors];

export type CreateParseConfigurationApiV1BetaParseConfigurationsPostResponses =
  {
    /**
     * Successful Response
     */
    201: ParseConfiguration;
  };

export type CreateParseConfigurationApiV1BetaParseConfigurationsPostResponse =
  CreateParseConfigurationApiV1BetaParseConfigurationsPostResponses[keyof CreateParseConfigurationApiV1BetaParseConfigurationsPostResponses];

export type UpsertParseConfigurationApiV1BetaParseConfigurationsPutData = {
  body: ParseConfigurationCreate;
  path?: never;
  query?: {
    project_id?: string | null;
    organization_id?: string | null;
  };
  url: "/api/v1/beta/parse-configurations";
};

export type UpsertParseConfigurationApiV1BetaParseConfigurationsPutErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type UpsertParseConfigurationApiV1BetaParseConfigurationsPutError =
  UpsertParseConfigurationApiV1BetaParseConfigurationsPutErrors[keyof UpsertParseConfigurationApiV1BetaParseConfigurationsPutErrors];

export type UpsertParseConfigurationApiV1BetaParseConfigurationsPutResponses = {
  /**
   * Successful Response
   */
  200: ParseConfiguration;
};

export type UpsertParseConfigurationApiV1BetaParseConfigurationsPutResponse =
  UpsertParseConfigurationApiV1BetaParseConfigurationsPutResponses[keyof UpsertParseConfigurationApiV1BetaParseConfigurationsPutResponses];

export type DeleteParseConfigurationApiV1BetaParseConfigurationsConfigIdDeleteData =
  {
    body?: never;
    path: {
      config_id: string;
    };
    query?: {
      project_id?: string | null;
      organization_id?: string | null;
    };
    url: "/api/v1/beta/parse-configurations/{config_id}";
  };

export type DeleteParseConfigurationApiV1BetaParseConfigurationsConfigIdDeleteErrors =
  {
    /**
     * Validation Error
     */
    422: HttpValidationError;
  };

export type DeleteParseConfigurationApiV1BetaParseConfigurationsConfigIdDeleteError =
  DeleteParseConfigurationApiV1BetaParseConfigurationsConfigIdDeleteErrors[keyof DeleteParseConfigurationApiV1BetaParseConfigurationsConfigIdDeleteErrors];

export type DeleteParseConfigurationApiV1BetaParseConfigurationsConfigIdDeleteResponses =
  {
    /**
     * Successful Response
     */
    204: void;
  };

export type DeleteParseConfigurationApiV1BetaParseConfigurationsConfigIdDeleteResponse =
  DeleteParseConfigurationApiV1BetaParseConfigurationsConfigIdDeleteResponses[keyof DeleteParseConfigurationApiV1BetaParseConfigurationsConfigIdDeleteResponses];

export type GetParseConfigurationApiV1BetaParseConfigurationsConfigIdGetData = {
  body?: never;
  path: {
    config_id: string;
  };
  query?: {
    project_id?: string | null;
    organization_id?: string | null;
  };
  url: "/api/v1/beta/parse-configurations/{config_id}";
};

export type GetParseConfigurationApiV1BetaParseConfigurationsConfigIdGetErrors =
  {
    /**
     * Validation Error
     */
    422: HttpValidationError;
  };

export type GetParseConfigurationApiV1BetaParseConfigurationsConfigIdGetError =
  GetParseConfigurationApiV1BetaParseConfigurationsConfigIdGetErrors[keyof GetParseConfigurationApiV1BetaParseConfigurationsConfigIdGetErrors];

export type GetParseConfigurationApiV1BetaParseConfigurationsConfigIdGetResponses =
  {
    /**
     * Successful Response
     */
    200: ParseConfiguration;
  };

export type GetParseConfigurationApiV1BetaParseConfigurationsConfigIdGetResponse =
  GetParseConfigurationApiV1BetaParseConfigurationsConfigIdGetResponses[keyof GetParseConfigurationApiV1BetaParseConfigurationsConfigIdGetResponses];

export type UpdateParseConfigurationApiV1BetaParseConfigurationsConfigIdPutData =
  {
    body: ParseConfigurationUpdate;
    path: {
      config_id: string;
    };
    query?: {
      project_id?: string | null;
      organization_id?: string | null;
    };
    url: "/api/v1/beta/parse-configurations/{config_id}";
  };

export type UpdateParseConfigurationApiV1BetaParseConfigurationsConfigIdPutErrors =
  {
    /**
     * Validation Error
     */
    422: HttpValidationError;
  };

export type UpdateParseConfigurationApiV1BetaParseConfigurationsConfigIdPutError =
  UpdateParseConfigurationApiV1BetaParseConfigurationsConfigIdPutErrors[keyof UpdateParseConfigurationApiV1BetaParseConfigurationsConfigIdPutErrors];

export type UpdateParseConfigurationApiV1BetaParseConfigurationsConfigIdPutResponses =
  {
    /**
     * Successful Response
     */
    200: ParseConfiguration;
  };

export type UpdateParseConfigurationApiV1BetaParseConfigurationsConfigIdPutResponse =
  UpdateParseConfigurationApiV1BetaParseConfigurationsConfigIdPutResponses[keyof UpdateParseConfigurationApiV1BetaParseConfigurationsConfigIdPutResponses];

export type QueryParseConfigurationsApiV1BetaParseConfigurationsQueryPostData =
  {
    body: ParseConfigurationQueryRequest;
    path?: never;
    query?: {
      project_id?: string | null;
      organization_id?: string | null;
    };
    url: "/api/v1/beta/parse-configurations/query";
  };

export type QueryParseConfigurationsApiV1BetaParseConfigurationsQueryPostErrors =
  {
    /**
     * Validation Error
     */
    422: HttpValidationError;
  };

export type QueryParseConfigurationsApiV1BetaParseConfigurationsQueryPostError =
  QueryParseConfigurationsApiV1BetaParseConfigurationsQueryPostErrors[keyof QueryParseConfigurationsApiV1BetaParseConfigurationsQueryPostErrors];

export type QueryParseConfigurationsApiV1BetaParseConfigurationsQueryPostResponses =
  {
    /**
     * Successful Response
     */
    200: ParseConfigurationQueryResponse;
  };

export type QueryParseConfigurationsApiV1BetaParseConfigurationsQueryPostResponse =
  QueryParseConfigurationsApiV1BetaParseConfigurationsQueryPostResponses[keyof QueryParseConfigurationsApiV1BetaParseConfigurationsQueryPostResponses];

export type GetLatestParseConfigurationApiV1BetaParseConfigurationsLatestGetData =
  {
    body?: never;
    path?: never;
    query?: {
      creator?: string | null;
      project_id?: string | null;
      organization_id?: string | null;
    };
    url: "/api/v1/beta/parse-configurations/latest";
  };

export type GetLatestParseConfigurationApiV1BetaParseConfigurationsLatestGetErrors =
  {
    /**
     * Validation Error
     */
    422: HttpValidationError;
  };

export type GetLatestParseConfigurationApiV1BetaParseConfigurationsLatestGetError =
  GetLatestParseConfigurationApiV1BetaParseConfigurationsLatestGetErrors[keyof GetLatestParseConfigurationApiV1BetaParseConfigurationsLatestGetErrors];

export type GetLatestParseConfigurationApiV1BetaParseConfigurationsLatestGetResponses =
  {
    /**
     * Successful Response
     */
    200: ParseConfiguration | null;
  };

export type GetLatestParseConfigurationApiV1BetaParseConfigurationsLatestGetResponse =
  GetLatestParseConfigurationApiV1BetaParseConfigurationsLatestGetResponses[keyof GetLatestParseConfigurationApiV1BetaParseConfigurationsLatestGetResponses];

export type UploadFileV2ApiV2Alpha1ParseUploadPostData = {
  body: BodyUploadFileV2ApiV2Alpha1ParseUploadPost;
  path?: never;
  query?: {
    project_id?: string | null;
    organization_id?: string | null;
  };
  url: "/api/v2alpha1/parse/upload";
};

export type UploadFileV2ApiV2Alpha1ParseUploadPostErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type UploadFileV2ApiV2Alpha1ParseUploadPostError =
  UploadFileV2ApiV2Alpha1ParseUploadPostErrors[keyof UploadFileV2ApiV2Alpha1ParseUploadPostErrors];

export type UploadFileV2ApiV2Alpha1ParseUploadPostResponses = {
  /**
   * Successful Response
   */
  200: ParsingJob;
};

export type UploadFileV2ApiV2Alpha1ParseUploadPostResponse =
  UploadFileV2ApiV2Alpha1ParseUploadPostResponses[keyof UploadFileV2ApiV2Alpha1ParseUploadPostResponses];

export type GetJobImageResultApiParsingJobJobIdResultImageNameGetData = {
  body?: never;
  path: {
    job_id: string;
    name: string;
  };
  query?: never;
  url: "/api/parsing/job/{job_id}/result/image/{name}";
};

export type GetJobImageResultApiParsingJobJobIdResultImageNameGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type GetJobImageResultApiParsingJobJobIdResultImageNameGetError =
  GetJobImageResultApiParsingJobJobIdResultImageNameGetErrors[keyof GetJobImageResultApiParsingJobJobIdResultImageNameGetErrors];

export type GetJobImageResultApiParsingJobJobIdResultImageNameGetResponses = {
  /**
   * Successful Response
   */
  200: unknown;
};

export type GetSupportedFileExtensionsApiParsingSupportedFileExtensionsGetData =
  {
    body?: never;
    path?: never;
    query?: never;
    url: "/api/parsing/supported_file_extensions";
  };

export type GetSupportedFileExtensionsApiParsingSupportedFileExtensionsGetResponses =
  {
    /**
     * Successful Response
     */
    200: Array<LlamaParseSupportedFileExtensions>;
  };

export type GetSupportedFileExtensionsApiParsingSupportedFileExtensionsGetResponse =
  GetSupportedFileExtensionsApiParsingSupportedFileExtensionsGetResponses[keyof GetSupportedFileExtensionsApiParsingSupportedFileExtensionsGetResponses];

export type ScreenshotApiParsingScreenshotPostData = {
  body?: BodyScreenshotApiParsingScreenshotPost;
  path?: never;
  query?: {
    organization_id?: string | null;
    project_id?: string | null;
  };
  url: "/api/parsing/screenshot";
};

export type ScreenshotApiParsingScreenshotPostErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type ScreenshotApiParsingScreenshotPostError =
  ScreenshotApiParsingScreenshotPostErrors[keyof ScreenshotApiParsingScreenshotPostErrors];

export type ScreenshotApiParsingScreenshotPostResponses = {
  /**
   * Successful Response
   */
  200: ParsingJob;
};

export type ScreenshotApiParsingScreenshotPostResponse =
  ScreenshotApiParsingScreenshotPostResponses[keyof ScreenshotApiParsingScreenshotPostResponses];

export type UploadFileApiParsingUploadPostData = {
  body?: BodyUploadFileApiParsingUploadPost;
  path?: never;
  query?: {
    organization_id?: string | null;
    project_id?: string | null;
  };
  url: "/api/parsing/upload";
};

export type UploadFileApiParsingUploadPostErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type UploadFileApiParsingUploadPostError =
  UploadFileApiParsingUploadPostErrors[keyof UploadFileApiParsingUploadPostErrors];

export type UploadFileApiParsingUploadPostResponses = {
  /**
   * Successful Response
   */
  200: ParsingJob;
};

export type UploadFileApiParsingUploadPostResponse =
  UploadFileApiParsingUploadPostResponses[keyof UploadFileApiParsingUploadPostResponses];

export type GetJobApiParsingJobJobIdGetData = {
  body?: never;
  path: {
    job_id: string;
  };
  query?: never;
  url: "/api/parsing/job/{job_id}";
};

export type GetJobApiParsingJobJobIdGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type GetJobApiParsingJobJobIdGetError =
  GetJobApiParsingJobJobIdGetErrors[keyof GetJobApiParsingJobJobIdGetErrors];

export type GetJobApiParsingJobJobIdGetResponses = {
  /**
   * Successful Response
   */
  200: ParsingJob;
};

export type GetJobApiParsingJobJobIdGetResponse =
  GetJobApiParsingJobJobIdGetResponses[keyof GetJobApiParsingJobJobIdGetResponses];

export type GetJobParametersApiParsingJobJobIdParametersGetData = {
  body?: never;
  path: {
    job_id: string;
  };
  query?: never;
  url: "/api/parsing/job/{job_id}/parameters";
};

export type GetJobParametersApiParsingJobJobIdParametersGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type GetJobParametersApiParsingJobJobIdParametersGetError =
  GetJobParametersApiParsingJobJobIdParametersGetErrors[keyof GetJobParametersApiParsingJobJobIdParametersGetErrors];

export type GetJobParametersApiParsingJobJobIdParametersGetResponses = {
  /**
   * Successful Response
   */
  200: unknown;
};

export type GetParsingJobDetailsApiParsingJobJobIdDetailsGetData = {
  body?: never;
  path: {
    job_id: string;
  };
  query?: never;
  url: "/api/parsing/job/{job_id}/details";
};

export type GetParsingJobDetailsApiParsingJobJobIdDetailsGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type GetParsingJobDetailsApiParsingJobJobIdDetailsGetError =
  GetParsingJobDetailsApiParsingJobJobIdDetailsGetErrors[keyof GetParsingJobDetailsApiParsingJobJobIdDetailsGetErrors];

export type GetParsingJobDetailsApiParsingJobJobIdDetailsGetResponses = {
  /**
   * Successful Response
   */
  200: unknown;
};

export type GetJobTextResultApiParsingJobJobIdResultTextGetData = {
  body?: never;
  path: {
    job_id: string;
  };
  query?: {
    organization_id?: string | null;
  };
  url: "/api/parsing/job/{job_id}/result/text";
};

export type GetJobTextResultApiParsingJobJobIdResultTextGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type GetJobTextResultApiParsingJobJobIdResultTextGetError =
  GetJobTextResultApiParsingJobJobIdResultTextGetErrors[keyof GetJobTextResultApiParsingJobJobIdResultTextGetErrors];

export type GetJobTextResultApiParsingJobJobIdResultTextGetResponses = {
  /**
   * Successful Response
   */
  200: ParsingJobTextResult;
};

export type GetJobTextResultApiParsingJobJobIdResultTextGetResponse =
  GetJobTextResultApiParsingJobJobIdResultTextGetResponses[keyof GetJobTextResultApiParsingJobJobIdResultTextGetResponses];

export type GetJobRawTextResultRawApiParsingJobJobIdResultRawTextGetData = {
  body?: never;
  path: {
    job_id: string;
  };
  query?: never;
  url: "/api/parsing/job/{job_id}/result/raw/text";
};

export type GetJobRawTextResultRawApiParsingJobJobIdResultRawTextGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type GetJobRawTextResultRawApiParsingJobJobIdResultRawTextGetError =
  GetJobRawTextResultRawApiParsingJobJobIdResultRawTextGetErrors[keyof GetJobRawTextResultRawApiParsingJobJobIdResultRawTextGetErrors];

export type GetJobRawTextResultRawApiParsingJobJobIdResultRawTextGetResponses =
  {
    /**
     * Successful Response
     */
    200: unknown;
  };

export type GetJobRawTextResultApiParsingJobJobIdResultPdfGetData = {
  body?: never;
  path: {
    job_id: string;
  };
  query?: never;
  url: "/api/parsing/job/{job_id}/result/pdf";
};

export type GetJobRawTextResultApiParsingJobJobIdResultPdfGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type GetJobRawTextResultApiParsingJobJobIdResultPdfGetError =
  GetJobRawTextResultApiParsingJobJobIdResultPdfGetErrors[keyof GetJobRawTextResultApiParsingJobJobIdResultPdfGetErrors];

export type GetJobRawTextResultApiParsingJobJobIdResultPdfGetResponses = {
  /**
   * Successful Response
   */
  200: unknown;
};

export type GetJobRawTextResultRawPdfApiParsingJobJobIdResultRawPdfGetData = {
  body?: never;
  path: {
    job_id: string;
  };
  query?: never;
  url: "/api/parsing/job/{job_id}/result/raw/pdf";
};

export type GetJobRawTextResultRawPdfApiParsingJobJobIdResultRawPdfGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type GetJobRawTextResultRawPdfApiParsingJobJobIdResultRawPdfGetError =
  GetJobRawTextResultRawPdfApiParsingJobJobIdResultRawPdfGetErrors[keyof GetJobRawTextResultRawPdfApiParsingJobJobIdResultRawPdfGetErrors];

export type GetJobRawTextResultRawPdfApiParsingJobJobIdResultRawPdfGetResponses =
  {
    /**
     * Successful Response
     */
    200: unknown;
  };

export type GetJobStructuredResultApiParsingJobJobIdResultStructuredGetData = {
  body?: never;
  path: {
    job_id: string;
  };
  query?: {
    organization_id?: string | null;
  };
  url: "/api/parsing/job/{job_id}/result/structured";
};

export type GetJobStructuredResultApiParsingJobJobIdResultStructuredGetErrors =
  {
    /**
     * Validation Error
     */
    422: HttpValidationError;
  };

export type GetJobStructuredResultApiParsingJobJobIdResultStructuredGetError =
  GetJobStructuredResultApiParsingJobJobIdResultStructuredGetErrors[keyof GetJobStructuredResultApiParsingJobJobIdResultStructuredGetErrors];

export type GetJobStructuredResultApiParsingJobJobIdResultStructuredGetResponses =
  {
    /**
     * Successful Response
     */
    200: ParsingJobStructuredResult;
  };

export type GetJobStructuredResultApiParsingJobJobIdResultStructuredGetResponse =
  GetJobStructuredResultApiParsingJobJobIdResultStructuredGetResponses[keyof GetJobStructuredResultApiParsingJobJobIdResultStructuredGetResponses];

export type GetJobRawStructuredResultApiParsingJobJobIdResultRawStructuredGetData =
  {
    body?: never;
    path: {
      job_id: string;
    };
    query?: never;
    url: "/api/parsing/job/{job_id}/result/raw/structured";
  };

export type GetJobRawStructuredResultApiParsingJobJobIdResultRawStructuredGetErrors =
  {
    /**
     * Validation Error
     */
    422: HttpValidationError;
  };

export type GetJobRawStructuredResultApiParsingJobJobIdResultRawStructuredGetError =
  GetJobRawStructuredResultApiParsingJobJobIdResultRawStructuredGetErrors[keyof GetJobRawStructuredResultApiParsingJobJobIdResultRawStructuredGetErrors];

export type GetJobRawStructuredResultApiParsingJobJobIdResultRawStructuredGetResponses =
  {
    /**
     * Successful Response
     */
    200: unknown;
  };

export type GetJobRawXlsxResultApiParsingJobJobIdResultXlsxGetData = {
  body?: never;
  path: {
    job_id: string;
  };
  query?: never;
  url: "/api/parsing/job/{job_id}/result/xlsx";
};

export type GetJobRawXlsxResultApiParsingJobJobIdResultXlsxGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type GetJobRawXlsxResultApiParsingJobJobIdResultXlsxGetError =
  GetJobRawXlsxResultApiParsingJobJobIdResultXlsxGetErrors[keyof GetJobRawXlsxResultApiParsingJobJobIdResultXlsxGetErrors];

export type GetJobRawXlsxResultApiParsingJobJobIdResultXlsxGetResponses = {
  /**
   * Successful Response
   */
  200: unknown;
};

export type GetJobRawXlsxResultRawApiParsingJobJobIdResultRawXlsxGetData = {
  body?: never;
  path: {
    job_id: string;
  };
  query?: never;
  url: "/api/parsing/job/{job_id}/result/raw/xlsx";
};

export type GetJobRawXlsxResultRawApiParsingJobJobIdResultRawXlsxGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type GetJobRawXlsxResultRawApiParsingJobJobIdResultRawXlsxGetError =
  GetJobRawXlsxResultRawApiParsingJobJobIdResultRawXlsxGetErrors[keyof GetJobRawXlsxResultRawApiParsingJobJobIdResultRawXlsxGetErrors];

export type GetJobRawXlsxResultRawApiParsingJobJobIdResultRawXlsxGetResponses =
  {
    /**
     * Successful Response
     */
    200: unknown;
  };

export type GetJobResultApiParsingJobJobIdResultMarkdownGetData = {
  body?: never;
  path: {
    job_id: string;
  };
  query?: {
    organization_id?: string | null;
  };
  url: "/api/parsing/job/{job_id}/result/markdown";
};

export type GetJobResultApiParsingJobJobIdResultMarkdownGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type GetJobResultApiParsingJobJobIdResultMarkdownGetError =
  GetJobResultApiParsingJobJobIdResultMarkdownGetErrors[keyof GetJobResultApiParsingJobJobIdResultMarkdownGetErrors];

export type GetJobResultApiParsingJobJobIdResultMarkdownGetResponses = {
  /**
   * Successful Response
   */
  200: ParsingJobMarkdownResult;
};

export type GetJobResultApiParsingJobJobIdResultMarkdownGetResponse =
  GetJobResultApiParsingJobJobIdResultMarkdownGetResponses[keyof GetJobResultApiParsingJobJobIdResultMarkdownGetResponses];

export type GetJobRawMdResultApiParsingJobJobIdResultRawMarkdownGetData = {
  body?: never;
  path: {
    job_id: string;
  };
  query?: never;
  url: "/api/parsing/job/{job_id}/result/raw/markdown";
};

export type GetJobRawMdResultApiParsingJobJobIdResultRawMarkdownGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type GetJobRawMdResultApiParsingJobJobIdResultRawMarkdownGetError =
  GetJobRawMdResultApiParsingJobJobIdResultRawMarkdownGetErrors[keyof GetJobRawMdResultApiParsingJobJobIdResultRawMarkdownGetErrors];

export type GetJobRawMdResultApiParsingJobJobIdResultRawMarkdownGetResponses = {
  /**
   * Successful Response
   */
  200: unknown;
};

export type GetJobJsonResultApiParsingJobJobIdResultJsonGetData = {
  body?: never;
  path: {
    job_id: string;
  };
  query?: {
    organization_id?: string | null;
  };
  url: "/api/parsing/job/{job_id}/result/json";
};

export type GetJobJsonResultApiParsingJobJobIdResultJsonGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type GetJobJsonResultApiParsingJobJobIdResultJsonGetError =
  GetJobJsonResultApiParsingJobJobIdResultJsonGetErrors[keyof GetJobJsonResultApiParsingJobJobIdResultJsonGetErrors];

export type GetJobJsonResultApiParsingJobJobIdResultJsonGetResponses = {
  /**
   * Successful Response
   */
  200: ParsingJobJsonResult;
};

export type GetJobJsonResultApiParsingJobJobIdResultJsonGetResponse =
  GetJobJsonResultApiParsingJobJobIdResultJsonGetResponses[keyof GetJobJsonResultApiParsingJobJobIdResultJsonGetResponses];

export type GetJobJsonRawResultApiParsingJobJobIdResultRawJsonGetData = {
  body?: never;
  path: {
    job_id: string;
  };
  query?: never;
  url: "/api/parsing/job/{job_id}/result/raw/json";
};

export type GetJobJsonRawResultApiParsingJobJobIdResultRawJsonGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type GetJobJsonRawResultApiParsingJobJobIdResultRawJsonGetError =
  GetJobJsonRawResultApiParsingJobJobIdResultRawJsonGetErrors[keyof GetJobJsonRawResultApiParsingJobJobIdResultRawJsonGetErrors];

export type GetJobJsonRawResultApiParsingJobJobIdResultRawJsonGetResponses = {
  /**
   * Successful Response
   */
  200: unknown;
};

export type GetParsingHistoryResultApiParsingHistoryGetData = {
  body?: never;
  path?: never;
  query?: never;
  url: "/api/parsing/history";
};

export type GetParsingHistoryResultApiParsingHistoryGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type GetParsingHistoryResultApiParsingHistoryGetError =
  GetParsingHistoryResultApiParsingHistoryGetErrors[keyof GetParsingHistoryResultApiParsingHistoryGetErrors];

export type GetParsingHistoryResultApiParsingHistoryGetResponses = {
  /**
   * Successful Response
   */
  200: Array<ParsingHistoryItem>;
};

export type GetParsingHistoryResultApiParsingHistoryGetResponse =
  GetParsingHistoryResultApiParsingHistoryGetResponses[keyof GetParsingHistoryResultApiParsingHistoryGetResponses];

export type GeneratePresignedUrlApiParsingJobJobIdReadFilenameGetData = {
  body?: never;
  path: {
    job_id: string;
    filename: string;
  };
  query?: never;
  url: "/api/parsing/job/{job_id}/read/{filename}";
};

export type GeneratePresignedUrlApiParsingJobJobIdReadFilenameGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type GeneratePresignedUrlApiParsingJobJobIdReadFilenameGetError =
  GeneratePresignedUrlApiParsingJobJobIdReadFilenameGetErrors[keyof GeneratePresignedUrlApiParsingJobJobIdReadFilenameGetErrors];

export type GeneratePresignedUrlApiParsingJobJobIdReadFilenameGetResponses = {
  /**
   * Successful Response
   */
  200: PresignedUrl;
};

export type GeneratePresignedUrlApiParsingJobJobIdReadFilenameGetResponse =
  GeneratePresignedUrlApiParsingJobJobIdReadFilenameGetResponses[keyof GeneratePresignedUrlApiParsingJobJobIdReadFilenameGetResponses];

export type ClientOptions = {
  baseUrl: `${string}://${string}` | (string & {});
};
